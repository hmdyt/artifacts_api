// Code generated by ogen, DO NOT EDIT.

package openapi

import (
	"fmt"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/validate"
)

func (s *ActionItemBankResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *AddAccountSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    6,
			MinLengthSet: true,
			MaxLength:    32,
			MaxLengthSet: true,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[a-zA-Z0-9_-]+$"],
		}).Validate(string(s.Username)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "username",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.String{
			MinLength:    5,
			MinLengthSet: true,
			MaxLength:    50,
			MaxLengthSet: true,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[^ \f\n\r\t\v\u00a0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+$"],
		}).Validate(string(s.Password)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "password",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.String{
			MinLength:    0,
			MinLengthSet: false,
			MaxLength:    0,
			MaxLengthSet: false,
			Email:        true,
			Hostname:     false,
			Regex:        nil,
		}).Validate(string(s.Email)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "email",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *AddCharacterSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    3,
			MinLengthSet: true,
			MaxLength:    12,
			MaxLengthSet: true,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[a-zA-Z0-9_-]+$"],
		}).Validate(string(s.Name)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "name",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s AddCharacterSchemaSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *BankItemSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Item.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "item",
			Error: err,
		})
	}
	if err := func() error {
		if s.Bank == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Bank {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "bank",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *BankItemSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s BankItemSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *BankItemSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s BankItemSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit_bank":
		return nil
	case "withdraw_bank":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "recycling":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *BankItemSchemaItem) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Level)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "level",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Craft.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "craft",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s BankItemSchemaItemCraft) Validate() error {
	switch s.Type {
	case CraftSchemaBankItemSchemaItemCraft:
		if err := s.CraftSchema.Validate(); err != nil {
			return err
		}
		return nil
	case NullBankItemSchemaItemCraft:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *ChangePassword) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    5,
			MinLengthSet: true,
			MaxLength:    50,
			MaxLengthSet: true,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[^ \f\n\r\t\v\u00a0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+$"],
		}).Validate(string(s.Password)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "password",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *CharacterFightDataSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Fight.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "fight",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *CharacterFightDataSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s CharacterFightDataSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *CharacterFightDataSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s CharacterFightDataSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit_bank":
		return nil
	case "withdraw_bank":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "recycling":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *CharacterFightDataSchemaFight) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Drops == nil {
			return errors.New("nil is invalid value")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "drops",
			Error: err,
		})
	}
	if err := func() error {
		if s.Logs == nil {
			return errors.New("nil is invalid value")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "logs",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Result.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "result",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s CharacterFightDataSchemaFightResult) Validate() error {
	switch s {
	case "win":
		return nil
	case "lose":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *CharacterFightResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *CharacterMovementDataSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *CharacterMovementDataSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s CharacterMovementDataSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *CharacterMovementDataSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s CharacterMovementDataSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit_bank":
		return nil
	case "withdraw_bank":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "recycling":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *CharacterMovementResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *CharacterResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *CharacterSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s CharacterSchemaSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *CraftSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if value, ok := s.Skill.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skill",
			Error: err,
		})
	}
	if err := func() error {
		var failures []validate.FieldError
		for i, elem := range s.Items {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "items",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s CraftSchemaSkill) Validate() error {
	switch s.Type {
	case CraftSchemaSkill0CraftSchemaSkill:
		if err := s.CraftSchemaSkill0.Validate(); err != nil {
			return err
		}
		return nil
	case NullCraftSchemaSkill:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s CraftSchemaSkill0) Validate() error {
	switch s {
	case "weaponcrafting":
		return nil
	case "gearcrafting":
		return nil
	case "jewelrycrafting":
		return nil
	case "cooking":
		return nil
	case "woodcutting":
		return nil
	case "mining":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *CraftingSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    0,
			MinLengthSet: false,
			MaxLength:    0,
			MaxLengthSet: false,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[a-zA-Z0-9_-]+$"],
		}).Validate(string(s.Code)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "code",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Quantity.Get(); ok {
			if err := func() error {
				if err := (validate.Int{
					MinSet:        true,
					Min:           1,
					MaxSet:        false,
					Max:           0,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(value)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *DataPageCharacterSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Data {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageCharacterSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageCharacterSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageCharacterSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageCharacterSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageCharacterSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageCharacterSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageCharacterSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageCharacterSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageCharacterSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageCharacterSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageCharacterSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageCharacterSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageEventSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageEventSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageEventSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageEventSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageEventSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageEventSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageEventSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageEventSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageEventSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageEventSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageEventSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageEventSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageEventSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageGEItemSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageGEItemSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageGEItemSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageGEItemSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageGEItemSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageGEItemSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageGEItemSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageGEItemSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageGEItemSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageGEItemSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageGEItemSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageGEItemSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageGEItemSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageItemSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Data {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageItemSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageItemSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageItemSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageItemSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageItemSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageItemSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageItemSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageItemSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageItemSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageItemSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageItemSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageItemSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageLogSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageLogSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageLogSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageLogSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageLogSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageLogSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageLogSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageLogSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageLogSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageLogSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageLogSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageLogSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageLogSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageMapSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageMapSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageMapSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageMapSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageMapSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageMapSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageMapSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageMapSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageMapSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageMapSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageMapSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageMapSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageMapSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageMonsterSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Data {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageMonsterSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageMonsterSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageMonsterSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageMonsterSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageMonsterSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageMonsterSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageMonsterSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageMonsterSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageMonsterSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageMonsterSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageMonsterSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageMonsterSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageResourceSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Data {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageResourceSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageResourceSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageResourceSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageResourceSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageResourceSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageResourceSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageResourceSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageResourceSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageResourceSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageResourceSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageResourceSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageResourceSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageSimpleItemSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Data {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageSimpleItemSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageSimpleItemSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageSimpleItemSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageSimpleItemSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageSimpleItemSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageSimpleItemSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageSimpleItemSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageSimpleItemSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageSimpleItemSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageSimpleItemSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageSimpleItemSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageSimpleItemSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DeleteItemResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *DeleteItemSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Item.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "item",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *DeleteItemSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DeleteItemSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *DeleteItemSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DeleteItemSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit_bank":
		return nil
	case "withdraw_bank":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "recycling":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *DeleteItemSchemaItem) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    0,
			MinLengthSet: false,
			MaxLength:    0,
			MaxLengthSet: false,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[a-zA-Z0-9_-]+$"],
		}).Validate(string(s.Code)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "code",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Quantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *DepositWithdrawGoldSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Quantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *DropRateSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    0,
			MinLengthSet: false,
			MaxLength:    0,
			MaxLengthSet: false,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[a-zA-Z0-9_-]+$"],
		}).Validate(string(s.Code)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "code",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Rate)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "rate",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.MinQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "min_quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.MaxQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "max_quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *EquipRequestSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Slot.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "slot",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Item.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "item",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *EquipRequestSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s EquipRequestSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *EquipRequestSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s EquipRequestSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit_bank":
		return nil
	case "withdraw_bank":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "recycling":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *EquipRequestSchemaItem) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Level)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "level",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Craft.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "craft",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s EquipRequestSchemaItemCraft) Validate() error {
	switch s.Type {
	case CraftSchemaEquipRequestSchemaItemCraft:
		if err := s.CraftSchema.Validate(); err != nil {
			return err
		}
		return nil
	case NullEquipRequestSchemaItemCraft:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s EquipRequestSchemaSlot) Validate() error {
	switch s {
	case "weapon":
		return nil
	case "shield":
		return nil
	case "helmet":
		return nil
	case "body_armor":
		return nil
	case "leg_armor":
		return nil
	case "boots":
		return nil
	case "ring1":
		return nil
	case "ring2":
		return nil
	case "amulet":
		return nil
	case "artifact1":
		return nil
	case "artifact2":
		return nil
	case "artifact3":
		return nil
	case "consumable1":
		return nil
	case "consumable2":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *EquipSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    0,
			MinLengthSet: false,
			MaxLength:    0,
			MaxLengthSet: false,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[a-zA-Z0-9_-]+$"],
		}).Validate(string(s.Code)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "code",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Slot.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "slot",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s EquipSchemaSlot) Validate() error {
	switch s {
	case "weapon":
		return nil
	case "shield":
		return nil
	case "helmet":
		return nil
	case "body_armor":
		return nil
	case "leg_armor":
		return nil
	case "boots":
		return nil
	case "ring1":
		return nil
	case "ring2":
		return nil
	case "amulet":
		return nil
	case "artifact1":
		return nil
	case "artifact2":
		return nil
	case "artifact3":
		return nil
	case "consumable1":
		return nil
	case "consumable2":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *EquipmentResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *GETransactionItemSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    0,
			MinLengthSet: false,
			MaxLength:    0,
			MaxLengthSet: false,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[a-zA-Z0-9_-]+$"],
		}).Validate(string(s.Code)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "code",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        true,
			Max:           50,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Quantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Price)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "price",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *GETransactionListSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *GETransactionListSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s GETransactionListSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *GETransactionListSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s GETransactionListSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit_bank":
		return nil
	case "withdraw_bank":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "recycling":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *GETransactionResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s GetAllCharactersCharactersGetSort) Validate() error {
	switch s {
	case "woodcutting":
		return nil
	case "mining":
		return nil
	case "fishing":
		return nil
	case "weaponcrafting":
		return nil
	case "gearcrafting":
		return nil
	case "jewelrycrafting":
		return nil
	case "cooking":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s GetAllItemsItemsGetCraftSkill) Validate() error {
	switch s {
	case "weaponcrafting":
		return nil
	case "gearcrafting":
		return nil
	case "jewelrycrafting":
		return nil
	case "cooking":
		return nil
	case "woodcutting":
		return nil
	case "mining":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s GetAllItemsItemsGetType) Validate() error {
	switch s {
	case "consumable":
		return nil
	case "body_armor":
		return nil
	case "weapon":
		return nil
	case "resource":
		return nil
	case "leg_armor":
		return nil
	case "helmet":
		return nil
	case "boots":
		return nil
	case "shield":
		return nil
	case "amulet":
		return nil
	case "ring":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s GetAllMapsMapsGetContentType) Validate() error {
	switch s {
	case "monster":
		return nil
	case "resource":
		return nil
	case "workshop":
		return nil
	case "bank":
		return nil
	case "grand_exchange":
		return nil
	case "tasks_master":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s GetAllResourcesResourcesGetSkill) Validate() error {
	switch s {
	case "mining":
		return nil
	case "woodcutting":
		return nil
	case "fishing":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *GoldBankResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *GoldResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *GoldSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Quantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *GoldTransactionSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Bank.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "bank",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *GoldTransactionSchemaBank) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Quantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *GoldTransactionSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s GoldTransactionSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *GoldTransactionSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s GoldTransactionSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit_bank":
		return nil
	case "withdraw_bank":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "recycling":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *ItemResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *ItemSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Level)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "level",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Craft.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "craft",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s ItemSchemaCraft) Validate() error {
	switch s.Type {
	case CraftSchemaItemSchemaCraft:
		if err := s.CraftSchema.Validate(); err != nil {
			return err
		}
		return nil
	case NullItemSchemaCraft:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *MonsterResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *MonsterSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Drops == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Drops {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "drops",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *MyCharactersListSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Data {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *RecyclingDataSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Details.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "details",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *RecyclingDataSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s RecyclingDataSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *RecyclingDataSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s RecyclingDataSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit_bank":
		return nil
	case "withdraw_bank":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "recycling":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *RecyclingDataSchemaDetails) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Items == nil {
			return errors.New("nil is invalid value")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "items",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *RecyclingResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *RecyclingSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    0,
			MinLengthSet: false,
			MaxLength:    0,
			MaxLengthSet: false,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[a-zA-Z0-9_-]+$"],
		}).Validate(string(s.Code)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "code",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Quantity.Get(); ok {
			if err := func() error {
				if err := (validate.Int{
					MinSet:        true,
					Min:           1,
					MaxSet:        false,
					Max:           0,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(value)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *ResourceResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *ResourceSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skill.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skill",
			Error: err,
		})
	}
	if err := func() error {
		if s.Drops == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Drops {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "drops",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s ResourceSchemaSkill) Validate() error {
	switch s {
	case "mining":
		return nil
	case "woodcutting":
		return nil
	case "fishing":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *SimpleItemSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    0,
			MinLengthSet: false,
			MaxLength:    0,
			MaxLengthSet: false,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[a-zA-Z0-9_-]+$"],
		}).Validate(string(s.Code)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "code",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Quantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *SingleItemSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Item.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "item",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *SingleItemSchemaItem) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Level)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "level",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Craft.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "craft",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s SingleItemSchemaItemCraft) Validate() error {
	switch s.Type {
	case CraftSchemaSingleItemSchemaItemCraft:
		if err := s.CraftSchema.Validate(); err != nil {
			return err
		}
		return nil
	case NullSingleItemSchemaItemCraft:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *SkillDataSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Details.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "details",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *SkillDataSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s SkillDataSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *SkillDataSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s SkillDataSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit_bank":
		return nil
	case "withdraw_bank":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "recycling":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *SkillDataSchemaDetails) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Items == nil {
			return errors.New("nil is invalid value")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "items",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *SkillResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *TaskDataSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Task.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "task",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *TaskDataSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s TaskDataSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *TaskDataSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s TaskDataSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit_bank":
		return nil
	case "withdraw_bank":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "recycling":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *TaskDataSchemaTask) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Type.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "type",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s TaskDataSchemaTaskType) Validate() error {
	switch s {
	case "monsters":
		return nil
	case "resources":
		return nil
	case "crafts":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *TaskResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *TaskRewardDataSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *TaskRewardDataSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s TaskRewardDataSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *TaskRewardDataSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s TaskRewardDataSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit_bank":
		return nil
	case "withdraw_bank":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "recycling":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *TaskRewardResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *UnequipSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Slot.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "slot",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s UnequipSchemaSlot) Validate() error {
	switch s {
	case "weapon":
		return nil
	case "shield":
		return nil
	case "helmet":
		return nil
	case "body_armor":
		return nil
	case "leg_armor":
		return nil
	case "boots":
		return nil
	case "ring1":
		return nil
	case "ring2":
		return nil
	case "amulet":
		return nil
	case "artifact1":
		return nil
	case "artifact2":
		return nil
	case "artifact3":
		return nil
	case "consumable1":
		return nil
	case "consumable2":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}
