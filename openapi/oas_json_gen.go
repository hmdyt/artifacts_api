// Code generated by ogen, DO NOT EDIT.

package openapi

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *ActionItemBankResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionItemBankResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfActionItemBankResponseSchema = [1]string{
	0: "data",
}

// Decode decodes ActionItemBankResponseSchema from json.
func (s *ActionItemBankResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionItemBankResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionItemBankResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionItemBankResponseSchema) {
					name = jsonFieldsNameOfActionItemBankResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionItemBankResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionItemBankResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddAccountSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddAccountSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
}

var jsonFieldsNameOfAddAccountSchema = [3]string{
	0: "username",
	1: "password",
	2: "email",
}

// Decode decodes AddAccountSchema from json.
func (s *AddAccountSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddAccountSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddAccountSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddAccountSchema) {
					name = jsonFieldsNameOfAddAccountSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddAccountSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddAccountSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddCharacterSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddCharacterSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
}

var jsonFieldsNameOfAddCharacterSchema = [2]string{
	0: "name",
	1: "skin",
}

// Decode decodes AddCharacterSchema from json.
func (s *AddCharacterSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddCharacterSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddCharacterSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddCharacterSchema) {
					name = jsonFieldsNameOfAddCharacterSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddCharacterSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddCharacterSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddCharacterSchemaSkin as json.
func (s AddCharacterSchemaSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AddCharacterSchemaSkin from json.
func (s *AddCharacterSchemaSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddCharacterSchemaSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AddCharacterSchemaSkin(v) {
	case AddCharacterSchemaSkinMen1:
		*s = AddCharacterSchemaSkinMen1
	case AddCharacterSchemaSkinMen2:
		*s = AddCharacterSchemaSkinMen2
	case AddCharacterSchemaSkinMen3:
		*s = AddCharacterSchemaSkinMen3
	case AddCharacterSchemaSkinWomen1:
		*s = AddCharacterSchemaSkinWomen1
	case AddCharacterSchemaSkinWomen2:
		*s = AddCharacterSchemaSkinWomen2
	case AddCharacterSchemaSkinWomen3:
		*s = AddCharacterSchemaSkinWomen3
	default:
		*s = AddCharacterSchemaSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AddCharacterSchemaSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddCharacterSchemaSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnnouncementSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnnouncementSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfAnnouncementSchema = [2]string{
	0: "message",
	1: "created_at",
}

// Decode decodes AnnouncementSchema from json.
func (s *AnnouncementSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnnouncementSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnnouncementSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnnouncementSchema) {
					name = jsonFieldsNameOfAnnouncementSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnnouncementSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnnouncementSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("item")
		s.Item.Encode(e)
	}
	{
		e.FieldStart("bank")
		e.ArrStart()
		for _, elem := range s.Bank {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfBankItemSchema = [4]string{
	0: "cooldown",
	1: "item",
	2: "bank",
	3: "character",
}

// Decode decodes BankItemSchema from json.
func (s *BankItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "item":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Item.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item\"")
			}
		case "bank":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Bank = make([]SimpleItemSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SimpleItemSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Bank = append(s.Bank, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bank\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankItemSchema) {
					name = jsonFieldsNameOfBankItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankItemSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankItemSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("total_xp")
		e.Int(s.TotalXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("inventory_slot1")
		e.Str(s.InventorySlot1)
	}
	{
		e.FieldStart("inventory_slot1_quantity")
		e.Int(s.InventorySlot1Quantity)
	}
	{
		e.FieldStart("inventory_slot2")
		e.Str(s.InventorySlot2)
	}
	{
		e.FieldStart("inventory_slot2_quantity")
		e.Int(s.InventorySlot2Quantity)
	}
	{
		e.FieldStart("inventory_slot3")
		e.Str(s.InventorySlot3)
	}
	{
		e.FieldStart("inventory_slot3_quantity")
		e.Int(s.InventorySlot3Quantity)
	}
	{
		e.FieldStart("inventory_slot4")
		e.Str(s.InventorySlot4)
	}
	{
		e.FieldStart("inventory_slot4_quantity")
		e.Int(s.InventorySlot4Quantity)
	}
	{
		e.FieldStart("inventory_slot5")
		e.Str(s.InventorySlot5)
	}
	{
		e.FieldStart("inventory_slot5_quantity")
		e.Int(s.InventorySlot5Quantity)
	}
	{
		e.FieldStart("inventory_slot6")
		e.Str(s.InventorySlot6)
	}
	{
		e.FieldStart("inventory_slot6_quantity")
		e.Int(s.InventorySlot6Quantity)
	}
	{
		e.FieldStart("inventory_slot7")
		e.Str(s.InventorySlot7)
	}
	{
		e.FieldStart("inventory_slot7_quantity")
		e.Int(s.InventorySlot7Quantity)
	}
	{
		e.FieldStart("inventory_slot8")
		e.Str(s.InventorySlot8)
	}
	{
		e.FieldStart("inventory_slot8_quantity")
		e.Int(s.InventorySlot8Quantity)
	}
	{
		e.FieldStart("inventory_slot9")
		e.Str(s.InventorySlot9)
	}
	{
		e.FieldStart("inventory_slot9_quantity")
		e.Int(s.InventorySlot9Quantity)
	}
	{
		e.FieldStart("inventory_slot10")
		e.Str(s.InventorySlot10)
	}
	{
		e.FieldStart("inventory_slot10_quantity")
		e.Int(s.InventorySlot10Quantity)
	}
	{
		e.FieldStart("inventory_slot11")
		e.Str(s.InventorySlot11)
	}
	{
		e.FieldStart("inventory_slot11_quantity")
		e.Int(s.InventorySlot11Quantity)
	}
	{
		e.FieldStart("inventory_slot12")
		e.Str(s.InventorySlot12)
	}
	{
		e.FieldStart("inventory_slot12_quantity")
		e.Int(s.InventorySlot12Quantity)
	}
	{
		e.FieldStart("inventory_slot13")
		e.Str(s.InventorySlot13)
	}
	{
		e.FieldStart("inventory_slot13_quantity")
		e.Int(s.InventorySlot13Quantity)
	}
	{
		e.FieldStart("inventory_slot14")
		e.Str(s.InventorySlot14)
	}
	{
		e.FieldStart("inventory_slot14_quantity")
		e.Int(s.InventorySlot14Quantity)
	}
	{
		e.FieldStart("inventory_slot15")
		e.Str(s.InventorySlot15)
	}
	{
		e.FieldStart("inventory_slot15_quantity")
		e.Int(s.InventorySlot15Quantity)
	}
	{
		e.FieldStart("inventory_slot16")
		e.Str(s.InventorySlot16)
	}
	{
		e.FieldStart("inventory_slot16_quantity")
		e.Int(s.InventorySlot16Quantity)
	}
	{
		e.FieldStart("inventory_slot17")
		e.Str(s.InventorySlot17)
	}
	{
		e.FieldStart("inventory_slot17_quantity")
		e.Int(s.InventorySlot17Quantity)
	}
	{
		e.FieldStart("inventory_slot18")
		e.Str(s.InventorySlot18)
	}
	{
		e.FieldStart("inventory_slot18_quantity")
		e.Int(s.InventorySlot18Quantity)
	}
	{
		e.FieldStart("inventory_slot19")
		e.Str(s.InventorySlot19)
	}
	{
		e.FieldStart("inventory_slot19_quantity")
		e.Int(s.InventorySlot19Quantity)
	}
	{
		e.FieldStart("inventory_slot20")
		e.Str(s.InventorySlot20)
	}
	{
		e.FieldStart("inventory_slot20_quantity")
		e.Int(s.InventorySlot20Quantity)
	}
}

var jsonFieldsNameOfBankItemSchemaCharacter = [111]string{
	0:   "name",
	1:   "skin",
	2:   "level",
	3:   "xp",
	4:   "max_xp",
	5:   "total_xp",
	6:   "gold",
	7:   "speed",
	8:   "mining_level",
	9:   "mining_xp",
	10:  "mining_max_xp",
	11:  "woodcutting_level",
	12:  "woodcutting_xp",
	13:  "woodcutting_max_xp",
	14:  "fishing_level",
	15:  "fishing_xp",
	16:  "fishing_max_xp",
	17:  "weaponcrafting_level",
	18:  "weaponcrafting_xp",
	19:  "weaponcrafting_max_xp",
	20:  "gearcrafting_level",
	21:  "gearcrafting_xp",
	22:  "gearcrafting_max_xp",
	23:  "jewelrycrafting_level",
	24:  "jewelrycrafting_xp",
	25:  "jewelrycrafting_max_xp",
	26:  "cooking_level",
	27:  "cooking_xp",
	28:  "cooking_max_xp",
	29:  "hp",
	30:  "haste",
	31:  "critical_strike",
	32:  "stamina",
	33:  "attack_fire",
	34:  "attack_earth",
	35:  "attack_water",
	36:  "attack_air",
	37:  "dmg_fire",
	38:  "dmg_earth",
	39:  "dmg_water",
	40:  "dmg_air",
	41:  "res_fire",
	42:  "res_earth",
	43:  "res_water",
	44:  "res_air",
	45:  "x",
	46:  "y",
	47:  "cooldown",
	48:  "cooldown_expiration",
	49:  "weapon_slot",
	50:  "shield_slot",
	51:  "helmet_slot",
	52:  "body_armor_slot",
	53:  "leg_armor_slot",
	54:  "boots_slot",
	55:  "ring1_slot",
	56:  "ring2_slot",
	57:  "amulet_slot",
	58:  "artifact1_slot",
	59:  "artifact2_slot",
	60:  "artifact3_slot",
	61:  "consumable1_slot",
	62:  "consumable1_slot_quantity",
	63:  "consumable2_slot",
	64:  "consumable2_slot_quantity",
	65:  "task",
	66:  "task_type",
	67:  "task_progress",
	68:  "task_total",
	69:  "inventory_max_items",
	70:  "inventory",
	71:  "inventory_slot1",
	72:  "inventory_slot1_quantity",
	73:  "inventory_slot2",
	74:  "inventory_slot2_quantity",
	75:  "inventory_slot3",
	76:  "inventory_slot3_quantity",
	77:  "inventory_slot4",
	78:  "inventory_slot4_quantity",
	79:  "inventory_slot5",
	80:  "inventory_slot5_quantity",
	81:  "inventory_slot6",
	82:  "inventory_slot6_quantity",
	83:  "inventory_slot7",
	84:  "inventory_slot7_quantity",
	85:  "inventory_slot8",
	86:  "inventory_slot8_quantity",
	87:  "inventory_slot9",
	88:  "inventory_slot9_quantity",
	89:  "inventory_slot10",
	90:  "inventory_slot10_quantity",
	91:  "inventory_slot11",
	92:  "inventory_slot11_quantity",
	93:  "inventory_slot12",
	94:  "inventory_slot12_quantity",
	95:  "inventory_slot13",
	96:  "inventory_slot13_quantity",
	97:  "inventory_slot14",
	98:  "inventory_slot14_quantity",
	99:  "inventory_slot15",
	100: "inventory_slot15_quantity",
	101: "inventory_slot16",
	102: "inventory_slot16_quantity",
	103: "inventory_slot17",
	104: "inventory_slot17_quantity",
	105: "inventory_slot18",
	106: "inventory_slot18_quantity",
	107: "inventory_slot19",
	108: "inventory_slot19_quantity",
	109: "inventory_slot20",
	110: "inventory_slot20_quantity",
}

// Decode decodes BankItemSchemaCharacter from json.
func (s *BankItemSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemSchemaCharacter to nil")
	}
	var requiredBitSet [14]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "total_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.TotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		case "inventory_slot1":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot1 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1\"")
			}
		case "inventory_slot1_quantity":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot1Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1_quantity\"")
			}
		case "inventory_slot2":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot2 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2\"")
			}
		case "inventory_slot2_quantity":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot2Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2_quantity\"")
			}
		case "inventory_slot3":
			requiredBitSet[9] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot3 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3\"")
			}
		case "inventory_slot3_quantity":
			requiredBitSet[9] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot3Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3_quantity\"")
			}
		case "inventory_slot4":
			requiredBitSet[9] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot4 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4\"")
			}
		case "inventory_slot4_quantity":
			requiredBitSet[9] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot4Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4_quantity\"")
			}
		case "inventory_slot5":
			requiredBitSet[9] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot5 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5\"")
			}
		case "inventory_slot5_quantity":
			requiredBitSet[10] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot5Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5_quantity\"")
			}
		case "inventory_slot6":
			requiredBitSet[10] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot6 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6\"")
			}
		case "inventory_slot6_quantity":
			requiredBitSet[10] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot6Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6_quantity\"")
			}
		case "inventory_slot7":
			requiredBitSet[10] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot7 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7\"")
			}
		case "inventory_slot7_quantity":
			requiredBitSet[10] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot7Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7_quantity\"")
			}
		case "inventory_slot8":
			requiredBitSet[10] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot8 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8\"")
			}
		case "inventory_slot8_quantity":
			requiredBitSet[10] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot8Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8_quantity\"")
			}
		case "inventory_slot9":
			requiredBitSet[10] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot9 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9\"")
			}
		case "inventory_slot9_quantity":
			requiredBitSet[11] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot9Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9_quantity\"")
			}
		case "inventory_slot10":
			requiredBitSet[11] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot10 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10\"")
			}
		case "inventory_slot10_quantity":
			requiredBitSet[11] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot10Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10_quantity\"")
			}
		case "inventory_slot11":
			requiredBitSet[11] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot11 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11\"")
			}
		case "inventory_slot11_quantity":
			requiredBitSet[11] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot11Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11_quantity\"")
			}
		case "inventory_slot12":
			requiredBitSet[11] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot12 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12\"")
			}
		case "inventory_slot12_quantity":
			requiredBitSet[11] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot12Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12_quantity\"")
			}
		case "inventory_slot13":
			requiredBitSet[11] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot13 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13\"")
			}
		case "inventory_slot13_quantity":
			requiredBitSet[12] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot13Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13_quantity\"")
			}
		case "inventory_slot14":
			requiredBitSet[12] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot14 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14\"")
			}
		case "inventory_slot14_quantity":
			requiredBitSet[12] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot14Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14_quantity\"")
			}
		case "inventory_slot15":
			requiredBitSet[12] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot15 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15\"")
			}
		case "inventory_slot15_quantity":
			requiredBitSet[12] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot15Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15_quantity\"")
			}
		case "inventory_slot16":
			requiredBitSet[12] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot16 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16\"")
			}
		case "inventory_slot16_quantity":
			requiredBitSet[12] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot16Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16_quantity\"")
			}
		case "inventory_slot17":
			requiredBitSet[12] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot17 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17\"")
			}
		case "inventory_slot17_quantity":
			requiredBitSet[13] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot17Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17_quantity\"")
			}
		case "inventory_slot18":
			requiredBitSet[13] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot18 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18\"")
			}
		case "inventory_slot18_quantity":
			requiredBitSet[13] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot18Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18_quantity\"")
			}
		case "inventory_slot19":
			requiredBitSet[13] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot19 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19\"")
			}
		case "inventory_slot19_quantity":
			requiredBitSet[13] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot19Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19_quantity\"")
			}
		case "inventory_slot20":
			requiredBitSet[13] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot20 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20\"")
			}
		case "inventory_slot20_quantity":
			requiredBitSet[13] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot20Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20_quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankItemSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [14]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b10111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankItemSchemaCharacter) {
					name = jsonFieldsNameOfBankItemSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankItemSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankItemSchemaCharacterCooldownExpiration as json.
func (s BankItemSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	switch s.Type {
	case DateTimeBankItemSchemaCharacterCooldownExpiration:
		json.EncodeDateTime(e, s.DateTime)
	case NullBankItemSchemaCharacterCooldownExpiration:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes BankItemSchemaCharacterCooldownExpiration from json.
func (s *BankItemSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemSchemaCharacterCooldownExpiration to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullBankItemSchemaCharacterCooldownExpiration
	case jx.String:
		v, err := json.DecodeDateTime(d)
		s.DateTime = v
		if err != nil {
			return err
		}
		s.Type = DateTimeBankItemSchemaCharacterCooldownExpiration
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BankItemSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankItemSchemaCharacterSkin as json.
func (s BankItemSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BankItemSchemaCharacterSkin from json.
func (s *BankItemSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BankItemSchemaCharacterSkin(v) {
	case BankItemSchemaCharacterSkinMen1:
		*s = BankItemSchemaCharacterSkinMen1
	case BankItemSchemaCharacterSkinMen2:
		*s = BankItemSchemaCharacterSkinMen2
	case BankItemSchemaCharacterSkinMen3:
		*s = BankItemSchemaCharacterSkinMen3
	case BankItemSchemaCharacterSkinWomen1:
		*s = BankItemSchemaCharacterSkinWomen1
	case BankItemSchemaCharacterSkinWomen2:
		*s = BankItemSchemaCharacterSkinWomen2
	case BankItemSchemaCharacterSkinWomen3:
		*s = BankItemSchemaCharacterSkinWomen3
	default:
		*s = BankItemSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BankItemSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankItemSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankItemSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfBankItemSchemaCooldown = [4]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "expiration",
	3: "reason",
}

// Decode decodes BankItemSchemaCooldown from json.
func (s *BankItemSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankItemSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankItemSchemaCooldown) {
					name = jsonFieldsNameOfBankItemSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankItemSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankItemSchemaCooldownReason as json.
func (s BankItemSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BankItemSchemaCooldownReason from json.
func (s *BankItemSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BankItemSchemaCooldownReason(v) {
	case BankItemSchemaCooldownReasonMovement:
		*s = BankItemSchemaCooldownReasonMovement
	case BankItemSchemaCooldownReasonFight:
		*s = BankItemSchemaCooldownReasonFight
	case BankItemSchemaCooldownReasonCrafting:
		*s = BankItemSchemaCooldownReasonCrafting
	case BankItemSchemaCooldownReasonGathering:
		*s = BankItemSchemaCooldownReasonGathering
	case BankItemSchemaCooldownReasonBuyGe:
		*s = BankItemSchemaCooldownReasonBuyGe
	case BankItemSchemaCooldownReasonSellGe:
		*s = BankItemSchemaCooldownReasonSellGe
	case BankItemSchemaCooldownReasonDeleteItem:
		*s = BankItemSchemaCooldownReasonDeleteItem
	case BankItemSchemaCooldownReasonDepositBank:
		*s = BankItemSchemaCooldownReasonDepositBank
	case BankItemSchemaCooldownReasonWithdrawBank:
		*s = BankItemSchemaCooldownReasonWithdrawBank
	case BankItemSchemaCooldownReasonEquip:
		*s = BankItemSchemaCooldownReasonEquip
	case BankItemSchemaCooldownReasonUnequip:
		*s = BankItemSchemaCooldownReasonUnequip
	case BankItemSchemaCooldownReasonTask:
		*s = BankItemSchemaCooldownReasonTask
	case BankItemSchemaCooldownReasonRecycling:
		*s = BankItemSchemaCooldownReasonRecycling
	default:
		*s = BankItemSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BankItemSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankItemSchemaItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankItemSchemaItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("subtype")
		e.Str(s.Subtype)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Effects != nil {
			e.FieldStart("effects")
			e.ArrStart()
			for _, elem := range s.Effects {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Craft.Set {
			e.FieldStart("craft")
			s.Craft.Encode(e)
		}
	}
}

var jsonFieldsNameOfBankItemSchemaItem = [8]string{
	0: "name",
	1: "code",
	2: "level",
	3: "type",
	4: "subtype",
	5: "description",
	6: "effects",
	7: "craft",
}

// Decode decodes BankItemSchemaItem from json.
func (s *BankItemSchemaItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemSchemaItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "subtype":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Subtype = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subtype\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "effects":
			if err := func() error {
				s.Effects = make([]ItemEffectSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ItemEffectSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Effects = append(s.Effects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effects\"")
			}
		case "craft":
			if err := func() error {
				s.Craft.Reset()
				if err := s.Craft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"craft\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankItemSchemaItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankItemSchemaItem) {
					name = jsonFieldsNameOfBankItemSchemaItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankItemSchemaItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemSchemaItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankItemSchemaItemCraft as json.
func (s BankItemSchemaItemCraft) Encode(e *jx.Encoder) {
	switch s.Type {
	case CraftSchemaBankItemSchemaItemCraft:
		s.CraftSchema.Encode(e)
	case NullBankItemSchemaItemCraft:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes BankItemSchemaItemCraft from json.
func (s *BankItemSchemaItemCraft) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemSchemaItemCraft to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullBankItemSchemaItemCraft
	case jx.Object:
		if err := s.CraftSchema.Decode(d); err != nil {
			return err
		}
		s.Type = CraftSchemaBankItemSchemaItemCraft
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BankItemSchemaItemCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemSchemaItemCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChangePassword) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChangePassword) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
}

var jsonFieldsNameOfChangePassword = [1]string{
	0: "password",
}

// Decode decodes ChangePassword from json.
func (s *ChangePassword) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChangePassword to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "password":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChangePassword")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChangePassword) {
					name = jsonFieldsNameOfChangePassword[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChangePassword) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChangePassword) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterFightDataSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterFightDataSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("fight")
		s.Fight.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfCharacterFightDataSchema = [3]string{
	0: "cooldown",
	1: "fight",
	2: "character",
}

// Decode decodes CharacterFightDataSchema from json.
func (s *CharacterFightDataSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "fight":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Fight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fight\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterFightDataSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterFightDataSchema) {
					name = jsonFieldsNameOfCharacterFightDataSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterFightDataSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterFightDataSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterFightDataSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("total_xp")
		e.Int(s.TotalXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("inventory_slot1")
		e.Str(s.InventorySlot1)
	}
	{
		e.FieldStart("inventory_slot1_quantity")
		e.Int(s.InventorySlot1Quantity)
	}
	{
		e.FieldStart("inventory_slot2")
		e.Str(s.InventorySlot2)
	}
	{
		e.FieldStart("inventory_slot2_quantity")
		e.Int(s.InventorySlot2Quantity)
	}
	{
		e.FieldStart("inventory_slot3")
		e.Str(s.InventorySlot3)
	}
	{
		e.FieldStart("inventory_slot3_quantity")
		e.Int(s.InventorySlot3Quantity)
	}
	{
		e.FieldStart("inventory_slot4")
		e.Str(s.InventorySlot4)
	}
	{
		e.FieldStart("inventory_slot4_quantity")
		e.Int(s.InventorySlot4Quantity)
	}
	{
		e.FieldStart("inventory_slot5")
		e.Str(s.InventorySlot5)
	}
	{
		e.FieldStart("inventory_slot5_quantity")
		e.Int(s.InventorySlot5Quantity)
	}
	{
		e.FieldStart("inventory_slot6")
		e.Str(s.InventorySlot6)
	}
	{
		e.FieldStart("inventory_slot6_quantity")
		e.Int(s.InventorySlot6Quantity)
	}
	{
		e.FieldStart("inventory_slot7")
		e.Str(s.InventorySlot7)
	}
	{
		e.FieldStart("inventory_slot7_quantity")
		e.Int(s.InventorySlot7Quantity)
	}
	{
		e.FieldStart("inventory_slot8")
		e.Str(s.InventorySlot8)
	}
	{
		e.FieldStart("inventory_slot8_quantity")
		e.Int(s.InventorySlot8Quantity)
	}
	{
		e.FieldStart("inventory_slot9")
		e.Str(s.InventorySlot9)
	}
	{
		e.FieldStart("inventory_slot9_quantity")
		e.Int(s.InventorySlot9Quantity)
	}
	{
		e.FieldStart("inventory_slot10")
		e.Str(s.InventorySlot10)
	}
	{
		e.FieldStart("inventory_slot10_quantity")
		e.Int(s.InventorySlot10Quantity)
	}
	{
		e.FieldStart("inventory_slot11")
		e.Str(s.InventorySlot11)
	}
	{
		e.FieldStart("inventory_slot11_quantity")
		e.Int(s.InventorySlot11Quantity)
	}
	{
		e.FieldStart("inventory_slot12")
		e.Str(s.InventorySlot12)
	}
	{
		e.FieldStart("inventory_slot12_quantity")
		e.Int(s.InventorySlot12Quantity)
	}
	{
		e.FieldStart("inventory_slot13")
		e.Str(s.InventorySlot13)
	}
	{
		e.FieldStart("inventory_slot13_quantity")
		e.Int(s.InventorySlot13Quantity)
	}
	{
		e.FieldStart("inventory_slot14")
		e.Str(s.InventorySlot14)
	}
	{
		e.FieldStart("inventory_slot14_quantity")
		e.Int(s.InventorySlot14Quantity)
	}
	{
		e.FieldStart("inventory_slot15")
		e.Str(s.InventorySlot15)
	}
	{
		e.FieldStart("inventory_slot15_quantity")
		e.Int(s.InventorySlot15Quantity)
	}
	{
		e.FieldStart("inventory_slot16")
		e.Str(s.InventorySlot16)
	}
	{
		e.FieldStart("inventory_slot16_quantity")
		e.Int(s.InventorySlot16Quantity)
	}
	{
		e.FieldStart("inventory_slot17")
		e.Str(s.InventorySlot17)
	}
	{
		e.FieldStart("inventory_slot17_quantity")
		e.Int(s.InventorySlot17Quantity)
	}
	{
		e.FieldStart("inventory_slot18")
		e.Str(s.InventorySlot18)
	}
	{
		e.FieldStart("inventory_slot18_quantity")
		e.Int(s.InventorySlot18Quantity)
	}
	{
		e.FieldStart("inventory_slot19")
		e.Str(s.InventorySlot19)
	}
	{
		e.FieldStart("inventory_slot19_quantity")
		e.Int(s.InventorySlot19Quantity)
	}
	{
		e.FieldStart("inventory_slot20")
		e.Str(s.InventorySlot20)
	}
	{
		e.FieldStart("inventory_slot20_quantity")
		e.Int(s.InventorySlot20Quantity)
	}
}

var jsonFieldsNameOfCharacterFightDataSchemaCharacter = [111]string{
	0:   "name",
	1:   "skin",
	2:   "level",
	3:   "xp",
	4:   "max_xp",
	5:   "total_xp",
	6:   "gold",
	7:   "speed",
	8:   "mining_level",
	9:   "mining_xp",
	10:  "mining_max_xp",
	11:  "woodcutting_level",
	12:  "woodcutting_xp",
	13:  "woodcutting_max_xp",
	14:  "fishing_level",
	15:  "fishing_xp",
	16:  "fishing_max_xp",
	17:  "weaponcrafting_level",
	18:  "weaponcrafting_xp",
	19:  "weaponcrafting_max_xp",
	20:  "gearcrafting_level",
	21:  "gearcrafting_xp",
	22:  "gearcrafting_max_xp",
	23:  "jewelrycrafting_level",
	24:  "jewelrycrafting_xp",
	25:  "jewelrycrafting_max_xp",
	26:  "cooking_level",
	27:  "cooking_xp",
	28:  "cooking_max_xp",
	29:  "hp",
	30:  "haste",
	31:  "critical_strike",
	32:  "stamina",
	33:  "attack_fire",
	34:  "attack_earth",
	35:  "attack_water",
	36:  "attack_air",
	37:  "dmg_fire",
	38:  "dmg_earth",
	39:  "dmg_water",
	40:  "dmg_air",
	41:  "res_fire",
	42:  "res_earth",
	43:  "res_water",
	44:  "res_air",
	45:  "x",
	46:  "y",
	47:  "cooldown",
	48:  "cooldown_expiration",
	49:  "weapon_slot",
	50:  "shield_slot",
	51:  "helmet_slot",
	52:  "body_armor_slot",
	53:  "leg_armor_slot",
	54:  "boots_slot",
	55:  "ring1_slot",
	56:  "ring2_slot",
	57:  "amulet_slot",
	58:  "artifact1_slot",
	59:  "artifact2_slot",
	60:  "artifact3_slot",
	61:  "consumable1_slot",
	62:  "consumable1_slot_quantity",
	63:  "consumable2_slot",
	64:  "consumable2_slot_quantity",
	65:  "task",
	66:  "task_type",
	67:  "task_progress",
	68:  "task_total",
	69:  "inventory_max_items",
	70:  "inventory",
	71:  "inventory_slot1",
	72:  "inventory_slot1_quantity",
	73:  "inventory_slot2",
	74:  "inventory_slot2_quantity",
	75:  "inventory_slot3",
	76:  "inventory_slot3_quantity",
	77:  "inventory_slot4",
	78:  "inventory_slot4_quantity",
	79:  "inventory_slot5",
	80:  "inventory_slot5_quantity",
	81:  "inventory_slot6",
	82:  "inventory_slot6_quantity",
	83:  "inventory_slot7",
	84:  "inventory_slot7_quantity",
	85:  "inventory_slot8",
	86:  "inventory_slot8_quantity",
	87:  "inventory_slot9",
	88:  "inventory_slot9_quantity",
	89:  "inventory_slot10",
	90:  "inventory_slot10_quantity",
	91:  "inventory_slot11",
	92:  "inventory_slot11_quantity",
	93:  "inventory_slot12",
	94:  "inventory_slot12_quantity",
	95:  "inventory_slot13",
	96:  "inventory_slot13_quantity",
	97:  "inventory_slot14",
	98:  "inventory_slot14_quantity",
	99:  "inventory_slot15",
	100: "inventory_slot15_quantity",
	101: "inventory_slot16",
	102: "inventory_slot16_quantity",
	103: "inventory_slot17",
	104: "inventory_slot17_quantity",
	105: "inventory_slot18",
	106: "inventory_slot18_quantity",
	107: "inventory_slot19",
	108: "inventory_slot19_quantity",
	109: "inventory_slot20",
	110: "inventory_slot20_quantity",
}

// Decode decodes CharacterFightDataSchemaCharacter from json.
func (s *CharacterFightDataSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaCharacter to nil")
	}
	var requiredBitSet [14]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "total_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.TotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		case "inventory_slot1":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot1 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1\"")
			}
		case "inventory_slot1_quantity":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot1Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1_quantity\"")
			}
		case "inventory_slot2":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot2 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2\"")
			}
		case "inventory_slot2_quantity":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot2Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2_quantity\"")
			}
		case "inventory_slot3":
			requiredBitSet[9] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot3 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3\"")
			}
		case "inventory_slot3_quantity":
			requiredBitSet[9] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot3Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3_quantity\"")
			}
		case "inventory_slot4":
			requiredBitSet[9] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot4 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4\"")
			}
		case "inventory_slot4_quantity":
			requiredBitSet[9] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot4Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4_quantity\"")
			}
		case "inventory_slot5":
			requiredBitSet[9] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot5 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5\"")
			}
		case "inventory_slot5_quantity":
			requiredBitSet[10] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot5Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5_quantity\"")
			}
		case "inventory_slot6":
			requiredBitSet[10] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot6 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6\"")
			}
		case "inventory_slot6_quantity":
			requiredBitSet[10] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot6Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6_quantity\"")
			}
		case "inventory_slot7":
			requiredBitSet[10] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot7 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7\"")
			}
		case "inventory_slot7_quantity":
			requiredBitSet[10] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot7Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7_quantity\"")
			}
		case "inventory_slot8":
			requiredBitSet[10] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot8 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8\"")
			}
		case "inventory_slot8_quantity":
			requiredBitSet[10] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot8Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8_quantity\"")
			}
		case "inventory_slot9":
			requiredBitSet[10] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot9 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9\"")
			}
		case "inventory_slot9_quantity":
			requiredBitSet[11] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot9Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9_quantity\"")
			}
		case "inventory_slot10":
			requiredBitSet[11] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot10 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10\"")
			}
		case "inventory_slot10_quantity":
			requiredBitSet[11] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot10Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10_quantity\"")
			}
		case "inventory_slot11":
			requiredBitSet[11] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot11 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11\"")
			}
		case "inventory_slot11_quantity":
			requiredBitSet[11] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot11Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11_quantity\"")
			}
		case "inventory_slot12":
			requiredBitSet[11] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot12 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12\"")
			}
		case "inventory_slot12_quantity":
			requiredBitSet[11] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot12Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12_quantity\"")
			}
		case "inventory_slot13":
			requiredBitSet[11] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot13 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13\"")
			}
		case "inventory_slot13_quantity":
			requiredBitSet[12] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot13Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13_quantity\"")
			}
		case "inventory_slot14":
			requiredBitSet[12] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot14 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14\"")
			}
		case "inventory_slot14_quantity":
			requiredBitSet[12] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot14Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14_quantity\"")
			}
		case "inventory_slot15":
			requiredBitSet[12] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot15 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15\"")
			}
		case "inventory_slot15_quantity":
			requiredBitSet[12] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot15Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15_quantity\"")
			}
		case "inventory_slot16":
			requiredBitSet[12] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot16 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16\"")
			}
		case "inventory_slot16_quantity":
			requiredBitSet[12] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot16Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16_quantity\"")
			}
		case "inventory_slot17":
			requiredBitSet[12] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot17 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17\"")
			}
		case "inventory_slot17_quantity":
			requiredBitSet[13] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot17Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17_quantity\"")
			}
		case "inventory_slot18":
			requiredBitSet[13] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot18 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18\"")
			}
		case "inventory_slot18_quantity":
			requiredBitSet[13] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot18Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18_quantity\"")
			}
		case "inventory_slot19":
			requiredBitSet[13] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot19 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19\"")
			}
		case "inventory_slot19_quantity":
			requiredBitSet[13] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot19Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19_quantity\"")
			}
		case "inventory_slot20":
			requiredBitSet[13] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot20 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20\"")
			}
		case "inventory_slot20_quantity":
			requiredBitSet[13] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot20Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20_quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterFightDataSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [14]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b10111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterFightDataSchemaCharacter) {
					name = jsonFieldsNameOfCharacterFightDataSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterFightDataSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterFightDataSchemaCharacterCooldownExpiration as json.
func (s CharacterFightDataSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	switch s.Type {
	case DateTimeCharacterFightDataSchemaCharacterCooldownExpiration:
		json.EncodeDateTime(e, s.DateTime)
	case NullCharacterFightDataSchemaCharacterCooldownExpiration:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes CharacterFightDataSchemaCharacterCooldownExpiration from json.
func (s *CharacterFightDataSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaCharacterCooldownExpiration to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullCharacterFightDataSchemaCharacterCooldownExpiration
	case jx.String:
		v, err := json.DecodeDateTime(d)
		s.DateTime = v
		if err != nil {
			return err
		}
		s.Type = DateTimeCharacterFightDataSchemaCharacterCooldownExpiration
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterFightDataSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterFightDataSchemaCharacterSkin as json.
func (s CharacterFightDataSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterFightDataSchemaCharacterSkin from json.
func (s *CharacterFightDataSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterFightDataSchemaCharacterSkin(v) {
	case CharacterFightDataSchemaCharacterSkinMen1:
		*s = CharacterFightDataSchemaCharacterSkinMen1
	case CharacterFightDataSchemaCharacterSkinMen2:
		*s = CharacterFightDataSchemaCharacterSkinMen2
	case CharacterFightDataSchemaCharacterSkinMen3:
		*s = CharacterFightDataSchemaCharacterSkinMen3
	case CharacterFightDataSchemaCharacterSkinWomen1:
		*s = CharacterFightDataSchemaCharacterSkinWomen1
	case CharacterFightDataSchemaCharacterSkinWomen2:
		*s = CharacterFightDataSchemaCharacterSkinWomen2
	case CharacterFightDataSchemaCharacterSkinWomen3:
		*s = CharacterFightDataSchemaCharacterSkinWomen3
	default:
		*s = CharacterFightDataSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterFightDataSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterFightDataSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterFightDataSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfCharacterFightDataSchemaCooldown = [4]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "expiration",
	3: "reason",
}

// Decode decodes CharacterFightDataSchemaCooldown from json.
func (s *CharacterFightDataSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterFightDataSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterFightDataSchemaCooldown) {
					name = jsonFieldsNameOfCharacterFightDataSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterFightDataSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterFightDataSchemaCooldownReason as json.
func (s CharacterFightDataSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterFightDataSchemaCooldownReason from json.
func (s *CharacterFightDataSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterFightDataSchemaCooldownReason(v) {
	case CharacterFightDataSchemaCooldownReasonMovement:
		*s = CharacterFightDataSchemaCooldownReasonMovement
	case CharacterFightDataSchemaCooldownReasonFight:
		*s = CharacterFightDataSchemaCooldownReasonFight
	case CharacterFightDataSchemaCooldownReasonCrafting:
		*s = CharacterFightDataSchemaCooldownReasonCrafting
	case CharacterFightDataSchemaCooldownReasonGathering:
		*s = CharacterFightDataSchemaCooldownReasonGathering
	case CharacterFightDataSchemaCooldownReasonBuyGe:
		*s = CharacterFightDataSchemaCooldownReasonBuyGe
	case CharacterFightDataSchemaCooldownReasonSellGe:
		*s = CharacterFightDataSchemaCooldownReasonSellGe
	case CharacterFightDataSchemaCooldownReasonDeleteItem:
		*s = CharacterFightDataSchemaCooldownReasonDeleteItem
	case CharacterFightDataSchemaCooldownReasonDepositBank:
		*s = CharacterFightDataSchemaCooldownReasonDepositBank
	case CharacterFightDataSchemaCooldownReasonWithdrawBank:
		*s = CharacterFightDataSchemaCooldownReasonWithdrawBank
	case CharacterFightDataSchemaCooldownReasonEquip:
		*s = CharacterFightDataSchemaCooldownReasonEquip
	case CharacterFightDataSchemaCooldownReasonUnequip:
		*s = CharacterFightDataSchemaCooldownReasonUnequip
	case CharacterFightDataSchemaCooldownReasonTask:
		*s = CharacterFightDataSchemaCooldownReasonTask
	case CharacterFightDataSchemaCooldownReasonRecycling:
		*s = CharacterFightDataSchemaCooldownReasonRecycling
	default:
		*s = CharacterFightDataSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterFightDataSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterFightDataSchemaFight) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterFightDataSchemaFight) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("drops")
		e.ArrStart()
		for _, elem := range s.Drops {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("turns")
		e.Int(s.Turns)
	}
	{
		e.FieldStart("monster_blocked_hits")
		s.MonsterBlockedHits.Encode(e)
	}
	{
		e.FieldStart("player_blocked_hits")
		s.PlayerBlockedHits.Encode(e)
	}
	{
		e.FieldStart("logs")
		e.ArrStart()
		for _, elem := range s.Logs {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("result")
		s.Result.Encode(e)
	}
}

var jsonFieldsNameOfCharacterFightDataSchemaFight = [8]string{
	0: "xp",
	1: "gold",
	2: "drops",
	3: "turns",
	4: "monster_blocked_hits",
	5: "player_blocked_hits",
	6: "logs",
	7: "result",
}

// Decode decodes CharacterFightDataSchemaFight from json.
func (s *CharacterFightDataSchemaFight) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaFight to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "xp":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "drops":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Drops = make([]DropSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DropSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Drops = append(s.Drops, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drops\"")
			}
		case "turns":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Turns = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"turns\"")
			}
		case "monster_blocked_hits":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.MonsterBlockedHits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monster_blocked_hits\"")
			}
		case "player_blocked_hits":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.PlayerBlockedHits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_blocked_hits\"")
			}
		case "logs":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.Logs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Logs = append(s.Logs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logs\"")
			}
		case "result":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterFightDataSchemaFight")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterFightDataSchemaFight) {
					name = jsonFieldsNameOfCharacterFightDataSchemaFight[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterFightDataSchemaFight) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaFight) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterFightDataSchemaFightMonsterBlockedHits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterFightDataSchemaFightMonsterBlockedHits) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fire")
		e.Int(s.Fire)
	}
	{
		e.FieldStart("earth")
		e.Int(s.Earth)
	}
	{
		e.FieldStart("water")
		e.Int(s.Water)
	}
	{
		e.FieldStart("air")
		e.Int(s.Air)
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
}

var jsonFieldsNameOfCharacterFightDataSchemaFightMonsterBlockedHits = [5]string{
	0: "fire",
	1: "earth",
	2: "water",
	3: "air",
	4: "total",
}

// Decode decodes CharacterFightDataSchemaFightMonsterBlockedHits from json.
func (s *CharacterFightDataSchemaFightMonsterBlockedHits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaFightMonsterBlockedHits to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fire":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Fire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fire\"")
			}
		case "earth":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Earth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"earth\"")
			}
		case "water":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Water = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"water\"")
			}
		case "air":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Air = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"air\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterFightDataSchemaFightMonsterBlockedHits")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterFightDataSchemaFightMonsterBlockedHits) {
					name = jsonFieldsNameOfCharacterFightDataSchemaFightMonsterBlockedHits[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterFightDataSchemaFightMonsterBlockedHits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaFightMonsterBlockedHits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterFightDataSchemaFightPlayerBlockedHits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterFightDataSchemaFightPlayerBlockedHits) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fire")
		e.Int(s.Fire)
	}
	{
		e.FieldStart("earth")
		e.Int(s.Earth)
	}
	{
		e.FieldStart("water")
		e.Int(s.Water)
	}
	{
		e.FieldStart("air")
		e.Int(s.Air)
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
}

var jsonFieldsNameOfCharacterFightDataSchemaFightPlayerBlockedHits = [5]string{
	0: "fire",
	1: "earth",
	2: "water",
	3: "air",
	4: "total",
}

// Decode decodes CharacterFightDataSchemaFightPlayerBlockedHits from json.
func (s *CharacterFightDataSchemaFightPlayerBlockedHits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaFightPlayerBlockedHits to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fire":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Fire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fire\"")
			}
		case "earth":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Earth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"earth\"")
			}
		case "water":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Water = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"water\"")
			}
		case "air":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Air = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"air\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterFightDataSchemaFightPlayerBlockedHits")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterFightDataSchemaFightPlayerBlockedHits) {
					name = jsonFieldsNameOfCharacterFightDataSchemaFightPlayerBlockedHits[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterFightDataSchemaFightPlayerBlockedHits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaFightPlayerBlockedHits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterFightDataSchemaFightResult as json.
func (s CharacterFightDataSchemaFightResult) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterFightDataSchemaFightResult from json.
func (s *CharacterFightDataSchemaFightResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaFightResult to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterFightDataSchemaFightResult(v) {
	case CharacterFightDataSchemaFightResultWin:
		*s = CharacterFightDataSchemaFightResultWin
	case CharacterFightDataSchemaFightResultLose:
		*s = CharacterFightDataSchemaFightResultLose
	default:
		*s = CharacterFightDataSchemaFightResult(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterFightDataSchemaFightResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaFightResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterFightResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterFightResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCharacterFightResponseSchema = [1]string{
	0: "data",
}

// Decode decodes CharacterFightResponseSchema from json.
func (s *CharacterFightResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterFightResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterFightResponseSchema) {
					name = jsonFieldsNameOfCharacterFightResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterFightResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterMovementDataSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterMovementDataSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("destination")
		s.Destination.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfCharacterMovementDataSchema = [3]string{
	0: "cooldown",
	1: "destination",
	2: "character",
}

// Decode decodes CharacterMovementDataSchema from json.
func (s *CharacterMovementDataSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementDataSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "destination":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Destination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterMovementDataSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterMovementDataSchema) {
					name = jsonFieldsNameOfCharacterMovementDataSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterMovementDataSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementDataSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterMovementDataSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterMovementDataSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("total_xp")
		e.Int(s.TotalXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("inventory_slot1")
		e.Str(s.InventorySlot1)
	}
	{
		e.FieldStart("inventory_slot1_quantity")
		e.Int(s.InventorySlot1Quantity)
	}
	{
		e.FieldStart("inventory_slot2")
		e.Str(s.InventorySlot2)
	}
	{
		e.FieldStart("inventory_slot2_quantity")
		e.Int(s.InventorySlot2Quantity)
	}
	{
		e.FieldStart("inventory_slot3")
		e.Str(s.InventorySlot3)
	}
	{
		e.FieldStart("inventory_slot3_quantity")
		e.Int(s.InventorySlot3Quantity)
	}
	{
		e.FieldStart("inventory_slot4")
		e.Str(s.InventorySlot4)
	}
	{
		e.FieldStart("inventory_slot4_quantity")
		e.Int(s.InventorySlot4Quantity)
	}
	{
		e.FieldStart("inventory_slot5")
		e.Str(s.InventorySlot5)
	}
	{
		e.FieldStart("inventory_slot5_quantity")
		e.Int(s.InventorySlot5Quantity)
	}
	{
		e.FieldStart("inventory_slot6")
		e.Str(s.InventorySlot6)
	}
	{
		e.FieldStart("inventory_slot6_quantity")
		e.Int(s.InventorySlot6Quantity)
	}
	{
		e.FieldStart("inventory_slot7")
		e.Str(s.InventorySlot7)
	}
	{
		e.FieldStart("inventory_slot7_quantity")
		e.Int(s.InventorySlot7Quantity)
	}
	{
		e.FieldStart("inventory_slot8")
		e.Str(s.InventorySlot8)
	}
	{
		e.FieldStart("inventory_slot8_quantity")
		e.Int(s.InventorySlot8Quantity)
	}
	{
		e.FieldStart("inventory_slot9")
		e.Str(s.InventorySlot9)
	}
	{
		e.FieldStart("inventory_slot9_quantity")
		e.Int(s.InventorySlot9Quantity)
	}
	{
		e.FieldStart("inventory_slot10")
		e.Str(s.InventorySlot10)
	}
	{
		e.FieldStart("inventory_slot10_quantity")
		e.Int(s.InventorySlot10Quantity)
	}
	{
		e.FieldStart("inventory_slot11")
		e.Str(s.InventorySlot11)
	}
	{
		e.FieldStart("inventory_slot11_quantity")
		e.Int(s.InventorySlot11Quantity)
	}
	{
		e.FieldStart("inventory_slot12")
		e.Str(s.InventorySlot12)
	}
	{
		e.FieldStart("inventory_slot12_quantity")
		e.Int(s.InventorySlot12Quantity)
	}
	{
		e.FieldStart("inventory_slot13")
		e.Str(s.InventorySlot13)
	}
	{
		e.FieldStart("inventory_slot13_quantity")
		e.Int(s.InventorySlot13Quantity)
	}
	{
		e.FieldStart("inventory_slot14")
		e.Str(s.InventorySlot14)
	}
	{
		e.FieldStart("inventory_slot14_quantity")
		e.Int(s.InventorySlot14Quantity)
	}
	{
		e.FieldStart("inventory_slot15")
		e.Str(s.InventorySlot15)
	}
	{
		e.FieldStart("inventory_slot15_quantity")
		e.Int(s.InventorySlot15Quantity)
	}
	{
		e.FieldStart("inventory_slot16")
		e.Str(s.InventorySlot16)
	}
	{
		e.FieldStart("inventory_slot16_quantity")
		e.Int(s.InventorySlot16Quantity)
	}
	{
		e.FieldStart("inventory_slot17")
		e.Str(s.InventorySlot17)
	}
	{
		e.FieldStart("inventory_slot17_quantity")
		e.Int(s.InventorySlot17Quantity)
	}
	{
		e.FieldStart("inventory_slot18")
		e.Str(s.InventorySlot18)
	}
	{
		e.FieldStart("inventory_slot18_quantity")
		e.Int(s.InventorySlot18Quantity)
	}
	{
		e.FieldStart("inventory_slot19")
		e.Str(s.InventorySlot19)
	}
	{
		e.FieldStart("inventory_slot19_quantity")
		e.Int(s.InventorySlot19Quantity)
	}
	{
		e.FieldStart("inventory_slot20")
		e.Str(s.InventorySlot20)
	}
	{
		e.FieldStart("inventory_slot20_quantity")
		e.Int(s.InventorySlot20Quantity)
	}
}

var jsonFieldsNameOfCharacterMovementDataSchemaCharacter = [111]string{
	0:   "name",
	1:   "skin",
	2:   "level",
	3:   "xp",
	4:   "max_xp",
	5:   "total_xp",
	6:   "gold",
	7:   "speed",
	8:   "mining_level",
	9:   "mining_xp",
	10:  "mining_max_xp",
	11:  "woodcutting_level",
	12:  "woodcutting_xp",
	13:  "woodcutting_max_xp",
	14:  "fishing_level",
	15:  "fishing_xp",
	16:  "fishing_max_xp",
	17:  "weaponcrafting_level",
	18:  "weaponcrafting_xp",
	19:  "weaponcrafting_max_xp",
	20:  "gearcrafting_level",
	21:  "gearcrafting_xp",
	22:  "gearcrafting_max_xp",
	23:  "jewelrycrafting_level",
	24:  "jewelrycrafting_xp",
	25:  "jewelrycrafting_max_xp",
	26:  "cooking_level",
	27:  "cooking_xp",
	28:  "cooking_max_xp",
	29:  "hp",
	30:  "haste",
	31:  "critical_strike",
	32:  "stamina",
	33:  "attack_fire",
	34:  "attack_earth",
	35:  "attack_water",
	36:  "attack_air",
	37:  "dmg_fire",
	38:  "dmg_earth",
	39:  "dmg_water",
	40:  "dmg_air",
	41:  "res_fire",
	42:  "res_earth",
	43:  "res_water",
	44:  "res_air",
	45:  "x",
	46:  "y",
	47:  "cooldown",
	48:  "cooldown_expiration",
	49:  "weapon_slot",
	50:  "shield_slot",
	51:  "helmet_slot",
	52:  "body_armor_slot",
	53:  "leg_armor_slot",
	54:  "boots_slot",
	55:  "ring1_slot",
	56:  "ring2_slot",
	57:  "amulet_slot",
	58:  "artifact1_slot",
	59:  "artifact2_slot",
	60:  "artifact3_slot",
	61:  "consumable1_slot",
	62:  "consumable1_slot_quantity",
	63:  "consumable2_slot",
	64:  "consumable2_slot_quantity",
	65:  "task",
	66:  "task_type",
	67:  "task_progress",
	68:  "task_total",
	69:  "inventory_max_items",
	70:  "inventory",
	71:  "inventory_slot1",
	72:  "inventory_slot1_quantity",
	73:  "inventory_slot2",
	74:  "inventory_slot2_quantity",
	75:  "inventory_slot3",
	76:  "inventory_slot3_quantity",
	77:  "inventory_slot4",
	78:  "inventory_slot4_quantity",
	79:  "inventory_slot5",
	80:  "inventory_slot5_quantity",
	81:  "inventory_slot6",
	82:  "inventory_slot6_quantity",
	83:  "inventory_slot7",
	84:  "inventory_slot7_quantity",
	85:  "inventory_slot8",
	86:  "inventory_slot8_quantity",
	87:  "inventory_slot9",
	88:  "inventory_slot9_quantity",
	89:  "inventory_slot10",
	90:  "inventory_slot10_quantity",
	91:  "inventory_slot11",
	92:  "inventory_slot11_quantity",
	93:  "inventory_slot12",
	94:  "inventory_slot12_quantity",
	95:  "inventory_slot13",
	96:  "inventory_slot13_quantity",
	97:  "inventory_slot14",
	98:  "inventory_slot14_quantity",
	99:  "inventory_slot15",
	100: "inventory_slot15_quantity",
	101: "inventory_slot16",
	102: "inventory_slot16_quantity",
	103: "inventory_slot17",
	104: "inventory_slot17_quantity",
	105: "inventory_slot18",
	106: "inventory_slot18_quantity",
	107: "inventory_slot19",
	108: "inventory_slot19_quantity",
	109: "inventory_slot20",
	110: "inventory_slot20_quantity",
}

// Decode decodes CharacterMovementDataSchemaCharacter from json.
func (s *CharacterMovementDataSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementDataSchemaCharacter to nil")
	}
	var requiredBitSet [14]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "total_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.TotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		case "inventory_slot1":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot1 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1\"")
			}
		case "inventory_slot1_quantity":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot1Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1_quantity\"")
			}
		case "inventory_slot2":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot2 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2\"")
			}
		case "inventory_slot2_quantity":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot2Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2_quantity\"")
			}
		case "inventory_slot3":
			requiredBitSet[9] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot3 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3\"")
			}
		case "inventory_slot3_quantity":
			requiredBitSet[9] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot3Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3_quantity\"")
			}
		case "inventory_slot4":
			requiredBitSet[9] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot4 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4\"")
			}
		case "inventory_slot4_quantity":
			requiredBitSet[9] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot4Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4_quantity\"")
			}
		case "inventory_slot5":
			requiredBitSet[9] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot5 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5\"")
			}
		case "inventory_slot5_quantity":
			requiredBitSet[10] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot5Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5_quantity\"")
			}
		case "inventory_slot6":
			requiredBitSet[10] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot6 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6\"")
			}
		case "inventory_slot6_quantity":
			requiredBitSet[10] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot6Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6_quantity\"")
			}
		case "inventory_slot7":
			requiredBitSet[10] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot7 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7\"")
			}
		case "inventory_slot7_quantity":
			requiredBitSet[10] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot7Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7_quantity\"")
			}
		case "inventory_slot8":
			requiredBitSet[10] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot8 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8\"")
			}
		case "inventory_slot8_quantity":
			requiredBitSet[10] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot8Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8_quantity\"")
			}
		case "inventory_slot9":
			requiredBitSet[10] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot9 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9\"")
			}
		case "inventory_slot9_quantity":
			requiredBitSet[11] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot9Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9_quantity\"")
			}
		case "inventory_slot10":
			requiredBitSet[11] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot10 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10\"")
			}
		case "inventory_slot10_quantity":
			requiredBitSet[11] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot10Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10_quantity\"")
			}
		case "inventory_slot11":
			requiredBitSet[11] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot11 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11\"")
			}
		case "inventory_slot11_quantity":
			requiredBitSet[11] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot11Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11_quantity\"")
			}
		case "inventory_slot12":
			requiredBitSet[11] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot12 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12\"")
			}
		case "inventory_slot12_quantity":
			requiredBitSet[11] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot12Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12_quantity\"")
			}
		case "inventory_slot13":
			requiredBitSet[11] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot13 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13\"")
			}
		case "inventory_slot13_quantity":
			requiredBitSet[12] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot13Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13_quantity\"")
			}
		case "inventory_slot14":
			requiredBitSet[12] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot14 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14\"")
			}
		case "inventory_slot14_quantity":
			requiredBitSet[12] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot14Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14_quantity\"")
			}
		case "inventory_slot15":
			requiredBitSet[12] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot15 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15\"")
			}
		case "inventory_slot15_quantity":
			requiredBitSet[12] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot15Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15_quantity\"")
			}
		case "inventory_slot16":
			requiredBitSet[12] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot16 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16\"")
			}
		case "inventory_slot16_quantity":
			requiredBitSet[12] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot16Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16_quantity\"")
			}
		case "inventory_slot17":
			requiredBitSet[12] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot17 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17\"")
			}
		case "inventory_slot17_quantity":
			requiredBitSet[13] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot17Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17_quantity\"")
			}
		case "inventory_slot18":
			requiredBitSet[13] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot18 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18\"")
			}
		case "inventory_slot18_quantity":
			requiredBitSet[13] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot18Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18_quantity\"")
			}
		case "inventory_slot19":
			requiredBitSet[13] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot19 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19\"")
			}
		case "inventory_slot19_quantity":
			requiredBitSet[13] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot19Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19_quantity\"")
			}
		case "inventory_slot20":
			requiredBitSet[13] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot20 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20\"")
			}
		case "inventory_slot20_quantity":
			requiredBitSet[13] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot20Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20_quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterMovementDataSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [14]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b10111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterMovementDataSchemaCharacter) {
					name = jsonFieldsNameOfCharacterMovementDataSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterMovementDataSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementDataSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterMovementDataSchemaCharacterCooldownExpiration as json.
func (s CharacterMovementDataSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	switch s.Type {
	case DateTimeCharacterMovementDataSchemaCharacterCooldownExpiration:
		json.EncodeDateTime(e, s.DateTime)
	case NullCharacterMovementDataSchemaCharacterCooldownExpiration:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes CharacterMovementDataSchemaCharacterCooldownExpiration from json.
func (s *CharacterMovementDataSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementDataSchemaCharacterCooldownExpiration to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullCharacterMovementDataSchemaCharacterCooldownExpiration
	case jx.String:
		v, err := json.DecodeDateTime(d)
		s.DateTime = v
		if err != nil {
			return err
		}
		s.Type = DateTimeCharacterMovementDataSchemaCharacterCooldownExpiration
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterMovementDataSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementDataSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterMovementDataSchemaCharacterSkin as json.
func (s CharacterMovementDataSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterMovementDataSchemaCharacterSkin from json.
func (s *CharacterMovementDataSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementDataSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterMovementDataSchemaCharacterSkin(v) {
	case CharacterMovementDataSchemaCharacterSkinMen1:
		*s = CharacterMovementDataSchemaCharacterSkinMen1
	case CharacterMovementDataSchemaCharacterSkinMen2:
		*s = CharacterMovementDataSchemaCharacterSkinMen2
	case CharacterMovementDataSchemaCharacterSkinMen3:
		*s = CharacterMovementDataSchemaCharacterSkinMen3
	case CharacterMovementDataSchemaCharacterSkinWomen1:
		*s = CharacterMovementDataSchemaCharacterSkinWomen1
	case CharacterMovementDataSchemaCharacterSkinWomen2:
		*s = CharacterMovementDataSchemaCharacterSkinWomen2
	case CharacterMovementDataSchemaCharacterSkinWomen3:
		*s = CharacterMovementDataSchemaCharacterSkinWomen3
	default:
		*s = CharacterMovementDataSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterMovementDataSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementDataSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterMovementDataSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterMovementDataSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfCharacterMovementDataSchemaCooldown = [4]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "expiration",
	3: "reason",
}

// Decode decodes CharacterMovementDataSchemaCooldown from json.
func (s *CharacterMovementDataSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementDataSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterMovementDataSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterMovementDataSchemaCooldown) {
					name = jsonFieldsNameOfCharacterMovementDataSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterMovementDataSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementDataSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterMovementDataSchemaCooldownReason as json.
func (s CharacterMovementDataSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterMovementDataSchemaCooldownReason from json.
func (s *CharacterMovementDataSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementDataSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterMovementDataSchemaCooldownReason(v) {
	case CharacterMovementDataSchemaCooldownReasonMovement:
		*s = CharacterMovementDataSchemaCooldownReasonMovement
	case CharacterMovementDataSchemaCooldownReasonFight:
		*s = CharacterMovementDataSchemaCooldownReasonFight
	case CharacterMovementDataSchemaCooldownReasonCrafting:
		*s = CharacterMovementDataSchemaCooldownReasonCrafting
	case CharacterMovementDataSchemaCooldownReasonGathering:
		*s = CharacterMovementDataSchemaCooldownReasonGathering
	case CharacterMovementDataSchemaCooldownReasonBuyGe:
		*s = CharacterMovementDataSchemaCooldownReasonBuyGe
	case CharacterMovementDataSchemaCooldownReasonSellGe:
		*s = CharacterMovementDataSchemaCooldownReasonSellGe
	case CharacterMovementDataSchemaCooldownReasonDeleteItem:
		*s = CharacterMovementDataSchemaCooldownReasonDeleteItem
	case CharacterMovementDataSchemaCooldownReasonDepositBank:
		*s = CharacterMovementDataSchemaCooldownReasonDepositBank
	case CharacterMovementDataSchemaCooldownReasonWithdrawBank:
		*s = CharacterMovementDataSchemaCooldownReasonWithdrawBank
	case CharacterMovementDataSchemaCooldownReasonEquip:
		*s = CharacterMovementDataSchemaCooldownReasonEquip
	case CharacterMovementDataSchemaCooldownReasonUnequip:
		*s = CharacterMovementDataSchemaCooldownReasonUnequip
	case CharacterMovementDataSchemaCooldownReasonTask:
		*s = CharacterMovementDataSchemaCooldownReasonTask
	case CharacterMovementDataSchemaCooldownReasonRecycling:
		*s = CharacterMovementDataSchemaCooldownReasonRecycling
	default:
		*s = CharacterMovementDataSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterMovementDataSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementDataSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterMovementDataSchemaDestination) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterMovementDataSchemaDestination) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		if len(s.Content) != 0 {
			e.FieldStart("content")
			e.Raw(s.Content)
		}
	}
}

var jsonFieldsNameOfCharacterMovementDataSchemaDestination = [4]string{
	0: "name",
	1: "x",
	2: "y",
	3: "content",
}

// Decode decodes CharacterMovementDataSchemaDestination from json.
func (s *CharacterMovementDataSchemaDestination) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementDataSchemaDestination to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "x":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Content = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterMovementDataSchemaDestination")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterMovementDataSchemaDestination) {
					name = jsonFieldsNameOfCharacterMovementDataSchemaDestination[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterMovementDataSchemaDestination) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementDataSchemaDestination) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterMovementResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterMovementResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCharacterMovementResponseSchema = [1]string{
	0: "data",
}

// Decode decodes CharacterMovementResponseSchema from json.
func (s *CharacterMovementResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterMovementResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterMovementResponseSchema) {
					name = jsonFieldsNameOfCharacterMovementResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterMovementResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCharacterResponseSchema = [1]string{
	0: "data",
}

// Decode decodes CharacterResponseSchema from json.
func (s *CharacterResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterResponseSchema) {
					name = jsonFieldsNameOfCharacterResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("total_xp")
		e.Int(s.TotalXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("inventory_slot1")
		e.Str(s.InventorySlot1)
	}
	{
		e.FieldStart("inventory_slot1_quantity")
		e.Int(s.InventorySlot1Quantity)
	}
	{
		e.FieldStart("inventory_slot2")
		e.Str(s.InventorySlot2)
	}
	{
		e.FieldStart("inventory_slot2_quantity")
		e.Int(s.InventorySlot2Quantity)
	}
	{
		e.FieldStart("inventory_slot3")
		e.Str(s.InventorySlot3)
	}
	{
		e.FieldStart("inventory_slot3_quantity")
		e.Int(s.InventorySlot3Quantity)
	}
	{
		e.FieldStart("inventory_slot4")
		e.Str(s.InventorySlot4)
	}
	{
		e.FieldStart("inventory_slot4_quantity")
		e.Int(s.InventorySlot4Quantity)
	}
	{
		e.FieldStart("inventory_slot5")
		e.Str(s.InventorySlot5)
	}
	{
		e.FieldStart("inventory_slot5_quantity")
		e.Int(s.InventorySlot5Quantity)
	}
	{
		e.FieldStart("inventory_slot6")
		e.Str(s.InventorySlot6)
	}
	{
		e.FieldStart("inventory_slot6_quantity")
		e.Int(s.InventorySlot6Quantity)
	}
	{
		e.FieldStart("inventory_slot7")
		e.Str(s.InventorySlot7)
	}
	{
		e.FieldStart("inventory_slot7_quantity")
		e.Int(s.InventorySlot7Quantity)
	}
	{
		e.FieldStart("inventory_slot8")
		e.Str(s.InventorySlot8)
	}
	{
		e.FieldStart("inventory_slot8_quantity")
		e.Int(s.InventorySlot8Quantity)
	}
	{
		e.FieldStart("inventory_slot9")
		e.Str(s.InventorySlot9)
	}
	{
		e.FieldStart("inventory_slot9_quantity")
		e.Int(s.InventorySlot9Quantity)
	}
	{
		e.FieldStart("inventory_slot10")
		e.Str(s.InventorySlot10)
	}
	{
		e.FieldStart("inventory_slot10_quantity")
		e.Int(s.InventorySlot10Quantity)
	}
	{
		e.FieldStart("inventory_slot11")
		e.Str(s.InventorySlot11)
	}
	{
		e.FieldStart("inventory_slot11_quantity")
		e.Int(s.InventorySlot11Quantity)
	}
	{
		e.FieldStart("inventory_slot12")
		e.Str(s.InventorySlot12)
	}
	{
		e.FieldStart("inventory_slot12_quantity")
		e.Int(s.InventorySlot12Quantity)
	}
	{
		e.FieldStart("inventory_slot13")
		e.Str(s.InventorySlot13)
	}
	{
		e.FieldStart("inventory_slot13_quantity")
		e.Int(s.InventorySlot13Quantity)
	}
	{
		e.FieldStart("inventory_slot14")
		e.Str(s.InventorySlot14)
	}
	{
		e.FieldStart("inventory_slot14_quantity")
		e.Int(s.InventorySlot14Quantity)
	}
	{
		e.FieldStart("inventory_slot15")
		e.Str(s.InventorySlot15)
	}
	{
		e.FieldStart("inventory_slot15_quantity")
		e.Int(s.InventorySlot15Quantity)
	}
	{
		e.FieldStart("inventory_slot16")
		e.Str(s.InventorySlot16)
	}
	{
		e.FieldStart("inventory_slot16_quantity")
		e.Int(s.InventorySlot16Quantity)
	}
	{
		e.FieldStart("inventory_slot17")
		e.Str(s.InventorySlot17)
	}
	{
		e.FieldStart("inventory_slot17_quantity")
		e.Int(s.InventorySlot17Quantity)
	}
	{
		e.FieldStart("inventory_slot18")
		e.Str(s.InventorySlot18)
	}
	{
		e.FieldStart("inventory_slot18_quantity")
		e.Int(s.InventorySlot18Quantity)
	}
	{
		e.FieldStart("inventory_slot19")
		e.Str(s.InventorySlot19)
	}
	{
		e.FieldStart("inventory_slot19_quantity")
		e.Int(s.InventorySlot19Quantity)
	}
	{
		e.FieldStart("inventory_slot20")
		e.Str(s.InventorySlot20)
	}
	{
		e.FieldStart("inventory_slot20_quantity")
		e.Int(s.InventorySlot20Quantity)
	}
}

var jsonFieldsNameOfCharacterSchema = [111]string{
	0:   "name",
	1:   "skin",
	2:   "level",
	3:   "xp",
	4:   "max_xp",
	5:   "total_xp",
	6:   "gold",
	7:   "speed",
	8:   "mining_level",
	9:   "mining_xp",
	10:  "mining_max_xp",
	11:  "woodcutting_level",
	12:  "woodcutting_xp",
	13:  "woodcutting_max_xp",
	14:  "fishing_level",
	15:  "fishing_xp",
	16:  "fishing_max_xp",
	17:  "weaponcrafting_level",
	18:  "weaponcrafting_xp",
	19:  "weaponcrafting_max_xp",
	20:  "gearcrafting_level",
	21:  "gearcrafting_xp",
	22:  "gearcrafting_max_xp",
	23:  "jewelrycrafting_level",
	24:  "jewelrycrafting_xp",
	25:  "jewelrycrafting_max_xp",
	26:  "cooking_level",
	27:  "cooking_xp",
	28:  "cooking_max_xp",
	29:  "hp",
	30:  "haste",
	31:  "critical_strike",
	32:  "stamina",
	33:  "attack_fire",
	34:  "attack_earth",
	35:  "attack_water",
	36:  "attack_air",
	37:  "dmg_fire",
	38:  "dmg_earth",
	39:  "dmg_water",
	40:  "dmg_air",
	41:  "res_fire",
	42:  "res_earth",
	43:  "res_water",
	44:  "res_air",
	45:  "x",
	46:  "y",
	47:  "cooldown",
	48:  "cooldown_expiration",
	49:  "weapon_slot",
	50:  "shield_slot",
	51:  "helmet_slot",
	52:  "body_armor_slot",
	53:  "leg_armor_slot",
	54:  "boots_slot",
	55:  "ring1_slot",
	56:  "ring2_slot",
	57:  "amulet_slot",
	58:  "artifact1_slot",
	59:  "artifact2_slot",
	60:  "artifact3_slot",
	61:  "consumable1_slot",
	62:  "consumable1_slot_quantity",
	63:  "consumable2_slot",
	64:  "consumable2_slot_quantity",
	65:  "task",
	66:  "task_type",
	67:  "task_progress",
	68:  "task_total",
	69:  "inventory_max_items",
	70:  "inventory",
	71:  "inventory_slot1",
	72:  "inventory_slot1_quantity",
	73:  "inventory_slot2",
	74:  "inventory_slot2_quantity",
	75:  "inventory_slot3",
	76:  "inventory_slot3_quantity",
	77:  "inventory_slot4",
	78:  "inventory_slot4_quantity",
	79:  "inventory_slot5",
	80:  "inventory_slot5_quantity",
	81:  "inventory_slot6",
	82:  "inventory_slot6_quantity",
	83:  "inventory_slot7",
	84:  "inventory_slot7_quantity",
	85:  "inventory_slot8",
	86:  "inventory_slot8_quantity",
	87:  "inventory_slot9",
	88:  "inventory_slot9_quantity",
	89:  "inventory_slot10",
	90:  "inventory_slot10_quantity",
	91:  "inventory_slot11",
	92:  "inventory_slot11_quantity",
	93:  "inventory_slot12",
	94:  "inventory_slot12_quantity",
	95:  "inventory_slot13",
	96:  "inventory_slot13_quantity",
	97:  "inventory_slot14",
	98:  "inventory_slot14_quantity",
	99:  "inventory_slot15",
	100: "inventory_slot15_quantity",
	101: "inventory_slot16",
	102: "inventory_slot16_quantity",
	103: "inventory_slot17",
	104: "inventory_slot17_quantity",
	105: "inventory_slot18",
	106: "inventory_slot18_quantity",
	107: "inventory_slot19",
	108: "inventory_slot19_quantity",
	109: "inventory_slot20",
	110: "inventory_slot20_quantity",
}

// Decode decodes CharacterSchema from json.
func (s *CharacterSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterSchema to nil")
	}
	var requiredBitSet [14]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "total_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.TotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		case "inventory_slot1":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot1 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1\"")
			}
		case "inventory_slot1_quantity":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot1Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1_quantity\"")
			}
		case "inventory_slot2":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot2 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2\"")
			}
		case "inventory_slot2_quantity":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot2Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2_quantity\"")
			}
		case "inventory_slot3":
			requiredBitSet[9] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot3 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3\"")
			}
		case "inventory_slot3_quantity":
			requiredBitSet[9] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot3Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3_quantity\"")
			}
		case "inventory_slot4":
			requiredBitSet[9] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot4 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4\"")
			}
		case "inventory_slot4_quantity":
			requiredBitSet[9] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot4Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4_quantity\"")
			}
		case "inventory_slot5":
			requiredBitSet[9] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot5 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5\"")
			}
		case "inventory_slot5_quantity":
			requiredBitSet[10] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot5Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5_quantity\"")
			}
		case "inventory_slot6":
			requiredBitSet[10] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot6 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6\"")
			}
		case "inventory_slot6_quantity":
			requiredBitSet[10] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot6Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6_quantity\"")
			}
		case "inventory_slot7":
			requiredBitSet[10] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot7 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7\"")
			}
		case "inventory_slot7_quantity":
			requiredBitSet[10] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot7Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7_quantity\"")
			}
		case "inventory_slot8":
			requiredBitSet[10] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot8 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8\"")
			}
		case "inventory_slot8_quantity":
			requiredBitSet[10] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot8Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8_quantity\"")
			}
		case "inventory_slot9":
			requiredBitSet[10] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot9 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9\"")
			}
		case "inventory_slot9_quantity":
			requiredBitSet[11] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot9Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9_quantity\"")
			}
		case "inventory_slot10":
			requiredBitSet[11] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot10 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10\"")
			}
		case "inventory_slot10_quantity":
			requiredBitSet[11] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot10Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10_quantity\"")
			}
		case "inventory_slot11":
			requiredBitSet[11] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot11 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11\"")
			}
		case "inventory_slot11_quantity":
			requiredBitSet[11] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot11Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11_quantity\"")
			}
		case "inventory_slot12":
			requiredBitSet[11] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot12 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12\"")
			}
		case "inventory_slot12_quantity":
			requiredBitSet[11] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot12Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12_quantity\"")
			}
		case "inventory_slot13":
			requiredBitSet[11] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot13 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13\"")
			}
		case "inventory_slot13_quantity":
			requiredBitSet[12] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot13Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13_quantity\"")
			}
		case "inventory_slot14":
			requiredBitSet[12] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot14 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14\"")
			}
		case "inventory_slot14_quantity":
			requiredBitSet[12] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot14Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14_quantity\"")
			}
		case "inventory_slot15":
			requiredBitSet[12] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot15 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15\"")
			}
		case "inventory_slot15_quantity":
			requiredBitSet[12] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot15Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15_quantity\"")
			}
		case "inventory_slot16":
			requiredBitSet[12] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot16 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16\"")
			}
		case "inventory_slot16_quantity":
			requiredBitSet[12] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot16Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16_quantity\"")
			}
		case "inventory_slot17":
			requiredBitSet[12] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot17 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17\"")
			}
		case "inventory_slot17_quantity":
			requiredBitSet[13] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot17Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17_quantity\"")
			}
		case "inventory_slot18":
			requiredBitSet[13] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot18 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18\"")
			}
		case "inventory_slot18_quantity":
			requiredBitSet[13] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot18Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18_quantity\"")
			}
		case "inventory_slot19":
			requiredBitSet[13] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot19 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19\"")
			}
		case "inventory_slot19_quantity":
			requiredBitSet[13] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot19Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19_quantity\"")
			}
		case "inventory_slot20":
			requiredBitSet[13] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot20 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20\"")
			}
		case "inventory_slot20_quantity":
			requiredBitSet[13] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot20Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20_quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [14]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b10111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterSchema) {
					name = jsonFieldsNameOfCharacterSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterSchemaCooldownExpiration as json.
func (s CharacterSchemaCooldownExpiration) Encode(e *jx.Encoder) {
	switch s.Type {
	case DateTimeCharacterSchemaCooldownExpiration:
		json.EncodeDateTime(e, s.DateTime)
	case NullCharacterSchemaCooldownExpiration:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes CharacterSchemaCooldownExpiration from json.
func (s *CharacterSchemaCooldownExpiration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterSchemaCooldownExpiration to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullCharacterSchemaCooldownExpiration
	case jx.String:
		v, err := json.DecodeDateTime(d)
		s.DateTime = v
		if err != nil {
			return err
		}
		s.Type = DateTimeCharacterSchemaCooldownExpiration
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterSchemaCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterSchemaCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterSchemaSkin as json.
func (s CharacterSchemaSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterSchemaSkin from json.
func (s *CharacterSchemaSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterSchemaSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterSchemaSkin(v) {
	case CharacterSchemaSkinMen1:
		*s = CharacterSchemaSkinMen1
	case CharacterSchemaSkinMen2:
		*s = CharacterSchemaSkinMen2
	case CharacterSchemaSkinMen3:
		*s = CharacterSchemaSkinMen3
	case CharacterSchemaSkinWomen1:
		*s = CharacterSchemaSkinWomen1
	case CharacterSchemaSkinWomen2:
		*s = CharacterSchemaSkinWomen2
	case CharacterSchemaSkinWomen3:
		*s = CharacterSchemaSkinWomen3
	default:
		*s = CharacterSchemaSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterSchemaSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterSchemaSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CraftSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CraftSchema) encodeFields(e *jx.Encoder) {
	{
		if s.Skill.Set {
			e.FieldStart("skill")
			s.Skill.Encode(e)
		}
	}
	{
		if s.Level.Set {
			e.FieldStart("level")
			s.Level.Encode(e)
		}
	}
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
}

var jsonFieldsNameOfCraftSchema = [4]string{
	0: "skill",
	1: "level",
	2: "items",
	3: "quantity",
}

// Decode decodes CraftSchema from json.
func (s *CraftSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CraftSchema to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "skill":
			if err := func() error {
				s.Skill.Reset()
				if err := s.Skill.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skill\"")
			}
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "items":
			if err := func() error {
				s.Items = make([]SimpleItemSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SimpleItemSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CraftSchema")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CraftSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CraftSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CraftSchemaLevel as json.
func (s CraftSchemaLevel) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntCraftSchemaLevel:
		e.Int(s.Int)
	case NullCraftSchemaLevel:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes CraftSchemaLevel from json.
func (s *CraftSchemaLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CraftSchemaLevel to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullCraftSchemaLevel
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntCraftSchemaLevel
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CraftSchemaLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CraftSchemaLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CraftSchemaQuantity as json.
func (s CraftSchemaQuantity) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntCraftSchemaQuantity:
		e.Int(s.Int)
	case NullCraftSchemaQuantity:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes CraftSchemaQuantity from json.
func (s *CraftSchemaQuantity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CraftSchemaQuantity to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullCraftSchemaQuantity
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntCraftSchemaQuantity
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CraftSchemaQuantity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CraftSchemaQuantity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CraftSchemaSkill as json.
func (s CraftSchemaSkill) Encode(e *jx.Encoder) {
	switch s.Type {
	case CraftSchemaSkill0CraftSchemaSkill:
		s.CraftSchemaSkill0.Encode(e)
	case NullCraftSchemaSkill:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes CraftSchemaSkill from json.
func (s *CraftSchemaSkill) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CraftSchemaSkill to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullCraftSchemaSkill
	case jx.String:
		if err := s.CraftSchemaSkill0.Decode(d); err != nil {
			return err
		}
		s.Type = CraftSchemaSkill0CraftSchemaSkill
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CraftSchemaSkill) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CraftSchemaSkill) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CraftSchemaSkill0 as json.
func (s CraftSchemaSkill0) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CraftSchemaSkill0 from json.
func (s *CraftSchemaSkill0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CraftSchemaSkill0 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CraftSchemaSkill0(v) {
	case CraftSchemaSkill0Weaponcrafting:
		*s = CraftSchemaSkill0Weaponcrafting
	case CraftSchemaSkill0Gearcrafting:
		*s = CraftSchemaSkill0Gearcrafting
	case CraftSchemaSkill0Jewelrycrafting:
		*s = CraftSchemaSkill0Jewelrycrafting
	case CraftSchemaSkill0Cooking:
		*s = CraftSchemaSkill0Cooking
	case CraftSchemaSkill0Woodcutting:
		*s = CraftSchemaSkill0Woodcutting
	case CraftSchemaSkill0Mining:
		*s = CraftSchemaSkill0Mining
	default:
		*s = CraftSchemaSkill0(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CraftSchemaSkill0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CraftSchemaSkill0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CraftingSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CraftingSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
}

var jsonFieldsNameOfCraftingSchema = [2]string{
	0: "code",
	1: "quantity",
}

// Decode decodes CraftingSchema from json.
func (s *CraftingSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CraftingSchema to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CraftingSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCraftingSchema) {
					name = jsonFieldsNameOfCraftingSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CraftingSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CraftingSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageCharacterSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageCharacterSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageCharacterSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageCharacterSchema from json.
func (s *DataPageCharacterSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageCharacterSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]CharacterSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CharacterSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageCharacterSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageCharacterSchema) {
					name = jsonFieldsNameOfDataPageCharacterSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageCharacterSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageCharacterSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageCharacterSchemaPage as json.
func (s DataPageCharacterSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageCharacterSchemaPage:
		e.Int(s.Int)
	case NullDataPageCharacterSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageCharacterSchemaPage from json.
func (s *DataPageCharacterSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageCharacterSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageCharacterSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageCharacterSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageCharacterSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageCharacterSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageCharacterSchemaPages as json.
func (s DataPageCharacterSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageCharacterSchemaPages:
		e.Int(s.Int)
	case NullDataPageCharacterSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageCharacterSchemaPages from json.
func (s *DataPageCharacterSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageCharacterSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageCharacterSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageCharacterSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageCharacterSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageCharacterSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageCharacterSchemaSize as json.
func (s DataPageCharacterSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageCharacterSchemaSize:
		e.Int(s.Int)
	case NullDataPageCharacterSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageCharacterSchemaSize from json.
func (s *DataPageCharacterSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageCharacterSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageCharacterSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageCharacterSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageCharacterSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageCharacterSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageCharacterSchemaTotal as json.
func (s DataPageCharacterSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageCharacterSchemaTotal:
		e.Int(s.Int)
	case NullDataPageCharacterSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageCharacterSchemaTotal from json.
func (s *DataPageCharacterSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageCharacterSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageCharacterSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageCharacterSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageCharacterSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageCharacterSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageEventSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageEventSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageEventSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageEventSchema from json.
func (s *DataPageEventSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageEventSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]EventSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EventSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageEventSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageEventSchema) {
					name = jsonFieldsNameOfDataPageEventSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageEventSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageEventSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageEventSchemaPage as json.
func (s DataPageEventSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageEventSchemaPage:
		e.Int(s.Int)
	case NullDataPageEventSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageEventSchemaPage from json.
func (s *DataPageEventSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageEventSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageEventSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageEventSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageEventSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageEventSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageEventSchemaPages as json.
func (s DataPageEventSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageEventSchemaPages:
		e.Int(s.Int)
	case NullDataPageEventSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageEventSchemaPages from json.
func (s *DataPageEventSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageEventSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageEventSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageEventSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageEventSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageEventSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageEventSchemaSize as json.
func (s DataPageEventSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageEventSchemaSize:
		e.Int(s.Int)
	case NullDataPageEventSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageEventSchemaSize from json.
func (s *DataPageEventSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageEventSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageEventSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageEventSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageEventSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageEventSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageEventSchemaTotal as json.
func (s DataPageEventSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageEventSchemaTotal:
		e.Int(s.Int)
	case NullDataPageEventSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageEventSchemaTotal from json.
func (s *DataPageEventSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageEventSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageEventSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageEventSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageEventSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageEventSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageGEItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageGEItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageGEItemSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageGEItemSchema from json.
func (s *DataPageGEItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageGEItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]GEItemSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GEItemSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageGEItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageGEItemSchema) {
					name = jsonFieldsNameOfDataPageGEItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageGEItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageGEItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageGEItemSchemaPage as json.
func (s DataPageGEItemSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageGEItemSchemaPage:
		e.Int(s.Int)
	case NullDataPageGEItemSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageGEItemSchemaPage from json.
func (s *DataPageGEItemSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageGEItemSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageGEItemSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageGEItemSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageGEItemSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageGEItemSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageGEItemSchemaPages as json.
func (s DataPageGEItemSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageGEItemSchemaPages:
		e.Int(s.Int)
	case NullDataPageGEItemSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageGEItemSchemaPages from json.
func (s *DataPageGEItemSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageGEItemSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageGEItemSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageGEItemSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageGEItemSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageGEItemSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageGEItemSchemaSize as json.
func (s DataPageGEItemSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageGEItemSchemaSize:
		e.Int(s.Int)
	case NullDataPageGEItemSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageGEItemSchemaSize from json.
func (s *DataPageGEItemSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageGEItemSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageGEItemSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageGEItemSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageGEItemSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageGEItemSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageGEItemSchemaTotal as json.
func (s DataPageGEItemSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageGEItemSchemaTotal:
		e.Int(s.Int)
	case NullDataPageGEItemSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageGEItemSchemaTotal from json.
func (s *DataPageGEItemSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageGEItemSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageGEItemSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageGEItemSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageGEItemSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageGEItemSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageItemSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageItemSchema from json.
func (s *DataPageItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]ItemSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ItemSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageItemSchema) {
					name = jsonFieldsNameOfDataPageItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageItemSchemaPage as json.
func (s DataPageItemSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageItemSchemaPage:
		e.Int(s.Int)
	case NullDataPageItemSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageItemSchemaPage from json.
func (s *DataPageItemSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageItemSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageItemSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageItemSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageItemSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageItemSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageItemSchemaPages as json.
func (s DataPageItemSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageItemSchemaPages:
		e.Int(s.Int)
	case NullDataPageItemSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageItemSchemaPages from json.
func (s *DataPageItemSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageItemSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageItemSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageItemSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageItemSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageItemSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageItemSchemaSize as json.
func (s DataPageItemSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageItemSchemaSize:
		e.Int(s.Int)
	case NullDataPageItemSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageItemSchemaSize from json.
func (s *DataPageItemSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageItemSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageItemSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageItemSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageItemSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageItemSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageItemSchemaTotal as json.
func (s DataPageItemSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageItemSchemaTotal:
		e.Int(s.Int)
	case NullDataPageItemSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageItemSchemaTotal from json.
func (s *DataPageItemSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageItemSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageItemSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageItemSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageItemSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageItemSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageLogSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageLogSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageLogSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageLogSchema from json.
func (s *DataPageLogSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageLogSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]LogSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LogSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageLogSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageLogSchema) {
					name = jsonFieldsNameOfDataPageLogSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageLogSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageLogSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageLogSchemaPage as json.
func (s DataPageLogSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageLogSchemaPage:
		e.Int(s.Int)
	case NullDataPageLogSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageLogSchemaPage from json.
func (s *DataPageLogSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageLogSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageLogSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageLogSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageLogSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageLogSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageLogSchemaPages as json.
func (s DataPageLogSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageLogSchemaPages:
		e.Int(s.Int)
	case NullDataPageLogSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageLogSchemaPages from json.
func (s *DataPageLogSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageLogSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageLogSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageLogSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageLogSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageLogSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageLogSchemaSize as json.
func (s DataPageLogSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageLogSchemaSize:
		e.Int(s.Int)
	case NullDataPageLogSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageLogSchemaSize from json.
func (s *DataPageLogSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageLogSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageLogSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageLogSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageLogSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageLogSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageLogSchemaTotal as json.
func (s DataPageLogSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageLogSchemaTotal:
		e.Int(s.Int)
	case NullDataPageLogSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageLogSchemaTotal from json.
func (s *DataPageLogSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageLogSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageLogSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageLogSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageLogSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageLogSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageMapSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageMapSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageMapSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageMapSchema from json.
func (s *DataPageMapSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMapSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]MapSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MapSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageMapSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageMapSchema) {
					name = jsonFieldsNameOfDataPageMapSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageMapSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMapSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMapSchemaPage as json.
func (s DataPageMapSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMapSchemaPage:
		e.Int(s.Int)
	case NullDataPageMapSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMapSchemaPage from json.
func (s *DataPageMapSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMapSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMapSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMapSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMapSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMapSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMapSchemaPages as json.
func (s DataPageMapSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMapSchemaPages:
		e.Int(s.Int)
	case NullDataPageMapSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMapSchemaPages from json.
func (s *DataPageMapSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMapSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMapSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMapSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMapSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMapSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMapSchemaSize as json.
func (s DataPageMapSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMapSchemaSize:
		e.Int(s.Int)
	case NullDataPageMapSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMapSchemaSize from json.
func (s *DataPageMapSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMapSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMapSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMapSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMapSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMapSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMapSchemaTotal as json.
func (s DataPageMapSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMapSchemaTotal:
		e.Int(s.Int)
	case NullDataPageMapSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMapSchemaTotal from json.
func (s *DataPageMapSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMapSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMapSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMapSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMapSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMapSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageMonsterSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageMonsterSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageMonsterSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageMonsterSchema from json.
func (s *DataPageMonsterSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMonsterSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]MonsterSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MonsterSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageMonsterSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageMonsterSchema) {
					name = jsonFieldsNameOfDataPageMonsterSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageMonsterSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMonsterSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMonsterSchemaPage as json.
func (s DataPageMonsterSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMonsterSchemaPage:
		e.Int(s.Int)
	case NullDataPageMonsterSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMonsterSchemaPage from json.
func (s *DataPageMonsterSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMonsterSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMonsterSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMonsterSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMonsterSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMonsterSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMonsterSchemaPages as json.
func (s DataPageMonsterSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMonsterSchemaPages:
		e.Int(s.Int)
	case NullDataPageMonsterSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMonsterSchemaPages from json.
func (s *DataPageMonsterSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMonsterSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMonsterSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMonsterSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMonsterSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMonsterSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMonsterSchemaSize as json.
func (s DataPageMonsterSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMonsterSchemaSize:
		e.Int(s.Int)
	case NullDataPageMonsterSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMonsterSchemaSize from json.
func (s *DataPageMonsterSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMonsterSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMonsterSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMonsterSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMonsterSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMonsterSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMonsterSchemaTotal as json.
func (s DataPageMonsterSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMonsterSchemaTotal:
		e.Int(s.Int)
	case NullDataPageMonsterSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMonsterSchemaTotal from json.
func (s *DataPageMonsterSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMonsterSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMonsterSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMonsterSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMonsterSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMonsterSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageResourceSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageResourceSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageResourceSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageResourceSchema from json.
func (s *DataPageResourceSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageResourceSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]ResourceSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResourceSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageResourceSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageResourceSchema) {
					name = jsonFieldsNameOfDataPageResourceSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageResourceSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageResourceSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageResourceSchemaPage as json.
func (s DataPageResourceSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageResourceSchemaPage:
		e.Int(s.Int)
	case NullDataPageResourceSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageResourceSchemaPage from json.
func (s *DataPageResourceSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageResourceSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageResourceSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageResourceSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageResourceSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageResourceSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageResourceSchemaPages as json.
func (s DataPageResourceSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageResourceSchemaPages:
		e.Int(s.Int)
	case NullDataPageResourceSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageResourceSchemaPages from json.
func (s *DataPageResourceSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageResourceSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageResourceSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageResourceSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageResourceSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageResourceSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageResourceSchemaSize as json.
func (s DataPageResourceSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageResourceSchemaSize:
		e.Int(s.Int)
	case NullDataPageResourceSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageResourceSchemaSize from json.
func (s *DataPageResourceSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageResourceSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageResourceSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageResourceSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageResourceSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageResourceSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageResourceSchemaTotal as json.
func (s DataPageResourceSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageResourceSchemaTotal:
		e.Int(s.Int)
	case NullDataPageResourceSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageResourceSchemaTotal from json.
func (s *DataPageResourceSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageResourceSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageResourceSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageResourceSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageResourceSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageResourceSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageSimpleItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageSimpleItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageSimpleItemSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageSimpleItemSchema from json.
func (s *DataPageSimpleItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageSimpleItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]SimpleItemSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SimpleItemSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageSimpleItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageSimpleItemSchema) {
					name = jsonFieldsNameOfDataPageSimpleItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageSimpleItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageSimpleItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageSimpleItemSchemaPage as json.
func (s DataPageSimpleItemSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageSimpleItemSchemaPage:
		e.Int(s.Int)
	case NullDataPageSimpleItemSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageSimpleItemSchemaPage from json.
func (s *DataPageSimpleItemSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageSimpleItemSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageSimpleItemSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageSimpleItemSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageSimpleItemSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageSimpleItemSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageSimpleItemSchemaPages as json.
func (s DataPageSimpleItemSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageSimpleItemSchemaPages:
		e.Int(s.Int)
	case NullDataPageSimpleItemSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageSimpleItemSchemaPages from json.
func (s *DataPageSimpleItemSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageSimpleItemSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageSimpleItemSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageSimpleItemSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageSimpleItemSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageSimpleItemSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageSimpleItemSchemaSize as json.
func (s DataPageSimpleItemSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageSimpleItemSchemaSize:
		e.Int(s.Int)
	case NullDataPageSimpleItemSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageSimpleItemSchemaSize from json.
func (s *DataPageSimpleItemSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageSimpleItemSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageSimpleItemSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageSimpleItemSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageSimpleItemSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageSimpleItemSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageSimpleItemSchemaTotal as json.
func (s DataPageSimpleItemSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageSimpleItemSchemaTotal:
		e.Int(s.Int)
	case NullDataPageSimpleItemSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageSimpleItemSchemaTotal from json.
func (s *DataPageSimpleItemSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageSimpleItemSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageSimpleItemSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageSimpleItemSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageSimpleItemSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageSimpleItemSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteItemResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteItemResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfDeleteItemResponseSchema = [1]string{
	0: "data",
}

// Decode decodes DeleteItemResponseSchema from json.
func (s *DeleteItemResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteItemResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteItemResponseSchema) {
					name = jsonFieldsNameOfDeleteItemResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteItemResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("item")
		s.Item.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfDeleteItemSchema = [3]string{
	0: "cooldown",
	1: "item",
	2: "character",
}

// Decode decodes DeleteItemSchema from json.
func (s *DeleteItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "item":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Item.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteItemSchema) {
					name = jsonFieldsNameOfDeleteItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteItemSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteItemSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("total_xp")
		e.Int(s.TotalXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("inventory_slot1")
		e.Str(s.InventorySlot1)
	}
	{
		e.FieldStart("inventory_slot1_quantity")
		e.Int(s.InventorySlot1Quantity)
	}
	{
		e.FieldStart("inventory_slot2")
		e.Str(s.InventorySlot2)
	}
	{
		e.FieldStart("inventory_slot2_quantity")
		e.Int(s.InventorySlot2Quantity)
	}
	{
		e.FieldStart("inventory_slot3")
		e.Str(s.InventorySlot3)
	}
	{
		e.FieldStart("inventory_slot3_quantity")
		e.Int(s.InventorySlot3Quantity)
	}
	{
		e.FieldStart("inventory_slot4")
		e.Str(s.InventorySlot4)
	}
	{
		e.FieldStart("inventory_slot4_quantity")
		e.Int(s.InventorySlot4Quantity)
	}
	{
		e.FieldStart("inventory_slot5")
		e.Str(s.InventorySlot5)
	}
	{
		e.FieldStart("inventory_slot5_quantity")
		e.Int(s.InventorySlot5Quantity)
	}
	{
		e.FieldStart("inventory_slot6")
		e.Str(s.InventorySlot6)
	}
	{
		e.FieldStart("inventory_slot6_quantity")
		e.Int(s.InventorySlot6Quantity)
	}
	{
		e.FieldStart("inventory_slot7")
		e.Str(s.InventorySlot7)
	}
	{
		e.FieldStart("inventory_slot7_quantity")
		e.Int(s.InventorySlot7Quantity)
	}
	{
		e.FieldStart("inventory_slot8")
		e.Str(s.InventorySlot8)
	}
	{
		e.FieldStart("inventory_slot8_quantity")
		e.Int(s.InventorySlot8Quantity)
	}
	{
		e.FieldStart("inventory_slot9")
		e.Str(s.InventorySlot9)
	}
	{
		e.FieldStart("inventory_slot9_quantity")
		e.Int(s.InventorySlot9Quantity)
	}
	{
		e.FieldStart("inventory_slot10")
		e.Str(s.InventorySlot10)
	}
	{
		e.FieldStart("inventory_slot10_quantity")
		e.Int(s.InventorySlot10Quantity)
	}
	{
		e.FieldStart("inventory_slot11")
		e.Str(s.InventorySlot11)
	}
	{
		e.FieldStart("inventory_slot11_quantity")
		e.Int(s.InventorySlot11Quantity)
	}
	{
		e.FieldStart("inventory_slot12")
		e.Str(s.InventorySlot12)
	}
	{
		e.FieldStart("inventory_slot12_quantity")
		e.Int(s.InventorySlot12Quantity)
	}
	{
		e.FieldStart("inventory_slot13")
		e.Str(s.InventorySlot13)
	}
	{
		e.FieldStart("inventory_slot13_quantity")
		e.Int(s.InventorySlot13Quantity)
	}
	{
		e.FieldStart("inventory_slot14")
		e.Str(s.InventorySlot14)
	}
	{
		e.FieldStart("inventory_slot14_quantity")
		e.Int(s.InventorySlot14Quantity)
	}
	{
		e.FieldStart("inventory_slot15")
		e.Str(s.InventorySlot15)
	}
	{
		e.FieldStart("inventory_slot15_quantity")
		e.Int(s.InventorySlot15Quantity)
	}
	{
		e.FieldStart("inventory_slot16")
		e.Str(s.InventorySlot16)
	}
	{
		e.FieldStart("inventory_slot16_quantity")
		e.Int(s.InventorySlot16Quantity)
	}
	{
		e.FieldStart("inventory_slot17")
		e.Str(s.InventorySlot17)
	}
	{
		e.FieldStart("inventory_slot17_quantity")
		e.Int(s.InventorySlot17Quantity)
	}
	{
		e.FieldStart("inventory_slot18")
		e.Str(s.InventorySlot18)
	}
	{
		e.FieldStart("inventory_slot18_quantity")
		e.Int(s.InventorySlot18Quantity)
	}
	{
		e.FieldStart("inventory_slot19")
		e.Str(s.InventorySlot19)
	}
	{
		e.FieldStart("inventory_slot19_quantity")
		e.Int(s.InventorySlot19Quantity)
	}
	{
		e.FieldStart("inventory_slot20")
		e.Str(s.InventorySlot20)
	}
	{
		e.FieldStart("inventory_slot20_quantity")
		e.Int(s.InventorySlot20Quantity)
	}
}

var jsonFieldsNameOfDeleteItemSchemaCharacter = [111]string{
	0:   "name",
	1:   "skin",
	2:   "level",
	3:   "xp",
	4:   "max_xp",
	5:   "total_xp",
	6:   "gold",
	7:   "speed",
	8:   "mining_level",
	9:   "mining_xp",
	10:  "mining_max_xp",
	11:  "woodcutting_level",
	12:  "woodcutting_xp",
	13:  "woodcutting_max_xp",
	14:  "fishing_level",
	15:  "fishing_xp",
	16:  "fishing_max_xp",
	17:  "weaponcrafting_level",
	18:  "weaponcrafting_xp",
	19:  "weaponcrafting_max_xp",
	20:  "gearcrafting_level",
	21:  "gearcrafting_xp",
	22:  "gearcrafting_max_xp",
	23:  "jewelrycrafting_level",
	24:  "jewelrycrafting_xp",
	25:  "jewelrycrafting_max_xp",
	26:  "cooking_level",
	27:  "cooking_xp",
	28:  "cooking_max_xp",
	29:  "hp",
	30:  "haste",
	31:  "critical_strike",
	32:  "stamina",
	33:  "attack_fire",
	34:  "attack_earth",
	35:  "attack_water",
	36:  "attack_air",
	37:  "dmg_fire",
	38:  "dmg_earth",
	39:  "dmg_water",
	40:  "dmg_air",
	41:  "res_fire",
	42:  "res_earth",
	43:  "res_water",
	44:  "res_air",
	45:  "x",
	46:  "y",
	47:  "cooldown",
	48:  "cooldown_expiration",
	49:  "weapon_slot",
	50:  "shield_slot",
	51:  "helmet_slot",
	52:  "body_armor_slot",
	53:  "leg_armor_slot",
	54:  "boots_slot",
	55:  "ring1_slot",
	56:  "ring2_slot",
	57:  "amulet_slot",
	58:  "artifact1_slot",
	59:  "artifact2_slot",
	60:  "artifact3_slot",
	61:  "consumable1_slot",
	62:  "consumable1_slot_quantity",
	63:  "consumable2_slot",
	64:  "consumable2_slot_quantity",
	65:  "task",
	66:  "task_type",
	67:  "task_progress",
	68:  "task_total",
	69:  "inventory_max_items",
	70:  "inventory",
	71:  "inventory_slot1",
	72:  "inventory_slot1_quantity",
	73:  "inventory_slot2",
	74:  "inventory_slot2_quantity",
	75:  "inventory_slot3",
	76:  "inventory_slot3_quantity",
	77:  "inventory_slot4",
	78:  "inventory_slot4_quantity",
	79:  "inventory_slot5",
	80:  "inventory_slot5_quantity",
	81:  "inventory_slot6",
	82:  "inventory_slot6_quantity",
	83:  "inventory_slot7",
	84:  "inventory_slot7_quantity",
	85:  "inventory_slot8",
	86:  "inventory_slot8_quantity",
	87:  "inventory_slot9",
	88:  "inventory_slot9_quantity",
	89:  "inventory_slot10",
	90:  "inventory_slot10_quantity",
	91:  "inventory_slot11",
	92:  "inventory_slot11_quantity",
	93:  "inventory_slot12",
	94:  "inventory_slot12_quantity",
	95:  "inventory_slot13",
	96:  "inventory_slot13_quantity",
	97:  "inventory_slot14",
	98:  "inventory_slot14_quantity",
	99:  "inventory_slot15",
	100: "inventory_slot15_quantity",
	101: "inventory_slot16",
	102: "inventory_slot16_quantity",
	103: "inventory_slot17",
	104: "inventory_slot17_quantity",
	105: "inventory_slot18",
	106: "inventory_slot18_quantity",
	107: "inventory_slot19",
	108: "inventory_slot19_quantity",
	109: "inventory_slot20",
	110: "inventory_slot20_quantity",
}

// Decode decodes DeleteItemSchemaCharacter from json.
func (s *DeleteItemSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemSchemaCharacter to nil")
	}
	var requiredBitSet [14]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "total_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.TotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		case "inventory_slot1":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot1 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1\"")
			}
		case "inventory_slot1_quantity":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot1Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1_quantity\"")
			}
		case "inventory_slot2":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot2 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2\"")
			}
		case "inventory_slot2_quantity":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot2Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2_quantity\"")
			}
		case "inventory_slot3":
			requiredBitSet[9] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot3 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3\"")
			}
		case "inventory_slot3_quantity":
			requiredBitSet[9] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot3Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3_quantity\"")
			}
		case "inventory_slot4":
			requiredBitSet[9] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot4 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4\"")
			}
		case "inventory_slot4_quantity":
			requiredBitSet[9] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot4Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4_quantity\"")
			}
		case "inventory_slot5":
			requiredBitSet[9] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot5 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5\"")
			}
		case "inventory_slot5_quantity":
			requiredBitSet[10] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot5Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5_quantity\"")
			}
		case "inventory_slot6":
			requiredBitSet[10] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot6 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6\"")
			}
		case "inventory_slot6_quantity":
			requiredBitSet[10] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot6Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6_quantity\"")
			}
		case "inventory_slot7":
			requiredBitSet[10] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot7 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7\"")
			}
		case "inventory_slot7_quantity":
			requiredBitSet[10] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot7Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7_quantity\"")
			}
		case "inventory_slot8":
			requiredBitSet[10] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot8 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8\"")
			}
		case "inventory_slot8_quantity":
			requiredBitSet[10] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot8Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8_quantity\"")
			}
		case "inventory_slot9":
			requiredBitSet[10] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot9 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9\"")
			}
		case "inventory_slot9_quantity":
			requiredBitSet[11] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot9Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9_quantity\"")
			}
		case "inventory_slot10":
			requiredBitSet[11] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot10 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10\"")
			}
		case "inventory_slot10_quantity":
			requiredBitSet[11] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot10Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10_quantity\"")
			}
		case "inventory_slot11":
			requiredBitSet[11] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot11 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11\"")
			}
		case "inventory_slot11_quantity":
			requiredBitSet[11] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot11Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11_quantity\"")
			}
		case "inventory_slot12":
			requiredBitSet[11] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot12 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12\"")
			}
		case "inventory_slot12_quantity":
			requiredBitSet[11] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot12Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12_quantity\"")
			}
		case "inventory_slot13":
			requiredBitSet[11] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot13 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13\"")
			}
		case "inventory_slot13_quantity":
			requiredBitSet[12] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot13Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13_quantity\"")
			}
		case "inventory_slot14":
			requiredBitSet[12] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot14 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14\"")
			}
		case "inventory_slot14_quantity":
			requiredBitSet[12] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot14Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14_quantity\"")
			}
		case "inventory_slot15":
			requiredBitSet[12] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot15 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15\"")
			}
		case "inventory_slot15_quantity":
			requiredBitSet[12] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot15Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15_quantity\"")
			}
		case "inventory_slot16":
			requiredBitSet[12] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot16 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16\"")
			}
		case "inventory_slot16_quantity":
			requiredBitSet[12] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot16Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16_quantity\"")
			}
		case "inventory_slot17":
			requiredBitSet[12] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot17 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17\"")
			}
		case "inventory_slot17_quantity":
			requiredBitSet[13] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot17Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17_quantity\"")
			}
		case "inventory_slot18":
			requiredBitSet[13] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot18 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18\"")
			}
		case "inventory_slot18_quantity":
			requiredBitSet[13] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot18Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18_quantity\"")
			}
		case "inventory_slot19":
			requiredBitSet[13] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot19 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19\"")
			}
		case "inventory_slot19_quantity":
			requiredBitSet[13] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot19Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19_quantity\"")
			}
		case "inventory_slot20":
			requiredBitSet[13] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot20 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20\"")
			}
		case "inventory_slot20_quantity":
			requiredBitSet[13] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot20Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20_quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteItemSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [14]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b10111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteItemSchemaCharacter) {
					name = jsonFieldsNameOfDeleteItemSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteItemSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteItemSchemaCharacterCooldownExpiration as json.
func (s DeleteItemSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	switch s.Type {
	case DateTimeDeleteItemSchemaCharacterCooldownExpiration:
		json.EncodeDateTime(e, s.DateTime)
	case NullDeleteItemSchemaCharacterCooldownExpiration:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DeleteItemSchemaCharacterCooldownExpiration from json.
func (s *DeleteItemSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemSchemaCharacterCooldownExpiration to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDeleteItemSchemaCharacterCooldownExpiration
	case jx.String:
		v, err := json.DecodeDateTime(d)
		s.DateTime = v
		if err != nil {
			return err
		}
		s.Type = DateTimeDeleteItemSchemaCharacterCooldownExpiration
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteItemSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteItemSchemaCharacterSkin as json.
func (s DeleteItemSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DeleteItemSchemaCharacterSkin from json.
func (s *DeleteItemSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DeleteItemSchemaCharacterSkin(v) {
	case DeleteItemSchemaCharacterSkinMen1:
		*s = DeleteItemSchemaCharacterSkinMen1
	case DeleteItemSchemaCharacterSkinMen2:
		*s = DeleteItemSchemaCharacterSkinMen2
	case DeleteItemSchemaCharacterSkinMen3:
		*s = DeleteItemSchemaCharacterSkinMen3
	case DeleteItemSchemaCharacterSkinWomen1:
		*s = DeleteItemSchemaCharacterSkinWomen1
	case DeleteItemSchemaCharacterSkinWomen2:
		*s = DeleteItemSchemaCharacterSkinWomen2
	case DeleteItemSchemaCharacterSkinWomen3:
		*s = DeleteItemSchemaCharacterSkinWomen3
	default:
		*s = DeleteItemSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteItemSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteItemSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteItemSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfDeleteItemSchemaCooldown = [4]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "expiration",
	3: "reason",
}

// Decode decodes DeleteItemSchemaCooldown from json.
func (s *DeleteItemSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteItemSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteItemSchemaCooldown) {
					name = jsonFieldsNameOfDeleteItemSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteItemSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteItemSchemaCooldownReason as json.
func (s DeleteItemSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DeleteItemSchemaCooldownReason from json.
func (s *DeleteItemSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DeleteItemSchemaCooldownReason(v) {
	case DeleteItemSchemaCooldownReasonMovement:
		*s = DeleteItemSchemaCooldownReasonMovement
	case DeleteItemSchemaCooldownReasonFight:
		*s = DeleteItemSchemaCooldownReasonFight
	case DeleteItemSchemaCooldownReasonCrafting:
		*s = DeleteItemSchemaCooldownReasonCrafting
	case DeleteItemSchemaCooldownReasonGathering:
		*s = DeleteItemSchemaCooldownReasonGathering
	case DeleteItemSchemaCooldownReasonBuyGe:
		*s = DeleteItemSchemaCooldownReasonBuyGe
	case DeleteItemSchemaCooldownReasonSellGe:
		*s = DeleteItemSchemaCooldownReasonSellGe
	case DeleteItemSchemaCooldownReasonDeleteItem:
		*s = DeleteItemSchemaCooldownReasonDeleteItem
	case DeleteItemSchemaCooldownReasonDepositBank:
		*s = DeleteItemSchemaCooldownReasonDepositBank
	case DeleteItemSchemaCooldownReasonWithdrawBank:
		*s = DeleteItemSchemaCooldownReasonWithdrawBank
	case DeleteItemSchemaCooldownReasonEquip:
		*s = DeleteItemSchemaCooldownReasonEquip
	case DeleteItemSchemaCooldownReasonUnequip:
		*s = DeleteItemSchemaCooldownReasonUnequip
	case DeleteItemSchemaCooldownReasonTask:
		*s = DeleteItemSchemaCooldownReasonTask
	case DeleteItemSchemaCooldownReasonRecycling:
		*s = DeleteItemSchemaCooldownReasonRecycling
	default:
		*s = DeleteItemSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteItemSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteItemSchemaItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteItemSchemaItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfDeleteItemSchemaItem = [2]string{
	0: "code",
	1: "quantity",
}

// Decode decodes DeleteItemSchemaItem from json.
func (s *DeleteItemSchemaItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemSchemaItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteItemSchemaItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteItemSchemaItem) {
					name = jsonFieldsNameOfDeleteItemSchemaItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteItemSchemaItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemSchemaItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DepositWithdrawGoldSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DepositWithdrawGoldSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfDepositWithdrawGoldSchema = [1]string{
	0: "quantity",
}

// Decode decodes DepositWithdrawGoldSchema from json.
func (s *DepositWithdrawGoldSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DepositWithdrawGoldSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "quantity":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DepositWithdrawGoldSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDepositWithdrawGoldSchema) {
					name = jsonFieldsNameOfDepositWithdrawGoldSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DepositWithdrawGoldSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DepositWithdrawGoldSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DestinationSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DestinationSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
}

var jsonFieldsNameOfDestinationSchema = [2]string{
	0: "x",
	1: "y",
}

// Decode decodes DestinationSchema from json.
func (s *DestinationSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DestinationSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DestinationSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDestinationSchema) {
					name = jsonFieldsNameOfDestinationSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DestinationSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DestinationSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DropRateSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DropRateSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("rate")
		e.Int(s.Rate)
	}
	{
		e.FieldStart("min_quantity")
		e.Int(s.MinQuantity)
	}
	{
		e.FieldStart("max_quantity")
		e.Int(s.MaxQuantity)
	}
}

var jsonFieldsNameOfDropRateSchema = [4]string{
	0: "code",
	1: "rate",
	2: "min_quantity",
	3: "max_quantity",
}

// Decode decodes DropRateSchema from json.
func (s *DropRateSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DropRateSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "rate":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Rate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate\"")
			}
		case "min_quantity":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MinQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_quantity\"")
			}
		case "max_quantity":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.MaxQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DropRateSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDropRateSchema) {
					name = jsonFieldsNameOfDropRateSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DropRateSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DropRateSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DropSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DropSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfDropSchema = [2]string{
	0: "code",
	1: "quantity",
}

// Decode decodes DropSchema from json.
func (s *DropSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DropSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DropSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDropSchema) {
					name = jsonFieldsNameOfDropSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DropSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DropSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EquipRequestSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EquipRequestSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("slot")
		s.Slot.Encode(e)
	}
	{
		e.FieldStart("item")
		s.Item.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfEquipRequestSchema = [4]string{
	0: "cooldown",
	1: "slot",
	2: "item",
	3: "character",
}

// Decode decodes EquipRequestSchema from json.
func (s *EquipRequestSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "slot":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Slot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slot\"")
			}
		case "item":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Item.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EquipRequestSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEquipRequestSchema) {
					name = jsonFieldsNameOfEquipRequestSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EquipRequestSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EquipRequestSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EquipRequestSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("total_xp")
		e.Int(s.TotalXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("inventory_slot1")
		e.Str(s.InventorySlot1)
	}
	{
		e.FieldStart("inventory_slot1_quantity")
		e.Int(s.InventorySlot1Quantity)
	}
	{
		e.FieldStart("inventory_slot2")
		e.Str(s.InventorySlot2)
	}
	{
		e.FieldStart("inventory_slot2_quantity")
		e.Int(s.InventorySlot2Quantity)
	}
	{
		e.FieldStart("inventory_slot3")
		e.Str(s.InventorySlot3)
	}
	{
		e.FieldStart("inventory_slot3_quantity")
		e.Int(s.InventorySlot3Quantity)
	}
	{
		e.FieldStart("inventory_slot4")
		e.Str(s.InventorySlot4)
	}
	{
		e.FieldStart("inventory_slot4_quantity")
		e.Int(s.InventorySlot4Quantity)
	}
	{
		e.FieldStart("inventory_slot5")
		e.Str(s.InventorySlot5)
	}
	{
		e.FieldStart("inventory_slot5_quantity")
		e.Int(s.InventorySlot5Quantity)
	}
	{
		e.FieldStart("inventory_slot6")
		e.Str(s.InventorySlot6)
	}
	{
		e.FieldStart("inventory_slot6_quantity")
		e.Int(s.InventorySlot6Quantity)
	}
	{
		e.FieldStart("inventory_slot7")
		e.Str(s.InventorySlot7)
	}
	{
		e.FieldStart("inventory_slot7_quantity")
		e.Int(s.InventorySlot7Quantity)
	}
	{
		e.FieldStart("inventory_slot8")
		e.Str(s.InventorySlot8)
	}
	{
		e.FieldStart("inventory_slot8_quantity")
		e.Int(s.InventorySlot8Quantity)
	}
	{
		e.FieldStart("inventory_slot9")
		e.Str(s.InventorySlot9)
	}
	{
		e.FieldStart("inventory_slot9_quantity")
		e.Int(s.InventorySlot9Quantity)
	}
	{
		e.FieldStart("inventory_slot10")
		e.Str(s.InventorySlot10)
	}
	{
		e.FieldStart("inventory_slot10_quantity")
		e.Int(s.InventorySlot10Quantity)
	}
	{
		e.FieldStart("inventory_slot11")
		e.Str(s.InventorySlot11)
	}
	{
		e.FieldStart("inventory_slot11_quantity")
		e.Int(s.InventorySlot11Quantity)
	}
	{
		e.FieldStart("inventory_slot12")
		e.Str(s.InventorySlot12)
	}
	{
		e.FieldStart("inventory_slot12_quantity")
		e.Int(s.InventorySlot12Quantity)
	}
	{
		e.FieldStart("inventory_slot13")
		e.Str(s.InventorySlot13)
	}
	{
		e.FieldStart("inventory_slot13_quantity")
		e.Int(s.InventorySlot13Quantity)
	}
	{
		e.FieldStart("inventory_slot14")
		e.Str(s.InventorySlot14)
	}
	{
		e.FieldStart("inventory_slot14_quantity")
		e.Int(s.InventorySlot14Quantity)
	}
	{
		e.FieldStart("inventory_slot15")
		e.Str(s.InventorySlot15)
	}
	{
		e.FieldStart("inventory_slot15_quantity")
		e.Int(s.InventorySlot15Quantity)
	}
	{
		e.FieldStart("inventory_slot16")
		e.Str(s.InventorySlot16)
	}
	{
		e.FieldStart("inventory_slot16_quantity")
		e.Int(s.InventorySlot16Quantity)
	}
	{
		e.FieldStart("inventory_slot17")
		e.Str(s.InventorySlot17)
	}
	{
		e.FieldStart("inventory_slot17_quantity")
		e.Int(s.InventorySlot17Quantity)
	}
	{
		e.FieldStart("inventory_slot18")
		e.Str(s.InventorySlot18)
	}
	{
		e.FieldStart("inventory_slot18_quantity")
		e.Int(s.InventorySlot18Quantity)
	}
	{
		e.FieldStart("inventory_slot19")
		e.Str(s.InventorySlot19)
	}
	{
		e.FieldStart("inventory_slot19_quantity")
		e.Int(s.InventorySlot19Quantity)
	}
	{
		e.FieldStart("inventory_slot20")
		e.Str(s.InventorySlot20)
	}
	{
		e.FieldStart("inventory_slot20_quantity")
		e.Int(s.InventorySlot20Quantity)
	}
}

var jsonFieldsNameOfEquipRequestSchemaCharacter = [111]string{
	0:   "name",
	1:   "skin",
	2:   "level",
	3:   "xp",
	4:   "max_xp",
	5:   "total_xp",
	6:   "gold",
	7:   "speed",
	8:   "mining_level",
	9:   "mining_xp",
	10:  "mining_max_xp",
	11:  "woodcutting_level",
	12:  "woodcutting_xp",
	13:  "woodcutting_max_xp",
	14:  "fishing_level",
	15:  "fishing_xp",
	16:  "fishing_max_xp",
	17:  "weaponcrafting_level",
	18:  "weaponcrafting_xp",
	19:  "weaponcrafting_max_xp",
	20:  "gearcrafting_level",
	21:  "gearcrafting_xp",
	22:  "gearcrafting_max_xp",
	23:  "jewelrycrafting_level",
	24:  "jewelrycrafting_xp",
	25:  "jewelrycrafting_max_xp",
	26:  "cooking_level",
	27:  "cooking_xp",
	28:  "cooking_max_xp",
	29:  "hp",
	30:  "haste",
	31:  "critical_strike",
	32:  "stamina",
	33:  "attack_fire",
	34:  "attack_earth",
	35:  "attack_water",
	36:  "attack_air",
	37:  "dmg_fire",
	38:  "dmg_earth",
	39:  "dmg_water",
	40:  "dmg_air",
	41:  "res_fire",
	42:  "res_earth",
	43:  "res_water",
	44:  "res_air",
	45:  "x",
	46:  "y",
	47:  "cooldown",
	48:  "cooldown_expiration",
	49:  "weapon_slot",
	50:  "shield_slot",
	51:  "helmet_slot",
	52:  "body_armor_slot",
	53:  "leg_armor_slot",
	54:  "boots_slot",
	55:  "ring1_slot",
	56:  "ring2_slot",
	57:  "amulet_slot",
	58:  "artifact1_slot",
	59:  "artifact2_slot",
	60:  "artifact3_slot",
	61:  "consumable1_slot",
	62:  "consumable1_slot_quantity",
	63:  "consumable2_slot",
	64:  "consumable2_slot_quantity",
	65:  "task",
	66:  "task_type",
	67:  "task_progress",
	68:  "task_total",
	69:  "inventory_max_items",
	70:  "inventory",
	71:  "inventory_slot1",
	72:  "inventory_slot1_quantity",
	73:  "inventory_slot2",
	74:  "inventory_slot2_quantity",
	75:  "inventory_slot3",
	76:  "inventory_slot3_quantity",
	77:  "inventory_slot4",
	78:  "inventory_slot4_quantity",
	79:  "inventory_slot5",
	80:  "inventory_slot5_quantity",
	81:  "inventory_slot6",
	82:  "inventory_slot6_quantity",
	83:  "inventory_slot7",
	84:  "inventory_slot7_quantity",
	85:  "inventory_slot8",
	86:  "inventory_slot8_quantity",
	87:  "inventory_slot9",
	88:  "inventory_slot9_quantity",
	89:  "inventory_slot10",
	90:  "inventory_slot10_quantity",
	91:  "inventory_slot11",
	92:  "inventory_slot11_quantity",
	93:  "inventory_slot12",
	94:  "inventory_slot12_quantity",
	95:  "inventory_slot13",
	96:  "inventory_slot13_quantity",
	97:  "inventory_slot14",
	98:  "inventory_slot14_quantity",
	99:  "inventory_slot15",
	100: "inventory_slot15_quantity",
	101: "inventory_slot16",
	102: "inventory_slot16_quantity",
	103: "inventory_slot17",
	104: "inventory_slot17_quantity",
	105: "inventory_slot18",
	106: "inventory_slot18_quantity",
	107: "inventory_slot19",
	108: "inventory_slot19_quantity",
	109: "inventory_slot20",
	110: "inventory_slot20_quantity",
}

// Decode decodes EquipRequestSchemaCharacter from json.
func (s *EquipRequestSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaCharacter to nil")
	}
	var requiredBitSet [14]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "total_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.TotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		case "inventory_slot1":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot1 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1\"")
			}
		case "inventory_slot1_quantity":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot1Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1_quantity\"")
			}
		case "inventory_slot2":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot2 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2\"")
			}
		case "inventory_slot2_quantity":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot2Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2_quantity\"")
			}
		case "inventory_slot3":
			requiredBitSet[9] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot3 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3\"")
			}
		case "inventory_slot3_quantity":
			requiredBitSet[9] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot3Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3_quantity\"")
			}
		case "inventory_slot4":
			requiredBitSet[9] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot4 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4\"")
			}
		case "inventory_slot4_quantity":
			requiredBitSet[9] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot4Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4_quantity\"")
			}
		case "inventory_slot5":
			requiredBitSet[9] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot5 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5\"")
			}
		case "inventory_slot5_quantity":
			requiredBitSet[10] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot5Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5_quantity\"")
			}
		case "inventory_slot6":
			requiredBitSet[10] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot6 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6\"")
			}
		case "inventory_slot6_quantity":
			requiredBitSet[10] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot6Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6_quantity\"")
			}
		case "inventory_slot7":
			requiredBitSet[10] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot7 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7\"")
			}
		case "inventory_slot7_quantity":
			requiredBitSet[10] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot7Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7_quantity\"")
			}
		case "inventory_slot8":
			requiredBitSet[10] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot8 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8\"")
			}
		case "inventory_slot8_quantity":
			requiredBitSet[10] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot8Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8_quantity\"")
			}
		case "inventory_slot9":
			requiredBitSet[10] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot9 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9\"")
			}
		case "inventory_slot9_quantity":
			requiredBitSet[11] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot9Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9_quantity\"")
			}
		case "inventory_slot10":
			requiredBitSet[11] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot10 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10\"")
			}
		case "inventory_slot10_quantity":
			requiredBitSet[11] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot10Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10_quantity\"")
			}
		case "inventory_slot11":
			requiredBitSet[11] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot11 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11\"")
			}
		case "inventory_slot11_quantity":
			requiredBitSet[11] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot11Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11_quantity\"")
			}
		case "inventory_slot12":
			requiredBitSet[11] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot12 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12\"")
			}
		case "inventory_slot12_quantity":
			requiredBitSet[11] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot12Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12_quantity\"")
			}
		case "inventory_slot13":
			requiredBitSet[11] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot13 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13\"")
			}
		case "inventory_slot13_quantity":
			requiredBitSet[12] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot13Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13_quantity\"")
			}
		case "inventory_slot14":
			requiredBitSet[12] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot14 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14\"")
			}
		case "inventory_slot14_quantity":
			requiredBitSet[12] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot14Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14_quantity\"")
			}
		case "inventory_slot15":
			requiredBitSet[12] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot15 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15\"")
			}
		case "inventory_slot15_quantity":
			requiredBitSet[12] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot15Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15_quantity\"")
			}
		case "inventory_slot16":
			requiredBitSet[12] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot16 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16\"")
			}
		case "inventory_slot16_quantity":
			requiredBitSet[12] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot16Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16_quantity\"")
			}
		case "inventory_slot17":
			requiredBitSet[12] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot17 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17\"")
			}
		case "inventory_slot17_quantity":
			requiredBitSet[13] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot17Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17_quantity\"")
			}
		case "inventory_slot18":
			requiredBitSet[13] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot18 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18\"")
			}
		case "inventory_slot18_quantity":
			requiredBitSet[13] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot18Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18_quantity\"")
			}
		case "inventory_slot19":
			requiredBitSet[13] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot19 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19\"")
			}
		case "inventory_slot19_quantity":
			requiredBitSet[13] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot19Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19_quantity\"")
			}
		case "inventory_slot20":
			requiredBitSet[13] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot20 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20\"")
			}
		case "inventory_slot20_quantity":
			requiredBitSet[13] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot20Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20_quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EquipRequestSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [14]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b10111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEquipRequestSchemaCharacter) {
					name = jsonFieldsNameOfEquipRequestSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EquipRequestSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EquipRequestSchemaCharacterCooldownExpiration as json.
func (s EquipRequestSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	switch s.Type {
	case DateTimeEquipRequestSchemaCharacterCooldownExpiration:
		json.EncodeDateTime(e, s.DateTime)
	case NullEquipRequestSchemaCharacterCooldownExpiration:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes EquipRequestSchemaCharacterCooldownExpiration from json.
func (s *EquipRequestSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaCharacterCooldownExpiration to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullEquipRequestSchemaCharacterCooldownExpiration
	case jx.String:
		v, err := json.DecodeDateTime(d)
		s.DateTime = v
		if err != nil {
			return err
		}
		s.Type = DateTimeEquipRequestSchemaCharacterCooldownExpiration
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EquipRequestSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EquipRequestSchemaCharacterSkin as json.
func (s EquipRequestSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EquipRequestSchemaCharacterSkin from json.
func (s *EquipRequestSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EquipRequestSchemaCharacterSkin(v) {
	case EquipRequestSchemaCharacterSkinMen1:
		*s = EquipRequestSchemaCharacterSkinMen1
	case EquipRequestSchemaCharacterSkinMen2:
		*s = EquipRequestSchemaCharacterSkinMen2
	case EquipRequestSchemaCharacterSkinMen3:
		*s = EquipRequestSchemaCharacterSkinMen3
	case EquipRequestSchemaCharacterSkinWomen1:
		*s = EquipRequestSchemaCharacterSkinWomen1
	case EquipRequestSchemaCharacterSkinWomen2:
		*s = EquipRequestSchemaCharacterSkinWomen2
	case EquipRequestSchemaCharacterSkinWomen3:
		*s = EquipRequestSchemaCharacterSkinWomen3
	default:
		*s = EquipRequestSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EquipRequestSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EquipRequestSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EquipRequestSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfEquipRequestSchemaCooldown = [4]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "expiration",
	3: "reason",
}

// Decode decodes EquipRequestSchemaCooldown from json.
func (s *EquipRequestSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EquipRequestSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEquipRequestSchemaCooldown) {
					name = jsonFieldsNameOfEquipRequestSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EquipRequestSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EquipRequestSchemaCooldownReason as json.
func (s EquipRequestSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EquipRequestSchemaCooldownReason from json.
func (s *EquipRequestSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EquipRequestSchemaCooldownReason(v) {
	case EquipRequestSchemaCooldownReasonMovement:
		*s = EquipRequestSchemaCooldownReasonMovement
	case EquipRequestSchemaCooldownReasonFight:
		*s = EquipRequestSchemaCooldownReasonFight
	case EquipRequestSchemaCooldownReasonCrafting:
		*s = EquipRequestSchemaCooldownReasonCrafting
	case EquipRequestSchemaCooldownReasonGathering:
		*s = EquipRequestSchemaCooldownReasonGathering
	case EquipRequestSchemaCooldownReasonBuyGe:
		*s = EquipRequestSchemaCooldownReasonBuyGe
	case EquipRequestSchemaCooldownReasonSellGe:
		*s = EquipRequestSchemaCooldownReasonSellGe
	case EquipRequestSchemaCooldownReasonDeleteItem:
		*s = EquipRequestSchemaCooldownReasonDeleteItem
	case EquipRequestSchemaCooldownReasonDepositBank:
		*s = EquipRequestSchemaCooldownReasonDepositBank
	case EquipRequestSchemaCooldownReasonWithdrawBank:
		*s = EquipRequestSchemaCooldownReasonWithdrawBank
	case EquipRequestSchemaCooldownReasonEquip:
		*s = EquipRequestSchemaCooldownReasonEquip
	case EquipRequestSchemaCooldownReasonUnequip:
		*s = EquipRequestSchemaCooldownReasonUnequip
	case EquipRequestSchemaCooldownReasonTask:
		*s = EquipRequestSchemaCooldownReasonTask
	case EquipRequestSchemaCooldownReasonRecycling:
		*s = EquipRequestSchemaCooldownReasonRecycling
	default:
		*s = EquipRequestSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EquipRequestSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EquipRequestSchemaItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EquipRequestSchemaItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("subtype")
		e.Str(s.Subtype)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Effects != nil {
			e.FieldStart("effects")
			e.ArrStart()
			for _, elem := range s.Effects {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Craft.Set {
			e.FieldStart("craft")
			s.Craft.Encode(e)
		}
	}
}

var jsonFieldsNameOfEquipRequestSchemaItem = [8]string{
	0: "name",
	1: "code",
	2: "level",
	3: "type",
	4: "subtype",
	5: "description",
	6: "effects",
	7: "craft",
}

// Decode decodes EquipRequestSchemaItem from json.
func (s *EquipRequestSchemaItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "subtype":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Subtype = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subtype\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "effects":
			if err := func() error {
				s.Effects = make([]ItemEffectSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ItemEffectSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Effects = append(s.Effects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effects\"")
			}
		case "craft":
			if err := func() error {
				s.Craft.Reset()
				if err := s.Craft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"craft\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EquipRequestSchemaItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEquipRequestSchemaItem) {
					name = jsonFieldsNameOfEquipRequestSchemaItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EquipRequestSchemaItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EquipRequestSchemaItemCraft as json.
func (s EquipRequestSchemaItemCraft) Encode(e *jx.Encoder) {
	switch s.Type {
	case CraftSchemaEquipRequestSchemaItemCraft:
		s.CraftSchema.Encode(e)
	case NullEquipRequestSchemaItemCraft:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes EquipRequestSchemaItemCraft from json.
func (s *EquipRequestSchemaItemCraft) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaItemCraft to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullEquipRequestSchemaItemCraft
	case jx.Object:
		if err := s.CraftSchema.Decode(d); err != nil {
			return err
		}
		s.Type = CraftSchemaEquipRequestSchemaItemCraft
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EquipRequestSchemaItemCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaItemCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EquipRequestSchemaSlot as json.
func (s EquipRequestSchemaSlot) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EquipRequestSchemaSlot from json.
func (s *EquipRequestSchemaSlot) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaSlot to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EquipRequestSchemaSlot(v) {
	case EquipRequestSchemaSlotWeapon:
		*s = EquipRequestSchemaSlotWeapon
	case EquipRequestSchemaSlotShield:
		*s = EquipRequestSchemaSlotShield
	case EquipRequestSchemaSlotHelmet:
		*s = EquipRequestSchemaSlotHelmet
	case EquipRequestSchemaSlotBodyArmor:
		*s = EquipRequestSchemaSlotBodyArmor
	case EquipRequestSchemaSlotLegArmor:
		*s = EquipRequestSchemaSlotLegArmor
	case EquipRequestSchemaSlotBoots:
		*s = EquipRequestSchemaSlotBoots
	case EquipRequestSchemaSlotRing1:
		*s = EquipRequestSchemaSlotRing1
	case EquipRequestSchemaSlotRing2:
		*s = EquipRequestSchemaSlotRing2
	case EquipRequestSchemaSlotAmulet:
		*s = EquipRequestSchemaSlotAmulet
	case EquipRequestSchemaSlotArtifact1:
		*s = EquipRequestSchemaSlotArtifact1
	case EquipRequestSchemaSlotArtifact2:
		*s = EquipRequestSchemaSlotArtifact2
	case EquipRequestSchemaSlotArtifact3:
		*s = EquipRequestSchemaSlotArtifact3
	case EquipRequestSchemaSlotConsumable1:
		*s = EquipRequestSchemaSlotConsumable1
	case EquipRequestSchemaSlotConsumable2:
		*s = EquipRequestSchemaSlotConsumable2
	default:
		*s = EquipRequestSchemaSlot(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EquipRequestSchemaSlot) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaSlot) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EquipSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EquipSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("slot")
		s.Slot.Encode(e)
	}
}

var jsonFieldsNameOfEquipSchema = [2]string{
	0: "code",
	1: "slot",
}

// Decode decodes EquipSchema from json.
func (s *EquipSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "slot":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Slot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slot\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EquipSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEquipSchema) {
					name = jsonFieldsNameOfEquipSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EquipSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EquipSchemaSlot as json.
func (s EquipSchemaSlot) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EquipSchemaSlot from json.
func (s *EquipSchemaSlot) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipSchemaSlot to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EquipSchemaSlot(v) {
	case EquipSchemaSlotWeapon:
		*s = EquipSchemaSlotWeapon
	case EquipSchemaSlotShield:
		*s = EquipSchemaSlotShield
	case EquipSchemaSlotHelmet:
		*s = EquipSchemaSlotHelmet
	case EquipSchemaSlotBodyArmor:
		*s = EquipSchemaSlotBodyArmor
	case EquipSchemaSlotLegArmor:
		*s = EquipSchemaSlotLegArmor
	case EquipSchemaSlotBoots:
		*s = EquipSchemaSlotBoots
	case EquipSchemaSlotRing1:
		*s = EquipSchemaSlotRing1
	case EquipSchemaSlotRing2:
		*s = EquipSchemaSlotRing2
	case EquipSchemaSlotAmulet:
		*s = EquipSchemaSlotAmulet
	case EquipSchemaSlotArtifact1:
		*s = EquipSchemaSlotArtifact1
	case EquipSchemaSlotArtifact2:
		*s = EquipSchemaSlotArtifact2
	case EquipSchemaSlotArtifact3:
		*s = EquipSchemaSlotArtifact3
	case EquipSchemaSlotConsumable1:
		*s = EquipSchemaSlotConsumable1
	case EquipSchemaSlotConsumable2:
		*s = EquipSchemaSlotConsumable2
	default:
		*s = EquipSchemaSlot(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EquipSchemaSlot) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipSchemaSlot) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EquipmentResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EquipmentResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfEquipmentResponseSchema = [1]string{
	0: "data",
}

// Decode decodes EquipmentResponseSchema from json.
func (s *EquipmentResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipmentResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EquipmentResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEquipmentResponseSchema) {
					name = jsonFieldsNameOfEquipmentResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EquipmentResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipmentResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("map")
		s.Map.Encode(e)
	}
	{
		e.FieldStart("previous_skin")
		e.Str(s.PreviousSkin)
	}
	{
		e.FieldStart("duration")
		e.Int(s.Duration)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
}

var jsonFieldsNameOfEventSchema = [6]string{
	0: "name",
	1: "map",
	2: "previous_skin",
	3: "duration",
	4: "expiration",
	5: "created_at",
}

// Decode decodes EventSchema from json.
func (s *EventSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "map":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Map.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"map\"")
			}
		case "previous_skin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PreviousSkin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_skin\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Duration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventSchema) {
					name = jsonFieldsNameOfEventSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventSchemaMap) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventSchemaMap) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		e.Str(s.Skin)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
}

var jsonFieldsNameOfEventSchemaMap = [5]string{
	0: "name",
	1: "skin",
	2: "x",
	3: "y",
	4: "content",
}

// Decode decodes EventSchemaMap from json.
func (s *EventSchemaMap) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventSchemaMap to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Skin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "x":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventSchemaMap")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventSchemaMap) {
					name = jsonFieldsNameOfEventSchemaMap[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventSchemaMap) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventSchemaMap) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventSchemaMapContent as json.
func (s EventSchemaMapContent) Encode(e *jx.Encoder) {
	switch s.Type {
	case MapContentSchemaEventSchemaMapContent:
		s.MapContentSchema.Encode(e)
	case NullEventSchemaMapContent:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes EventSchemaMapContent from json.
func (s *EventSchemaMapContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventSchemaMapContent to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullEventSchemaMapContent
	case jx.Object:
		if err := s.MapContentSchema.Decode(d); err != nil {
			return err
		}
		s.Type = MapContentSchemaEventSchemaMapContent
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventSchemaMapContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventSchemaMapContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GEItemResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GEItemResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfGEItemResponseSchema = [1]string{
	0: "data",
}

// Decode decodes GEItemResponseSchema from json.
func (s *GEItemResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GEItemResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GEItemResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGEItemResponseSchema) {
					name = jsonFieldsNameOfGEItemResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GEItemResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GEItemResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GEItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GEItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("stock")
		e.Int(s.Stock)
	}
	{
		if s.SellPrice.Set {
			e.FieldStart("sell_price")
			s.SellPrice.Encode(e)
		}
	}
	{
		if s.BuyPrice.Set {
			e.FieldStart("buy_price")
			s.BuyPrice.Encode(e)
		}
	}
}

var jsonFieldsNameOfGEItemSchema = [4]string{
	0: "code",
	1: "stock",
	2: "sell_price",
	3: "buy_price",
}

// Decode decodes GEItemSchema from json.
func (s *GEItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GEItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "stock":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Stock = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stock\"")
			}
		case "sell_price":
			if err := func() error {
				s.SellPrice.Reset()
				if err := s.SellPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sell_price\"")
			}
		case "buy_price":
			if err := func() error {
				s.BuyPrice.Reset()
				if err := s.BuyPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buy_price\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GEItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGEItemSchema) {
					name = jsonFieldsNameOfGEItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GEItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GEItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GETransactionItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GETransactionItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
	{
		e.FieldStart("price")
		e.Int(s.Price)
	}
}

var jsonFieldsNameOfGETransactionItemSchema = [3]string{
	0: "code",
	1: "quantity",
	2: "price",
}

// Decode decodes GETransactionItemSchema from json.
func (s *GETransactionItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "price":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Price = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GETransactionItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGETransactionItemSchema) {
					name = jsonFieldsNameOfGETransactionItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GETransactionItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GETransactionListSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GETransactionListSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("transaction")
		s.Transaction.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfGETransactionListSchema = [3]string{
	0: "cooldown",
	1: "transaction",
	2: "character",
}

// Decode decodes GETransactionListSchema from json.
func (s *GETransactionListSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionListSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "transaction":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Transaction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transaction\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GETransactionListSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGETransactionListSchema) {
					name = jsonFieldsNameOfGETransactionListSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GETransactionListSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionListSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GETransactionListSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GETransactionListSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("total_xp")
		e.Int(s.TotalXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("inventory_slot1")
		e.Str(s.InventorySlot1)
	}
	{
		e.FieldStart("inventory_slot1_quantity")
		e.Int(s.InventorySlot1Quantity)
	}
	{
		e.FieldStart("inventory_slot2")
		e.Str(s.InventorySlot2)
	}
	{
		e.FieldStart("inventory_slot2_quantity")
		e.Int(s.InventorySlot2Quantity)
	}
	{
		e.FieldStart("inventory_slot3")
		e.Str(s.InventorySlot3)
	}
	{
		e.FieldStart("inventory_slot3_quantity")
		e.Int(s.InventorySlot3Quantity)
	}
	{
		e.FieldStart("inventory_slot4")
		e.Str(s.InventorySlot4)
	}
	{
		e.FieldStart("inventory_slot4_quantity")
		e.Int(s.InventorySlot4Quantity)
	}
	{
		e.FieldStart("inventory_slot5")
		e.Str(s.InventorySlot5)
	}
	{
		e.FieldStart("inventory_slot5_quantity")
		e.Int(s.InventorySlot5Quantity)
	}
	{
		e.FieldStart("inventory_slot6")
		e.Str(s.InventorySlot6)
	}
	{
		e.FieldStart("inventory_slot6_quantity")
		e.Int(s.InventorySlot6Quantity)
	}
	{
		e.FieldStart("inventory_slot7")
		e.Str(s.InventorySlot7)
	}
	{
		e.FieldStart("inventory_slot7_quantity")
		e.Int(s.InventorySlot7Quantity)
	}
	{
		e.FieldStart("inventory_slot8")
		e.Str(s.InventorySlot8)
	}
	{
		e.FieldStart("inventory_slot8_quantity")
		e.Int(s.InventorySlot8Quantity)
	}
	{
		e.FieldStart("inventory_slot9")
		e.Str(s.InventorySlot9)
	}
	{
		e.FieldStart("inventory_slot9_quantity")
		e.Int(s.InventorySlot9Quantity)
	}
	{
		e.FieldStart("inventory_slot10")
		e.Str(s.InventorySlot10)
	}
	{
		e.FieldStart("inventory_slot10_quantity")
		e.Int(s.InventorySlot10Quantity)
	}
	{
		e.FieldStart("inventory_slot11")
		e.Str(s.InventorySlot11)
	}
	{
		e.FieldStart("inventory_slot11_quantity")
		e.Int(s.InventorySlot11Quantity)
	}
	{
		e.FieldStart("inventory_slot12")
		e.Str(s.InventorySlot12)
	}
	{
		e.FieldStart("inventory_slot12_quantity")
		e.Int(s.InventorySlot12Quantity)
	}
	{
		e.FieldStart("inventory_slot13")
		e.Str(s.InventorySlot13)
	}
	{
		e.FieldStart("inventory_slot13_quantity")
		e.Int(s.InventorySlot13Quantity)
	}
	{
		e.FieldStart("inventory_slot14")
		e.Str(s.InventorySlot14)
	}
	{
		e.FieldStart("inventory_slot14_quantity")
		e.Int(s.InventorySlot14Quantity)
	}
	{
		e.FieldStart("inventory_slot15")
		e.Str(s.InventorySlot15)
	}
	{
		e.FieldStart("inventory_slot15_quantity")
		e.Int(s.InventorySlot15Quantity)
	}
	{
		e.FieldStart("inventory_slot16")
		e.Str(s.InventorySlot16)
	}
	{
		e.FieldStart("inventory_slot16_quantity")
		e.Int(s.InventorySlot16Quantity)
	}
	{
		e.FieldStart("inventory_slot17")
		e.Str(s.InventorySlot17)
	}
	{
		e.FieldStart("inventory_slot17_quantity")
		e.Int(s.InventorySlot17Quantity)
	}
	{
		e.FieldStart("inventory_slot18")
		e.Str(s.InventorySlot18)
	}
	{
		e.FieldStart("inventory_slot18_quantity")
		e.Int(s.InventorySlot18Quantity)
	}
	{
		e.FieldStart("inventory_slot19")
		e.Str(s.InventorySlot19)
	}
	{
		e.FieldStart("inventory_slot19_quantity")
		e.Int(s.InventorySlot19Quantity)
	}
	{
		e.FieldStart("inventory_slot20")
		e.Str(s.InventorySlot20)
	}
	{
		e.FieldStart("inventory_slot20_quantity")
		e.Int(s.InventorySlot20Quantity)
	}
}

var jsonFieldsNameOfGETransactionListSchemaCharacter = [111]string{
	0:   "name",
	1:   "skin",
	2:   "level",
	3:   "xp",
	4:   "max_xp",
	5:   "total_xp",
	6:   "gold",
	7:   "speed",
	8:   "mining_level",
	9:   "mining_xp",
	10:  "mining_max_xp",
	11:  "woodcutting_level",
	12:  "woodcutting_xp",
	13:  "woodcutting_max_xp",
	14:  "fishing_level",
	15:  "fishing_xp",
	16:  "fishing_max_xp",
	17:  "weaponcrafting_level",
	18:  "weaponcrafting_xp",
	19:  "weaponcrafting_max_xp",
	20:  "gearcrafting_level",
	21:  "gearcrafting_xp",
	22:  "gearcrafting_max_xp",
	23:  "jewelrycrafting_level",
	24:  "jewelrycrafting_xp",
	25:  "jewelrycrafting_max_xp",
	26:  "cooking_level",
	27:  "cooking_xp",
	28:  "cooking_max_xp",
	29:  "hp",
	30:  "haste",
	31:  "critical_strike",
	32:  "stamina",
	33:  "attack_fire",
	34:  "attack_earth",
	35:  "attack_water",
	36:  "attack_air",
	37:  "dmg_fire",
	38:  "dmg_earth",
	39:  "dmg_water",
	40:  "dmg_air",
	41:  "res_fire",
	42:  "res_earth",
	43:  "res_water",
	44:  "res_air",
	45:  "x",
	46:  "y",
	47:  "cooldown",
	48:  "cooldown_expiration",
	49:  "weapon_slot",
	50:  "shield_slot",
	51:  "helmet_slot",
	52:  "body_armor_slot",
	53:  "leg_armor_slot",
	54:  "boots_slot",
	55:  "ring1_slot",
	56:  "ring2_slot",
	57:  "amulet_slot",
	58:  "artifact1_slot",
	59:  "artifact2_slot",
	60:  "artifact3_slot",
	61:  "consumable1_slot",
	62:  "consumable1_slot_quantity",
	63:  "consumable2_slot",
	64:  "consumable2_slot_quantity",
	65:  "task",
	66:  "task_type",
	67:  "task_progress",
	68:  "task_total",
	69:  "inventory_max_items",
	70:  "inventory",
	71:  "inventory_slot1",
	72:  "inventory_slot1_quantity",
	73:  "inventory_slot2",
	74:  "inventory_slot2_quantity",
	75:  "inventory_slot3",
	76:  "inventory_slot3_quantity",
	77:  "inventory_slot4",
	78:  "inventory_slot4_quantity",
	79:  "inventory_slot5",
	80:  "inventory_slot5_quantity",
	81:  "inventory_slot6",
	82:  "inventory_slot6_quantity",
	83:  "inventory_slot7",
	84:  "inventory_slot7_quantity",
	85:  "inventory_slot8",
	86:  "inventory_slot8_quantity",
	87:  "inventory_slot9",
	88:  "inventory_slot9_quantity",
	89:  "inventory_slot10",
	90:  "inventory_slot10_quantity",
	91:  "inventory_slot11",
	92:  "inventory_slot11_quantity",
	93:  "inventory_slot12",
	94:  "inventory_slot12_quantity",
	95:  "inventory_slot13",
	96:  "inventory_slot13_quantity",
	97:  "inventory_slot14",
	98:  "inventory_slot14_quantity",
	99:  "inventory_slot15",
	100: "inventory_slot15_quantity",
	101: "inventory_slot16",
	102: "inventory_slot16_quantity",
	103: "inventory_slot17",
	104: "inventory_slot17_quantity",
	105: "inventory_slot18",
	106: "inventory_slot18_quantity",
	107: "inventory_slot19",
	108: "inventory_slot19_quantity",
	109: "inventory_slot20",
	110: "inventory_slot20_quantity",
}

// Decode decodes GETransactionListSchemaCharacter from json.
func (s *GETransactionListSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionListSchemaCharacter to nil")
	}
	var requiredBitSet [14]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "total_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.TotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		case "inventory_slot1":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot1 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1\"")
			}
		case "inventory_slot1_quantity":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot1Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1_quantity\"")
			}
		case "inventory_slot2":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot2 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2\"")
			}
		case "inventory_slot2_quantity":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot2Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2_quantity\"")
			}
		case "inventory_slot3":
			requiredBitSet[9] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot3 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3\"")
			}
		case "inventory_slot3_quantity":
			requiredBitSet[9] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot3Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3_quantity\"")
			}
		case "inventory_slot4":
			requiredBitSet[9] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot4 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4\"")
			}
		case "inventory_slot4_quantity":
			requiredBitSet[9] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot4Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4_quantity\"")
			}
		case "inventory_slot5":
			requiredBitSet[9] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot5 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5\"")
			}
		case "inventory_slot5_quantity":
			requiredBitSet[10] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot5Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5_quantity\"")
			}
		case "inventory_slot6":
			requiredBitSet[10] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot6 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6\"")
			}
		case "inventory_slot6_quantity":
			requiredBitSet[10] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot6Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6_quantity\"")
			}
		case "inventory_slot7":
			requiredBitSet[10] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot7 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7\"")
			}
		case "inventory_slot7_quantity":
			requiredBitSet[10] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot7Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7_quantity\"")
			}
		case "inventory_slot8":
			requiredBitSet[10] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot8 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8\"")
			}
		case "inventory_slot8_quantity":
			requiredBitSet[10] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot8Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8_quantity\"")
			}
		case "inventory_slot9":
			requiredBitSet[10] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot9 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9\"")
			}
		case "inventory_slot9_quantity":
			requiredBitSet[11] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot9Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9_quantity\"")
			}
		case "inventory_slot10":
			requiredBitSet[11] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot10 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10\"")
			}
		case "inventory_slot10_quantity":
			requiredBitSet[11] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot10Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10_quantity\"")
			}
		case "inventory_slot11":
			requiredBitSet[11] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot11 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11\"")
			}
		case "inventory_slot11_quantity":
			requiredBitSet[11] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot11Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11_quantity\"")
			}
		case "inventory_slot12":
			requiredBitSet[11] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot12 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12\"")
			}
		case "inventory_slot12_quantity":
			requiredBitSet[11] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot12Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12_quantity\"")
			}
		case "inventory_slot13":
			requiredBitSet[11] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot13 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13\"")
			}
		case "inventory_slot13_quantity":
			requiredBitSet[12] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot13Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13_quantity\"")
			}
		case "inventory_slot14":
			requiredBitSet[12] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot14 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14\"")
			}
		case "inventory_slot14_quantity":
			requiredBitSet[12] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot14Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14_quantity\"")
			}
		case "inventory_slot15":
			requiredBitSet[12] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot15 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15\"")
			}
		case "inventory_slot15_quantity":
			requiredBitSet[12] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot15Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15_quantity\"")
			}
		case "inventory_slot16":
			requiredBitSet[12] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot16 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16\"")
			}
		case "inventory_slot16_quantity":
			requiredBitSet[12] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot16Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16_quantity\"")
			}
		case "inventory_slot17":
			requiredBitSet[12] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot17 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17\"")
			}
		case "inventory_slot17_quantity":
			requiredBitSet[13] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot17Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17_quantity\"")
			}
		case "inventory_slot18":
			requiredBitSet[13] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot18 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18\"")
			}
		case "inventory_slot18_quantity":
			requiredBitSet[13] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot18Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18_quantity\"")
			}
		case "inventory_slot19":
			requiredBitSet[13] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot19 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19\"")
			}
		case "inventory_slot19_quantity":
			requiredBitSet[13] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot19Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19_quantity\"")
			}
		case "inventory_slot20":
			requiredBitSet[13] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot20 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20\"")
			}
		case "inventory_slot20_quantity":
			requiredBitSet[13] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot20Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20_quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GETransactionListSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [14]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b10111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGETransactionListSchemaCharacter) {
					name = jsonFieldsNameOfGETransactionListSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GETransactionListSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionListSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GETransactionListSchemaCharacterCooldownExpiration as json.
func (s GETransactionListSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	switch s.Type {
	case DateTimeGETransactionListSchemaCharacterCooldownExpiration:
		json.EncodeDateTime(e, s.DateTime)
	case NullGETransactionListSchemaCharacterCooldownExpiration:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes GETransactionListSchemaCharacterCooldownExpiration from json.
func (s *GETransactionListSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionListSchemaCharacterCooldownExpiration to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullGETransactionListSchemaCharacterCooldownExpiration
	case jx.String:
		v, err := json.DecodeDateTime(d)
		s.DateTime = v
		if err != nil {
			return err
		}
		s.Type = DateTimeGETransactionListSchemaCharacterCooldownExpiration
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GETransactionListSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionListSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GETransactionListSchemaCharacterSkin as json.
func (s GETransactionListSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GETransactionListSchemaCharacterSkin from json.
func (s *GETransactionListSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionListSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GETransactionListSchemaCharacterSkin(v) {
	case GETransactionListSchemaCharacterSkinMen1:
		*s = GETransactionListSchemaCharacterSkinMen1
	case GETransactionListSchemaCharacterSkinMen2:
		*s = GETransactionListSchemaCharacterSkinMen2
	case GETransactionListSchemaCharacterSkinMen3:
		*s = GETransactionListSchemaCharacterSkinMen3
	case GETransactionListSchemaCharacterSkinWomen1:
		*s = GETransactionListSchemaCharacterSkinWomen1
	case GETransactionListSchemaCharacterSkinWomen2:
		*s = GETransactionListSchemaCharacterSkinWomen2
	case GETransactionListSchemaCharacterSkinWomen3:
		*s = GETransactionListSchemaCharacterSkinWomen3
	default:
		*s = GETransactionListSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GETransactionListSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionListSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GETransactionListSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GETransactionListSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfGETransactionListSchemaCooldown = [4]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "expiration",
	3: "reason",
}

// Decode decodes GETransactionListSchemaCooldown from json.
func (s *GETransactionListSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionListSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GETransactionListSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGETransactionListSchemaCooldown) {
					name = jsonFieldsNameOfGETransactionListSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GETransactionListSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionListSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GETransactionListSchemaCooldownReason as json.
func (s GETransactionListSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GETransactionListSchemaCooldownReason from json.
func (s *GETransactionListSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionListSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GETransactionListSchemaCooldownReason(v) {
	case GETransactionListSchemaCooldownReasonMovement:
		*s = GETransactionListSchemaCooldownReasonMovement
	case GETransactionListSchemaCooldownReasonFight:
		*s = GETransactionListSchemaCooldownReasonFight
	case GETransactionListSchemaCooldownReasonCrafting:
		*s = GETransactionListSchemaCooldownReasonCrafting
	case GETransactionListSchemaCooldownReasonGathering:
		*s = GETransactionListSchemaCooldownReasonGathering
	case GETransactionListSchemaCooldownReasonBuyGe:
		*s = GETransactionListSchemaCooldownReasonBuyGe
	case GETransactionListSchemaCooldownReasonSellGe:
		*s = GETransactionListSchemaCooldownReasonSellGe
	case GETransactionListSchemaCooldownReasonDeleteItem:
		*s = GETransactionListSchemaCooldownReasonDeleteItem
	case GETransactionListSchemaCooldownReasonDepositBank:
		*s = GETransactionListSchemaCooldownReasonDepositBank
	case GETransactionListSchemaCooldownReasonWithdrawBank:
		*s = GETransactionListSchemaCooldownReasonWithdrawBank
	case GETransactionListSchemaCooldownReasonEquip:
		*s = GETransactionListSchemaCooldownReasonEquip
	case GETransactionListSchemaCooldownReasonUnequip:
		*s = GETransactionListSchemaCooldownReasonUnequip
	case GETransactionListSchemaCooldownReasonTask:
		*s = GETransactionListSchemaCooldownReasonTask
	case GETransactionListSchemaCooldownReasonRecycling:
		*s = GETransactionListSchemaCooldownReasonRecycling
	default:
		*s = GETransactionListSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GETransactionListSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionListSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GETransactionListSchemaTransaction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GETransactionListSchemaTransaction) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
	{
		e.FieldStart("price")
		e.Int(s.Price)
	}
	{
		e.FieldStart("total_price")
		e.Int(s.TotalPrice)
	}
}

var jsonFieldsNameOfGETransactionListSchemaTransaction = [4]string{
	0: "code",
	1: "quantity",
	2: "price",
	3: "total_price",
}

// Decode decodes GETransactionListSchemaTransaction from json.
func (s *GETransactionListSchemaTransaction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionListSchemaTransaction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "price":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Price = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "total_price":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TotalPrice = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_price\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GETransactionListSchemaTransaction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGETransactionListSchemaTransaction) {
					name = jsonFieldsNameOfGETransactionListSchemaTransaction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GETransactionListSchemaTransaction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionListSchemaTransaction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GETransactionResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GETransactionResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfGETransactionResponseSchema = [1]string{
	0: "data",
}

// Decode decodes GETransactionResponseSchema from json.
func (s *GETransactionResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GETransactionResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGETransactionResponseSchema) {
					name = jsonFieldsNameOfGETransactionResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GETransactionResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GoldBankResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GoldBankResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfGoldBankResponseSchema = [1]string{
	0: "data",
}

// Decode decodes GoldBankResponseSchema from json.
func (s *GoldBankResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GoldBankResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GoldBankResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGoldBankResponseSchema) {
					name = jsonFieldsNameOfGoldBankResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GoldBankResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GoldBankResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GoldResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GoldResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfGoldResponseSchema = [1]string{
	0: "data",
}

// Decode decodes GoldResponseSchema from json.
func (s *GoldResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GoldResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GoldResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGoldResponseSchema) {
					name = jsonFieldsNameOfGoldResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GoldResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GoldResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GoldSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GoldSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfGoldSchema = [1]string{
	0: "quantity",
}

// Decode decodes GoldSchema from json.
func (s *GoldSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GoldSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "quantity":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GoldSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGoldSchema) {
					name = jsonFieldsNameOfGoldSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GoldSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GoldSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GoldTransactionSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GoldTransactionSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("bank")
		s.Bank.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfGoldTransactionSchema = [3]string{
	0: "cooldown",
	1: "bank",
	2: "character",
}

// Decode decodes GoldTransactionSchema from json.
func (s *GoldTransactionSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GoldTransactionSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "bank":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Bank.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bank\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GoldTransactionSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGoldTransactionSchema) {
					name = jsonFieldsNameOfGoldTransactionSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GoldTransactionSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GoldTransactionSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GoldTransactionSchemaBank) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GoldTransactionSchemaBank) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfGoldTransactionSchemaBank = [1]string{
	0: "quantity",
}

// Decode decodes GoldTransactionSchemaBank from json.
func (s *GoldTransactionSchemaBank) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GoldTransactionSchemaBank to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "quantity":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GoldTransactionSchemaBank")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGoldTransactionSchemaBank) {
					name = jsonFieldsNameOfGoldTransactionSchemaBank[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GoldTransactionSchemaBank) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GoldTransactionSchemaBank) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GoldTransactionSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GoldTransactionSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("total_xp")
		e.Int(s.TotalXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("inventory_slot1")
		e.Str(s.InventorySlot1)
	}
	{
		e.FieldStart("inventory_slot1_quantity")
		e.Int(s.InventorySlot1Quantity)
	}
	{
		e.FieldStart("inventory_slot2")
		e.Str(s.InventorySlot2)
	}
	{
		e.FieldStart("inventory_slot2_quantity")
		e.Int(s.InventorySlot2Quantity)
	}
	{
		e.FieldStart("inventory_slot3")
		e.Str(s.InventorySlot3)
	}
	{
		e.FieldStart("inventory_slot3_quantity")
		e.Int(s.InventorySlot3Quantity)
	}
	{
		e.FieldStart("inventory_slot4")
		e.Str(s.InventorySlot4)
	}
	{
		e.FieldStart("inventory_slot4_quantity")
		e.Int(s.InventorySlot4Quantity)
	}
	{
		e.FieldStart("inventory_slot5")
		e.Str(s.InventorySlot5)
	}
	{
		e.FieldStart("inventory_slot5_quantity")
		e.Int(s.InventorySlot5Quantity)
	}
	{
		e.FieldStart("inventory_slot6")
		e.Str(s.InventorySlot6)
	}
	{
		e.FieldStart("inventory_slot6_quantity")
		e.Int(s.InventorySlot6Quantity)
	}
	{
		e.FieldStart("inventory_slot7")
		e.Str(s.InventorySlot7)
	}
	{
		e.FieldStart("inventory_slot7_quantity")
		e.Int(s.InventorySlot7Quantity)
	}
	{
		e.FieldStart("inventory_slot8")
		e.Str(s.InventorySlot8)
	}
	{
		e.FieldStart("inventory_slot8_quantity")
		e.Int(s.InventorySlot8Quantity)
	}
	{
		e.FieldStart("inventory_slot9")
		e.Str(s.InventorySlot9)
	}
	{
		e.FieldStart("inventory_slot9_quantity")
		e.Int(s.InventorySlot9Quantity)
	}
	{
		e.FieldStart("inventory_slot10")
		e.Str(s.InventorySlot10)
	}
	{
		e.FieldStart("inventory_slot10_quantity")
		e.Int(s.InventorySlot10Quantity)
	}
	{
		e.FieldStart("inventory_slot11")
		e.Str(s.InventorySlot11)
	}
	{
		e.FieldStart("inventory_slot11_quantity")
		e.Int(s.InventorySlot11Quantity)
	}
	{
		e.FieldStart("inventory_slot12")
		e.Str(s.InventorySlot12)
	}
	{
		e.FieldStart("inventory_slot12_quantity")
		e.Int(s.InventorySlot12Quantity)
	}
	{
		e.FieldStart("inventory_slot13")
		e.Str(s.InventorySlot13)
	}
	{
		e.FieldStart("inventory_slot13_quantity")
		e.Int(s.InventorySlot13Quantity)
	}
	{
		e.FieldStart("inventory_slot14")
		e.Str(s.InventorySlot14)
	}
	{
		e.FieldStart("inventory_slot14_quantity")
		e.Int(s.InventorySlot14Quantity)
	}
	{
		e.FieldStart("inventory_slot15")
		e.Str(s.InventorySlot15)
	}
	{
		e.FieldStart("inventory_slot15_quantity")
		e.Int(s.InventorySlot15Quantity)
	}
	{
		e.FieldStart("inventory_slot16")
		e.Str(s.InventorySlot16)
	}
	{
		e.FieldStart("inventory_slot16_quantity")
		e.Int(s.InventorySlot16Quantity)
	}
	{
		e.FieldStart("inventory_slot17")
		e.Str(s.InventorySlot17)
	}
	{
		e.FieldStart("inventory_slot17_quantity")
		e.Int(s.InventorySlot17Quantity)
	}
	{
		e.FieldStart("inventory_slot18")
		e.Str(s.InventorySlot18)
	}
	{
		e.FieldStart("inventory_slot18_quantity")
		e.Int(s.InventorySlot18Quantity)
	}
	{
		e.FieldStart("inventory_slot19")
		e.Str(s.InventorySlot19)
	}
	{
		e.FieldStart("inventory_slot19_quantity")
		e.Int(s.InventorySlot19Quantity)
	}
	{
		e.FieldStart("inventory_slot20")
		e.Str(s.InventorySlot20)
	}
	{
		e.FieldStart("inventory_slot20_quantity")
		e.Int(s.InventorySlot20Quantity)
	}
}

var jsonFieldsNameOfGoldTransactionSchemaCharacter = [111]string{
	0:   "name",
	1:   "skin",
	2:   "level",
	3:   "xp",
	4:   "max_xp",
	5:   "total_xp",
	6:   "gold",
	7:   "speed",
	8:   "mining_level",
	9:   "mining_xp",
	10:  "mining_max_xp",
	11:  "woodcutting_level",
	12:  "woodcutting_xp",
	13:  "woodcutting_max_xp",
	14:  "fishing_level",
	15:  "fishing_xp",
	16:  "fishing_max_xp",
	17:  "weaponcrafting_level",
	18:  "weaponcrafting_xp",
	19:  "weaponcrafting_max_xp",
	20:  "gearcrafting_level",
	21:  "gearcrafting_xp",
	22:  "gearcrafting_max_xp",
	23:  "jewelrycrafting_level",
	24:  "jewelrycrafting_xp",
	25:  "jewelrycrafting_max_xp",
	26:  "cooking_level",
	27:  "cooking_xp",
	28:  "cooking_max_xp",
	29:  "hp",
	30:  "haste",
	31:  "critical_strike",
	32:  "stamina",
	33:  "attack_fire",
	34:  "attack_earth",
	35:  "attack_water",
	36:  "attack_air",
	37:  "dmg_fire",
	38:  "dmg_earth",
	39:  "dmg_water",
	40:  "dmg_air",
	41:  "res_fire",
	42:  "res_earth",
	43:  "res_water",
	44:  "res_air",
	45:  "x",
	46:  "y",
	47:  "cooldown",
	48:  "cooldown_expiration",
	49:  "weapon_slot",
	50:  "shield_slot",
	51:  "helmet_slot",
	52:  "body_armor_slot",
	53:  "leg_armor_slot",
	54:  "boots_slot",
	55:  "ring1_slot",
	56:  "ring2_slot",
	57:  "amulet_slot",
	58:  "artifact1_slot",
	59:  "artifact2_slot",
	60:  "artifact3_slot",
	61:  "consumable1_slot",
	62:  "consumable1_slot_quantity",
	63:  "consumable2_slot",
	64:  "consumable2_slot_quantity",
	65:  "task",
	66:  "task_type",
	67:  "task_progress",
	68:  "task_total",
	69:  "inventory_max_items",
	70:  "inventory",
	71:  "inventory_slot1",
	72:  "inventory_slot1_quantity",
	73:  "inventory_slot2",
	74:  "inventory_slot2_quantity",
	75:  "inventory_slot3",
	76:  "inventory_slot3_quantity",
	77:  "inventory_slot4",
	78:  "inventory_slot4_quantity",
	79:  "inventory_slot5",
	80:  "inventory_slot5_quantity",
	81:  "inventory_slot6",
	82:  "inventory_slot6_quantity",
	83:  "inventory_slot7",
	84:  "inventory_slot7_quantity",
	85:  "inventory_slot8",
	86:  "inventory_slot8_quantity",
	87:  "inventory_slot9",
	88:  "inventory_slot9_quantity",
	89:  "inventory_slot10",
	90:  "inventory_slot10_quantity",
	91:  "inventory_slot11",
	92:  "inventory_slot11_quantity",
	93:  "inventory_slot12",
	94:  "inventory_slot12_quantity",
	95:  "inventory_slot13",
	96:  "inventory_slot13_quantity",
	97:  "inventory_slot14",
	98:  "inventory_slot14_quantity",
	99:  "inventory_slot15",
	100: "inventory_slot15_quantity",
	101: "inventory_slot16",
	102: "inventory_slot16_quantity",
	103: "inventory_slot17",
	104: "inventory_slot17_quantity",
	105: "inventory_slot18",
	106: "inventory_slot18_quantity",
	107: "inventory_slot19",
	108: "inventory_slot19_quantity",
	109: "inventory_slot20",
	110: "inventory_slot20_quantity",
}

// Decode decodes GoldTransactionSchemaCharacter from json.
func (s *GoldTransactionSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GoldTransactionSchemaCharacter to nil")
	}
	var requiredBitSet [14]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "total_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.TotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		case "inventory_slot1":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot1 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1\"")
			}
		case "inventory_slot1_quantity":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot1Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1_quantity\"")
			}
		case "inventory_slot2":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot2 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2\"")
			}
		case "inventory_slot2_quantity":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot2Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2_quantity\"")
			}
		case "inventory_slot3":
			requiredBitSet[9] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot3 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3\"")
			}
		case "inventory_slot3_quantity":
			requiredBitSet[9] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot3Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3_quantity\"")
			}
		case "inventory_slot4":
			requiredBitSet[9] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot4 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4\"")
			}
		case "inventory_slot4_quantity":
			requiredBitSet[9] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot4Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4_quantity\"")
			}
		case "inventory_slot5":
			requiredBitSet[9] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot5 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5\"")
			}
		case "inventory_slot5_quantity":
			requiredBitSet[10] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot5Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5_quantity\"")
			}
		case "inventory_slot6":
			requiredBitSet[10] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot6 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6\"")
			}
		case "inventory_slot6_quantity":
			requiredBitSet[10] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot6Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6_quantity\"")
			}
		case "inventory_slot7":
			requiredBitSet[10] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot7 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7\"")
			}
		case "inventory_slot7_quantity":
			requiredBitSet[10] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot7Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7_quantity\"")
			}
		case "inventory_slot8":
			requiredBitSet[10] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot8 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8\"")
			}
		case "inventory_slot8_quantity":
			requiredBitSet[10] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot8Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8_quantity\"")
			}
		case "inventory_slot9":
			requiredBitSet[10] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot9 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9\"")
			}
		case "inventory_slot9_quantity":
			requiredBitSet[11] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot9Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9_quantity\"")
			}
		case "inventory_slot10":
			requiredBitSet[11] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot10 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10\"")
			}
		case "inventory_slot10_quantity":
			requiredBitSet[11] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot10Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10_quantity\"")
			}
		case "inventory_slot11":
			requiredBitSet[11] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot11 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11\"")
			}
		case "inventory_slot11_quantity":
			requiredBitSet[11] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot11Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11_quantity\"")
			}
		case "inventory_slot12":
			requiredBitSet[11] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot12 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12\"")
			}
		case "inventory_slot12_quantity":
			requiredBitSet[11] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot12Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12_quantity\"")
			}
		case "inventory_slot13":
			requiredBitSet[11] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot13 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13\"")
			}
		case "inventory_slot13_quantity":
			requiredBitSet[12] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot13Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13_quantity\"")
			}
		case "inventory_slot14":
			requiredBitSet[12] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot14 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14\"")
			}
		case "inventory_slot14_quantity":
			requiredBitSet[12] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot14Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14_quantity\"")
			}
		case "inventory_slot15":
			requiredBitSet[12] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot15 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15\"")
			}
		case "inventory_slot15_quantity":
			requiredBitSet[12] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot15Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15_quantity\"")
			}
		case "inventory_slot16":
			requiredBitSet[12] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot16 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16\"")
			}
		case "inventory_slot16_quantity":
			requiredBitSet[12] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot16Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16_quantity\"")
			}
		case "inventory_slot17":
			requiredBitSet[12] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot17 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17\"")
			}
		case "inventory_slot17_quantity":
			requiredBitSet[13] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot17Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17_quantity\"")
			}
		case "inventory_slot18":
			requiredBitSet[13] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot18 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18\"")
			}
		case "inventory_slot18_quantity":
			requiredBitSet[13] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot18Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18_quantity\"")
			}
		case "inventory_slot19":
			requiredBitSet[13] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot19 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19\"")
			}
		case "inventory_slot19_quantity":
			requiredBitSet[13] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot19Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19_quantity\"")
			}
		case "inventory_slot20":
			requiredBitSet[13] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot20 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20\"")
			}
		case "inventory_slot20_quantity":
			requiredBitSet[13] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot20Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20_quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GoldTransactionSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [14]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b10111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGoldTransactionSchemaCharacter) {
					name = jsonFieldsNameOfGoldTransactionSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GoldTransactionSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GoldTransactionSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GoldTransactionSchemaCharacterCooldownExpiration as json.
func (s GoldTransactionSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	switch s.Type {
	case DateTimeGoldTransactionSchemaCharacterCooldownExpiration:
		json.EncodeDateTime(e, s.DateTime)
	case NullGoldTransactionSchemaCharacterCooldownExpiration:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes GoldTransactionSchemaCharacterCooldownExpiration from json.
func (s *GoldTransactionSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GoldTransactionSchemaCharacterCooldownExpiration to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullGoldTransactionSchemaCharacterCooldownExpiration
	case jx.String:
		v, err := json.DecodeDateTime(d)
		s.DateTime = v
		if err != nil {
			return err
		}
		s.Type = DateTimeGoldTransactionSchemaCharacterCooldownExpiration
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GoldTransactionSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GoldTransactionSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GoldTransactionSchemaCharacterSkin as json.
func (s GoldTransactionSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GoldTransactionSchemaCharacterSkin from json.
func (s *GoldTransactionSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GoldTransactionSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GoldTransactionSchemaCharacterSkin(v) {
	case GoldTransactionSchemaCharacterSkinMen1:
		*s = GoldTransactionSchemaCharacterSkinMen1
	case GoldTransactionSchemaCharacterSkinMen2:
		*s = GoldTransactionSchemaCharacterSkinMen2
	case GoldTransactionSchemaCharacterSkinMen3:
		*s = GoldTransactionSchemaCharacterSkinMen3
	case GoldTransactionSchemaCharacterSkinWomen1:
		*s = GoldTransactionSchemaCharacterSkinWomen1
	case GoldTransactionSchemaCharacterSkinWomen2:
		*s = GoldTransactionSchemaCharacterSkinWomen2
	case GoldTransactionSchemaCharacterSkinWomen3:
		*s = GoldTransactionSchemaCharacterSkinWomen3
	default:
		*s = GoldTransactionSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GoldTransactionSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GoldTransactionSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GoldTransactionSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GoldTransactionSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfGoldTransactionSchemaCooldown = [4]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "expiration",
	3: "reason",
}

// Decode decodes GoldTransactionSchemaCooldown from json.
func (s *GoldTransactionSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GoldTransactionSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GoldTransactionSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGoldTransactionSchemaCooldown) {
					name = jsonFieldsNameOfGoldTransactionSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GoldTransactionSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GoldTransactionSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GoldTransactionSchemaCooldownReason as json.
func (s GoldTransactionSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GoldTransactionSchemaCooldownReason from json.
func (s *GoldTransactionSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GoldTransactionSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GoldTransactionSchemaCooldownReason(v) {
	case GoldTransactionSchemaCooldownReasonMovement:
		*s = GoldTransactionSchemaCooldownReasonMovement
	case GoldTransactionSchemaCooldownReasonFight:
		*s = GoldTransactionSchemaCooldownReasonFight
	case GoldTransactionSchemaCooldownReasonCrafting:
		*s = GoldTransactionSchemaCooldownReasonCrafting
	case GoldTransactionSchemaCooldownReasonGathering:
		*s = GoldTransactionSchemaCooldownReasonGathering
	case GoldTransactionSchemaCooldownReasonBuyGe:
		*s = GoldTransactionSchemaCooldownReasonBuyGe
	case GoldTransactionSchemaCooldownReasonSellGe:
		*s = GoldTransactionSchemaCooldownReasonSellGe
	case GoldTransactionSchemaCooldownReasonDeleteItem:
		*s = GoldTransactionSchemaCooldownReasonDeleteItem
	case GoldTransactionSchemaCooldownReasonDepositBank:
		*s = GoldTransactionSchemaCooldownReasonDepositBank
	case GoldTransactionSchemaCooldownReasonWithdrawBank:
		*s = GoldTransactionSchemaCooldownReasonWithdrawBank
	case GoldTransactionSchemaCooldownReasonEquip:
		*s = GoldTransactionSchemaCooldownReasonEquip
	case GoldTransactionSchemaCooldownReasonUnequip:
		*s = GoldTransactionSchemaCooldownReasonUnequip
	case GoldTransactionSchemaCooldownReasonTask:
		*s = GoldTransactionSchemaCooldownReasonTask
	case GoldTransactionSchemaCooldownReasonRecycling:
		*s = GoldTransactionSchemaCooldownReasonRecycling
	default:
		*s = GoldTransactionSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GoldTransactionSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GoldTransactionSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InventorySlot) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InventorySlot) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("slot")
		e.Int(s.Slot)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfInventorySlot = [3]string{
	0: "slot",
	1: "code",
	2: "quantity",
}

// Decode decodes InventorySlot from json.
func (s *InventorySlot) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InventorySlot to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "slot":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Slot = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slot\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InventorySlot")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInventorySlot) {
					name = jsonFieldsNameOfInventorySlot[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InventorySlot) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InventorySlot) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ItemEffectSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ItemEffectSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Int(s.Value)
	}
}

var jsonFieldsNameOfItemEffectSchema = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes ItemEffectSchema from json.
func (s *ItemEffectSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ItemEffectSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Value = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ItemEffectSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfItemEffectSchema) {
					name = jsonFieldsNameOfItemEffectSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ItemEffectSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ItemEffectSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ItemResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ItemResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfItemResponseSchema = [1]string{
	0: "data",
}

// Decode decodes ItemResponseSchema from json.
func (s *ItemResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ItemResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ItemResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfItemResponseSchema) {
					name = jsonFieldsNameOfItemResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ItemResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ItemResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("subtype")
		e.Str(s.Subtype)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Effects != nil {
			e.FieldStart("effects")
			e.ArrStart()
			for _, elem := range s.Effects {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Craft.Set {
			e.FieldStart("craft")
			s.Craft.Encode(e)
		}
	}
}

var jsonFieldsNameOfItemSchema = [8]string{
	0: "name",
	1: "code",
	2: "level",
	3: "type",
	4: "subtype",
	5: "description",
	6: "effects",
	7: "craft",
}

// Decode decodes ItemSchema from json.
func (s *ItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "subtype":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Subtype = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subtype\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "effects":
			if err := func() error {
				s.Effects = make([]ItemEffectSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ItemEffectSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Effects = append(s.Effects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effects\"")
			}
		case "craft":
			if err := func() error {
				s.Craft.Reset()
				if err := s.Craft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"craft\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfItemSchema) {
					name = jsonFieldsNameOfItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ItemSchemaCraft as json.
func (s ItemSchemaCraft) Encode(e *jx.Encoder) {
	switch s.Type {
	case CraftSchemaItemSchemaCraft:
		s.CraftSchema.Encode(e)
	case NullItemSchemaCraft:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes ItemSchemaCraft from json.
func (s *ItemSchemaCraft) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ItemSchemaCraft to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullItemSchemaCraft
	case jx.Object:
		if err := s.CraftSchema.Decode(d); err != nil {
			return err
		}
		s.Type = CraftSchemaItemSchemaCraft
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ItemSchemaCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ItemSchemaCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LogSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LogSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("character")
		e.Str(s.Character)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if len(s.Content) != 0 {
			e.FieldStart("content")
			e.Raw(s.Content)
		}
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		e.FieldStart("cooldown_expiration")
		json.EncodeDateTime(e, s.CooldownExpiration)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
}

var jsonFieldsNameOfLogSchema = [8]string{
	0: "character",
	1: "account",
	2: "type",
	3: "description",
	4: "content",
	5: "cooldown",
	6: "cooldown_expiration",
	7: "created_at",
}

// Decode decodes LogSchema from json.
func (s *LogSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LogSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "character":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Character = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Content = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "cooldown":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CooldownExpiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LogSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLogSchema) {
					name = jsonFieldsNameOfLogSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LogSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LogSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MapContentSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MapContentSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
}

var jsonFieldsNameOfMapContentSchema = [2]string{
	0: "type",
	1: "code",
}

// Decode decodes MapContentSchema from json.
func (s *MapContentSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MapContentSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MapContentSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMapContentSchema) {
					name = jsonFieldsNameOfMapContentSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MapContentSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MapContentSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MapResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MapResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfMapResponseSchema = [1]string{
	0: "data",
}

// Decode decodes MapResponseSchema from json.
func (s *MapResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MapResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MapResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMapResponseSchema) {
					name = jsonFieldsNameOfMapResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MapResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MapResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MapSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MapSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		e.Str(s.Skin)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
}

var jsonFieldsNameOfMapSchema = [5]string{
	0: "name",
	1: "skin",
	2: "x",
	3: "y",
	4: "content",
}

// Decode decodes MapSchema from json.
func (s *MapSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MapSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Skin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "x":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MapSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMapSchema) {
					name = jsonFieldsNameOfMapSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MapSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MapSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MapSchemaContent as json.
func (s MapSchemaContent) Encode(e *jx.Encoder) {
	switch s.Type {
	case MapContentSchemaMapSchemaContent:
		s.MapContentSchema.Encode(e)
	case NullMapSchemaContent:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes MapSchemaContent from json.
func (s *MapSchemaContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MapSchemaContent to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullMapSchemaContent
	case jx.Object:
		if err := s.MapContentSchema.Decode(d); err != nil {
			return err
		}
		s.Type = MapContentSchemaMapSchemaContent
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MapSchemaContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MapSchemaContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MonsterResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MonsterResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfMonsterResponseSchema = [1]string{
	0: "data",
}

// Decode decodes MonsterResponseSchema from json.
func (s *MonsterResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MonsterResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MonsterResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMonsterResponseSchema) {
					name = jsonFieldsNameOfMonsterResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MonsterResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MonsterResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MonsterSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MonsterSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("min_gold")
		e.Int(s.MinGold)
	}
	{
		e.FieldStart("max_gold")
		e.Int(s.MaxGold)
	}
	{
		e.FieldStart("drops")
		e.ArrStart()
		for _, elem := range s.Drops {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfMonsterSchema = [15]string{
	0:  "name",
	1:  "code",
	2:  "level",
	3:  "hp",
	4:  "attack_fire",
	5:  "attack_earth",
	6:  "attack_water",
	7:  "attack_air",
	8:  "res_fire",
	9:  "res_earth",
	10: "res_water",
	11: "res_air",
	12: "min_gold",
	13: "max_gold",
	14: "drops",
}

// Decode decodes MonsterSchema from json.
func (s *MonsterSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MonsterSchema to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "hp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "attack_fire":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "res_fire":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "min_gold":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MinGold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_gold\"")
			}
		case "max_gold":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxGold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_gold\"")
			}
		case "drops":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				s.Drops = make([]DropRateSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DropRateSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Drops = append(s.Drops, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drops\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MonsterSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMonsterSchema) {
					name = jsonFieldsNameOfMonsterSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MonsterSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MonsterSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MyCharactersListSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MyCharactersListSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfMyCharactersListSchema = [1]string{
	0: "data",
}

// Decode decodes MyCharactersListSchema from json.
func (s *MyCharactersListSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MyCharactersListSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]CharacterSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CharacterSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MyCharactersListSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMyCharactersListSchema) {
					name = jsonFieldsNameOfMyCharactersListSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MyCharactersListSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MyCharactersListSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankItemSchemaCharacterCooldownExpiration as json.
func (o OptBankItemSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BankItemSchemaCharacterCooldownExpiration from json.
func (o *OptBankItemSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBankItemSchemaCharacterCooldownExpiration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBankItemSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBankItemSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankItemSchemaItemCraft as json.
func (o OptBankItemSchemaItemCraft) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BankItemSchemaItemCraft from json.
func (o *OptBankItemSchemaItemCraft) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBankItemSchemaItemCraft to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBankItemSchemaItemCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBankItemSchemaItemCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterFightDataSchemaCharacterCooldownExpiration as json.
func (o OptCharacterFightDataSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CharacterFightDataSchemaCharacterCooldownExpiration from json.
func (o *OptCharacterFightDataSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCharacterFightDataSchemaCharacterCooldownExpiration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCharacterFightDataSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCharacterFightDataSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterMovementDataSchemaCharacterCooldownExpiration as json.
func (o OptCharacterMovementDataSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CharacterMovementDataSchemaCharacterCooldownExpiration from json.
func (o *OptCharacterMovementDataSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCharacterMovementDataSchemaCharacterCooldownExpiration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCharacterMovementDataSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCharacterMovementDataSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterSchemaCooldownExpiration as json.
func (o OptCharacterSchemaCooldownExpiration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CharacterSchemaCooldownExpiration from json.
func (o *OptCharacterSchemaCooldownExpiration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCharacterSchemaCooldownExpiration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCharacterSchemaCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCharacterSchemaCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CraftSchemaLevel as json.
func (o OptCraftSchemaLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CraftSchemaLevel from json.
func (o *OptCraftSchemaLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCraftSchemaLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCraftSchemaLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCraftSchemaLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CraftSchemaQuantity as json.
func (o OptCraftSchemaQuantity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CraftSchemaQuantity from json.
func (o *OptCraftSchemaQuantity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCraftSchemaQuantity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCraftSchemaQuantity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCraftSchemaQuantity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CraftSchemaSkill as json.
func (o OptCraftSchemaSkill) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CraftSchemaSkill from json.
func (o *OptCraftSchemaSkill) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCraftSchemaSkill to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCraftSchemaSkill) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCraftSchemaSkill) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageCharacterSchemaPages as json.
func (o OptDataPageCharacterSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageCharacterSchemaPages from json.
func (o *OptDataPageCharacterSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageCharacterSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageCharacterSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageCharacterSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageEventSchemaPages as json.
func (o OptDataPageEventSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageEventSchemaPages from json.
func (o *OptDataPageEventSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageEventSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageEventSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageEventSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageGEItemSchemaPages as json.
func (o OptDataPageGEItemSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageGEItemSchemaPages from json.
func (o *OptDataPageGEItemSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageGEItemSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageGEItemSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageGEItemSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageItemSchemaPages as json.
func (o OptDataPageItemSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageItemSchemaPages from json.
func (o *OptDataPageItemSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageItemSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageItemSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageItemSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageLogSchemaPages as json.
func (o OptDataPageLogSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageLogSchemaPages from json.
func (o *OptDataPageLogSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageLogSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageLogSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageLogSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMapSchemaPages as json.
func (o OptDataPageMapSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageMapSchemaPages from json.
func (o *OptDataPageMapSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageMapSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageMapSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageMapSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMonsterSchemaPages as json.
func (o OptDataPageMonsterSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageMonsterSchemaPages from json.
func (o *OptDataPageMonsterSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageMonsterSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageMonsterSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageMonsterSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageResourceSchemaPages as json.
func (o OptDataPageResourceSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageResourceSchemaPages from json.
func (o *OptDataPageResourceSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageResourceSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageResourceSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageResourceSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageSimpleItemSchemaPages as json.
func (o OptDataPageSimpleItemSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageSimpleItemSchemaPages from json.
func (o *OptDataPageSimpleItemSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageSimpleItemSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageSimpleItemSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageSimpleItemSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes DeleteItemSchemaCharacterCooldownExpiration as json.
func (o OptDeleteItemSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DeleteItemSchemaCharacterCooldownExpiration from json.
func (o *OptDeleteItemSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDeleteItemSchemaCharacterCooldownExpiration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDeleteItemSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDeleteItemSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EquipRequestSchemaCharacterCooldownExpiration as json.
func (o OptEquipRequestSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EquipRequestSchemaCharacterCooldownExpiration from json.
func (o *OptEquipRequestSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEquipRequestSchemaCharacterCooldownExpiration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEquipRequestSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEquipRequestSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EquipRequestSchemaItemCraft as json.
func (o OptEquipRequestSchemaItemCraft) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EquipRequestSchemaItemCraft from json.
func (o *OptEquipRequestSchemaItemCraft) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEquipRequestSchemaItemCraft to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEquipRequestSchemaItemCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEquipRequestSchemaItemCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GETransactionListSchemaCharacterCooldownExpiration as json.
func (o OptGETransactionListSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GETransactionListSchemaCharacterCooldownExpiration from json.
func (o *OptGETransactionListSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGETransactionListSchemaCharacterCooldownExpiration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGETransactionListSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGETransactionListSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GoldTransactionSchemaCharacterCooldownExpiration as json.
func (o OptGoldTransactionSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GoldTransactionSchemaCharacterCooldownExpiration from json.
func (o *OptGoldTransactionSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGoldTransactionSchemaCharacterCooldownExpiration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGoldTransactionSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGoldTransactionSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ItemSchemaCraft as json.
func (o OptItemSchemaCraft) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ItemSchemaCraft from json.
func (o *OptItemSchemaCraft) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptItemSchemaCraft to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptItemSchemaCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptItemSchemaCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecyclingDataSchemaCharacterCooldownExpiration as json.
func (o OptRecyclingDataSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RecyclingDataSchemaCharacterCooldownExpiration from json.
func (o *OptRecyclingDataSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRecyclingDataSchemaCharacterCooldownExpiration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRecyclingDataSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRecyclingDataSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SingleItemSchemaGe as json.
func (o OptSingleItemSchemaGe) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SingleItemSchemaGe from json.
func (o *OptSingleItemSchemaGe) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSingleItemSchemaGe to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSingleItemSchemaGe) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSingleItemSchemaGe) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SingleItemSchemaItemCraft as json.
func (o OptSingleItemSchemaItemCraft) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SingleItemSchemaItemCraft from json.
func (o *OptSingleItemSchemaItemCraft) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSingleItemSchemaItemCraft to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSingleItemSchemaItemCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSingleItemSchemaItemCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SkillDataSchemaCharacterCooldownExpiration as json.
func (o OptSkillDataSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SkillDataSchemaCharacterCooldownExpiration from json.
func (o *OptSkillDataSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSkillDataSchemaCharacterCooldownExpiration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSkillDataSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSkillDataSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskDataSchemaCharacterCooldownExpiration as json.
func (o OptTaskDataSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TaskDataSchemaCharacterCooldownExpiration from json.
func (o *OptTaskDataSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTaskDataSchemaCharacterCooldownExpiration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTaskDataSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTaskDataSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskRewardDataSchemaCharacterCooldownExpiration as json.
func (o OptTaskRewardDataSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TaskRewardDataSchemaCharacterCooldownExpiration from json.
func (o *OptTaskRewardDataSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTaskRewardDataSchemaCharacterCooldownExpiration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTaskRewardDataSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTaskRewardDataSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecyclingDataSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecyclingDataSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("details")
		s.Details.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfRecyclingDataSchema = [3]string{
	0: "cooldown",
	1: "details",
	2: "character",
}

// Decode decodes RecyclingDataSchema from json.
func (s *RecyclingDataSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingDataSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "details":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecyclingDataSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecyclingDataSchema) {
					name = jsonFieldsNameOfRecyclingDataSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecyclingDataSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingDataSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecyclingDataSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecyclingDataSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("total_xp")
		e.Int(s.TotalXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("inventory_slot1")
		e.Str(s.InventorySlot1)
	}
	{
		e.FieldStart("inventory_slot1_quantity")
		e.Int(s.InventorySlot1Quantity)
	}
	{
		e.FieldStart("inventory_slot2")
		e.Str(s.InventorySlot2)
	}
	{
		e.FieldStart("inventory_slot2_quantity")
		e.Int(s.InventorySlot2Quantity)
	}
	{
		e.FieldStart("inventory_slot3")
		e.Str(s.InventorySlot3)
	}
	{
		e.FieldStart("inventory_slot3_quantity")
		e.Int(s.InventorySlot3Quantity)
	}
	{
		e.FieldStart("inventory_slot4")
		e.Str(s.InventorySlot4)
	}
	{
		e.FieldStart("inventory_slot4_quantity")
		e.Int(s.InventorySlot4Quantity)
	}
	{
		e.FieldStart("inventory_slot5")
		e.Str(s.InventorySlot5)
	}
	{
		e.FieldStart("inventory_slot5_quantity")
		e.Int(s.InventorySlot5Quantity)
	}
	{
		e.FieldStart("inventory_slot6")
		e.Str(s.InventorySlot6)
	}
	{
		e.FieldStart("inventory_slot6_quantity")
		e.Int(s.InventorySlot6Quantity)
	}
	{
		e.FieldStart("inventory_slot7")
		e.Str(s.InventorySlot7)
	}
	{
		e.FieldStart("inventory_slot7_quantity")
		e.Int(s.InventorySlot7Quantity)
	}
	{
		e.FieldStart("inventory_slot8")
		e.Str(s.InventorySlot8)
	}
	{
		e.FieldStart("inventory_slot8_quantity")
		e.Int(s.InventorySlot8Quantity)
	}
	{
		e.FieldStart("inventory_slot9")
		e.Str(s.InventorySlot9)
	}
	{
		e.FieldStart("inventory_slot9_quantity")
		e.Int(s.InventorySlot9Quantity)
	}
	{
		e.FieldStart("inventory_slot10")
		e.Str(s.InventorySlot10)
	}
	{
		e.FieldStart("inventory_slot10_quantity")
		e.Int(s.InventorySlot10Quantity)
	}
	{
		e.FieldStart("inventory_slot11")
		e.Str(s.InventorySlot11)
	}
	{
		e.FieldStart("inventory_slot11_quantity")
		e.Int(s.InventorySlot11Quantity)
	}
	{
		e.FieldStart("inventory_slot12")
		e.Str(s.InventorySlot12)
	}
	{
		e.FieldStart("inventory_slot12_quantity")
		e.Int(s.InventorySlot12Quantity)
	}
	{
		e.FieldStart("inventory_slot13")
		e.Str(s.InventorySlot13)
	}
	{
		e.FieldStart("inventory_slot13_quantity")
		e.Int(s.InventorySlot13Quantity)
	}
	{
		e.FieldStart("inventory_slot14")
		e.Str(s.InventorySlot14)
	}
	{
		e.FieldStart("inventory_slot14_quantity")
		e.Int(s.InventorySlot14Quantity)
	}
	{
		e.FieldStart("inventory_slot15")
		e.Str(s.InventorySlot15)
	}
	{
		e.FieldStart("inventory_slot15_quantity")
		e.Int(s.InventorySlot15Quantity)
	}
	{
		e.FieldStart("inventory_slot16")
		e.Str(s.InventorySlot16)
	}
	{
		e.FieldStart("inventory_slot16_quantity")
		e.Int(s.InventorySlot16Quantity)
	}
	{
		e.FieldStart("inventory_slot17")
		e.Str(s.InventorySlot17)
	}
	{
		e.FieldStart("inventory_slot17_quantity")
		e.Int(s.InventorySlot17Quantity)
	}
	{
		e.FieldStart("inventory_slot18")
		e.Str(s.InventorySlot18)
	}
	{
		e.FieldStart("inventory_slot18_quantity")
		e.Int(s.InventorySlot18Quantity)
	}
	{
		e.FieldStart("inventory_slot19")
		e.Str(s.InventorySlot19)
	}
	{
		e.FieldStart("inventory_slot19_quantity")
		e.Int(s.InventorySlot19Quantity)
	}
	{
		e.FieldStart("inventory_slot20")
		e.Str(s.InventorySlot20)
	}
	{
		e.FieldStart("inventory_slot20_quantity")
		e.Int(s.InventorySlot20Quantity)
	}
}

var jsonFieldsNameOfRecyclingDataSchemaCharacter = [111]string{
	0:   "name",
	1:   "skin",
	2:   "level",
	3:   "xp",
	4:   "max_xp",
	5:   "total_xp",
	6:   "gold",
	7:   "speed",
	8:   "mining_level",
	9:   "mining_xp",
	10:  "mining_max_xp",
	11:  "woodcutting_level",
	12:  "woodcutting_xp",
	13:  "woodcutting_max_xp",
	14:  "fishing_level",
	15:  "fishing_xp",
	16:  "fishing_max_xp",
	17:  "weaponcrafting_level",
	18:  "weaponcrafting_xp",
	19:  "weaponcrafting_max_xp",
	20:  "gearcrafting_level",
	21:  "gearcrafting_xp",
	22:  "gearcrafting_max_xp",
	23:  "jewelrycrafting_level",
	24:  "jewelrycrafting_xp",
	25:  "jewelrycrafting_max_xp",
	26:  "cooking_level",
	27:  "cooking_xp",
	28:  "cooking_max_xp",
	29:  "hp",
	30:  "haste",
	31:  "critical_strike",
	32:  "stamina",
	33:  "attack_fire",
	34:  "attack_earth",
	35:  "attack_water",
	36:  "attack_air",
	37:  "dmg_fire",
	38:  "dmg_earth",
	39:  "dmg_water",
	40:  "dmg_air",
	41:  "res_fire",
	42:  "res_earth",
	43:  "res_water",
	44:  "res_air",
	45:  "x",
	46:  "y",
	47:  "cooldown",
	48:  "cooldown_expiration",
	49:  "weapon_slot",
	50:  "shield_slot",
	51:  "helmet_slot",
	52:  "body_armor_slot",
	53:  "leg_armor_slot",
	54:  "boots_slot",
	55:  "ring1_slot",
	56:  "ring2_slot",
	57:  "amulet_slot",
	58:  "artifact1_slot",
	59:  "artifact2_slot",
	60:  "artifact3_slot",
	61:  "consumable1_slot",
	62:  "consumable1_slot_quantity",
	63:  "consumable2_slot",
	64:  "consumable2_slot_quantity",
	65:  "task",
	66:  "task_type",
	67:  "task_progress",
	68:  "task_total",
	69:  "inventory_max_items",
	70:  "inventory",
	71:  "inventory_slot1",
	72:  "inventory_slot1_quantity",
	73:  "inventory_slot2",
	74:  "inventory_slot2_quantity",
	75:  "inventory_slot3",
	76:  "inventory_slot3_quantity",
	77:  "inventory_slot4",
	78:  "inventory_slot4_quantity",
	79:  "inventory_slot5",
	80:  "inventory_slot5_quantity",
	81:  "inventory_slot6",
	82:  "inventory_slot6_quantity",
	83:  "inventory_slot7",
	84:  "inventory_slot7_quantity",
	85:  "inventory_slot8",
	86:  "inventory_slot8_quantity",
	87:  "inventory_slot9",
	88:  "inventory_slot9_quantity",
	89:  "inventory_slot10",
	90:  "inventory_slot10_quantity",
	91:  "inventory_slot11",
	92:  "inventory_slot11_quantity",
	93:  "inventory_slot12",
	94:  "inventory_slot12_quantity",
	95:  "inventory_slot13",
	96:  "inventory_slot13_quantity",
	97:  "inventory_slot14",
	98:  "inventory_slot14_quantity",
	99:  "inventory_slot15",
	100: "inventory_slot15_quantity",
	101: "inventory_slot16",
	102: "inventory_slot16_quantity",
	103: "inventory_slot17",
	104: "inventory_slot17_quantity",
	105: "inventory_slot18",
	106: "inventory_slot18_quantity",
	107: "inventory_slot19",
	108: "inventory_slot19_quantity",
	109: "inventory_slot20",
	110: "inventory_slot20_quantity",
}

// Decode decodes RecyclingDataSchemaCharacter from json.
func (s *RecyclingDataSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingDataSchemaCharacter to nil")
	}
	var requiredBitSet [14]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "total_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.TotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		case "inventory_slot1":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot1 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1\"")
			}
		case "inventory_slot1_quantity":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot1Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1_quantity\"")
			}
		case "inventory_slot2":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot2 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2\"")
			}
		case "inventory_slot2_quantity":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot2Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2_quantity\"")
			}
		case "inventory_slot3":
			requiredBitSet[9] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot3 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3\"")
			}
		case "inventory_slot3_quantity":
			requiredBitSet[9] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot3Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3_quantity\"")
			}
		case "inventory_slot4":
			requiredBitSet[9] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot4 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4\"")
			}
		case "inventory_slot4_quantity":
			requiredBitSet[9] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot4Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4_quantity\"")
			}
		case "inventory_slot5":
			requiredBitSet[9] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot5 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5\"")
			}
		case "inventory_slot5_quantity":
			requiredBitSet[10] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot5Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5_quantity\"")
			}
		case "inventory_slot6":
			requiredBitSet[10] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot6 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6\"")
			}
		case "inventory_slot6_quantity":
			requiredBitSet[10] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot6Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6_quantity\"")
			}
		case "inventory_slot7":
			requiredBitSet[10] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot7 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7\"")
			}
		case "inventory_slot7_quantity":
			requiredBitSet[10] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot7Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7_quantity\"")
			}
		case "inventory_slot8":
			requiredBitSet[10] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot8 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8\"")
			}
		case "inventory_slot8_quantity":
			requiredBitSet[10] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot8Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8_quantity\"")
			}
		case "inventory_slot9":
			requiredBitSet[10] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot9 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9\"")
			}
		case "inventory_slot9_quantity":
			requiredBitSet[11] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot9Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9_quantity\"")
			}
		case "inventory_slot10":
			requiredBitSet[11] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot10 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10\"")
			}
		case "inventory_slot10_quantity":
			requiredBitSet[11] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot10Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10_quantity\"")
			}
		case "inventory_slot11":
			requiredBitSet[11] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot11 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11\"")
			}
		case "inventory_slot11_quantity":
			requiredBitSet[11] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot11Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11_quantity\"")
			}
		case "inventory_slot12":
			requiredBitSet[11] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot12 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12\"")
			}
		case "inventory_slot12_quantity":
			requiredBitSet[11] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot12Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12_quantity\"")
			}
		case "inventory_slot13":
			requiredBitSet[11] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot13 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13\"")
			}
		case "inventory_slot13_quantity":
			requiredBitSet[12] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot13Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13_quantity\"")
			}
		case "inventory_slot14":
			requiredBitSet[12] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot14 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14\"")
			}
		case "inventory_slot14_quantity":
			requiredBitSet[12] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot14Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14_quantity\"")
			}
		case "inventory_slot15":
			requiredBitSet[12] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot15 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15\"")
			}
		case "inventory_slot15_quantity":
			requiredBitSet[12] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot15Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15_quantity\"")
			}
		case "inventory_slot16":
			requiredBitSet[12] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot16 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16\"")
			}
		case "inventory_slot16_quantity":
			requiredBitSet[12] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot16Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16_quantity\"")
			}
		case "inventory_slot17":
			requiredBitSet[12] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot17 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17\"")
			}
		case "inventory_slot17_quantity":
			requiredBitSet[13] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot17Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17_quantity\"")
			}
		case "inventory_slot18":
			requiredBitSet[13] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot18 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18\"")
			}
		case "inventory_slot18_quantity":
			requiredBitSet[13] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot18Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18_quantity\"")
			}
		case "inventory_slot19":
			requiredBitSet[13] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot19 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19\"")
			}
		case "inventory_slot19_quantity":
			requiredBitSet[13] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot19Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19_quantity\"")
			}
		case "inventory_slot20":
			requiredBitSet[13] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot20 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20\"")
			}
		case "inventory_slot20_quantity":
			requiredBitSet[13] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot20Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20_quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecyclingDataSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [14]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b10111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecyclingDataSchemaCharacter) {
					name = jsonFieldsNameOfRecyclingDataSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecyclingDataSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingDataSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecyclingDataSchemaCharacterCooldownExpiration as json.
func (s RecyclingDataSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	switch s.Type {
	case DateTimeRecyclingDataSchemaCharacterCooldownExpiration:
		json.EncodeDateTime(e, s.DateTime)
	case NullRecyclingDataSchemaCharacterCooldownExpiration:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes RecyclingDataSchemaCharacterCooldownExpiration from json.
func (s *RecyclingDataSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingDataSchemaCharacterCooldownExpiration to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullRecyclingDataSchemaCharacterCooldownExpiration
	case jx.String:
		v, err := json.DecodeDateTime(d)
		s.DateTime = v
		if err != nil {
			return err
		}
		s.Type = DateTimeRecyclingDataSchemaCharacterCooldownExpiration
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecyclingDataSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingDataSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecyclingDataSchemaCharacterSkin as json.
func (s RecyclingDataSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RecyclingDataSchemaCharacterSkin from json.
func (s *RecyclingDataSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingDataSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RecyclingDataSchemaCharacterSkin(v) {
	case RecyclingDataSchemaCharacterSkinMen1:
		*s = RecyclingDataSchemaCharacterSkinMen1
	case RecyclingDataSchemaCharacterSkinMen2:
		*s = RecyclingDataSchemaCharacterSkinMen2
	case RecyclingDataSchemaCharacterSkinMen3:
		*s = RecyclingDataSchemaCharacterSkinMen3
	case RecyclingDataSchemaCharacterSkinWomen1:
		*s = RecyclingDataSchemaCharacterSkinWomen1
	case RecyclingDataSchemaCharacterSkinWomen2:
		*s = RecyclingDataSchemaCharacterSkinWomen2
	case RecyclingDataSchemaCharacterSkinWomen3:
		*s = RecyclingDataSchemaCharacterSkinWomen3
	default:
		*s = RecyclingDataSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecyclingDataSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingDataSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecyclingDataSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecyclingDataSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfRecyclingDataSchemaCooldown = [4]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "expiration",
	3: "reason",
}

// Decode decodes RecyclingDataSchemaCooldown from json.
func (s *RecyclingDataSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingDataSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecyclingDataSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecyclingDataSchemaCooldown) {
					name = jsonFieldsNameOfRecyclingDataSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecyclingDataSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingDataSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecyclingDataSchemaCooldownReason as json.
func (s RecyclingDataSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RecyclingDataSchemaCooldownReason from json.
func (s *RecyclingDataSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingDataSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RecyclingDataSchemaCooldownReason(v) {
	case RecyclingDataSchemaCooldownReasonMovement:
		*s = RecyclingDataSchemaCooldownReasonMovement
	case RecyclingDataSchemaCooldownReasonFight:
		*s = RecyclingDataSchemaCooldownReasonFight
	case RecyclingDataSchemaCooldownReasonCrafting:
		*s = RecyclingDataSchemaCooldownReasonCrafting
	case RecyclingDataSchemaCooldownReasonGathering:
		*s = RecyclingDataSchemaCooldownReasonGathering
	case RecyclingDataSchemaCooldownReasonBuyGe:
		*s = RecyclingDataSchemaCooldownReasonBuyGe
	case RecyclingDataSchemaCooldownReasonSellGe:
		*s = RecyclingDataSchemaCooldownReasonSellGe
	case RecyclingDataSchemaCooldownReasonDeleteItem:
		*s = RecyclingDataSchemaCooldownReasonDeleteItem
	case RecyclingDataSchemaCooldownReasonDepositBank:
		*s = RecyclingDataSchemaCooldownReasonDepositBank
	case RecyclingDataSchemaCooldownReasonWithdrawBank:
		*s = RecyclingDataSchemaCooldownReasonWithdrawBank
	case RecyclingDataSchemaCooldownReasonEquip:
		*s = RecyclingDataSchemaCooldownReasonEquip
	case RecyclingDataSchemaCooldownReasonUnequip:
		*s = RecyclingDataSchemaCooldownReasonUnequip
	case RecyclingDataSchemaCooldownReasonTask:
		*s = RecyclingDataSchemaCooldownReasonTask
	case RecyclingDataSchemaCooldownReasonRecycling:
		*s = RecyclingDataSchemaCooldownReasonRecycling
	default:
		*s = RecyclingDataSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecyclingDataSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingDataSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecyclingDataSchemaDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecyclingDataSchemaDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfRecyclingDataSchemaDetails = [1]string{
	0: "items",
}

// Decode decodes RecyclingDataSchemaDetails from json.
func (s *RecyclingDataSchemaDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingDataSchemaDetails to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Items = make([]DropSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DropSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecyclingDataSchemaDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecyclingDataSchemaDetails) {
					name = jsonFieldsNameOfRecyclingDataSchemaDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecyclingDataSchemaDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingDataSchemaDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecyclingResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecyclingResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfRecyclingResponseSchema = [1]string{
	0: "data",
}

// Decode decodes RecyclingResponseSchema from json.
func (s *RecyclingResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecyclingResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecyclingResponseSchema) {
					name = jsonFieldsNameOfRecyclingResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecyclingResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecyclingSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecyclingSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecyclingSchema = [2]string{
	0: "code",
	1: "quantity",
}

// Decode decodes RecyclingSchema from json.
func (s *RecyclingSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingSchema to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecyclingSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecyclingSchema) {
					name = jsonFieldsNameOfRecyclingSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecyclingSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfResourceResponseSchema = [1]string{
	0: "data",
}

// Decode decodes ResourceResponseSchema from json.
func (s *ResourceResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResourceResponseSchema) {
					name = jsonFieldsNameOfResourceResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("skill")
		s.Skill.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("drops")
		e.ArrStart()
		for _, elem := range s.Drops {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfResourceSchema = [5]string{
	0: "name",
	1: "code",
	2: "skill",
	3: "level",
	4: "drops",
}

// Decode decodes ResourceSchema from json.
func (s *ResourceSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "skill":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Skill.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skill\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "drops":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Drops = make([]DropRateSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DropRateSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Drops = append(s.Drops, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drops\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResourceSchema) {
					name = jsonFieldsNameOfResourceSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourceSchemaSkill as json.
func (s ResourceSchemaSkill) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ResourceSchemaSkill from json.
func (s *ResourceSchemaSkill) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceSchemaSkill to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ResourceSchemaSkill(v) {
	case ResourceSchemaSkillMining:
		*s = ResourceSchemaSkillMining
	case ResourceSchemaSkillWoodcutting:
		*s = ResourceSchemaSkillWoodcutting
	case ResourceSchemaSkillFishing:
		*s = ResourceSchemaSkillFishing
	default:
		*s = ResourceSchemaSkill(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResourceSchemaSkill) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceSchemaSkill) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfResponseSchema = [1]string{
	0: "message",
}

// Decode decodes ResponseSchema from json.
func (s *ResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResponseSchema) {
					name = jsonFieldsNameOfResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SimpleItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SimpleItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfSimpleItemSchema = [2]string{
	0: "code",
	1: "quantity",
}

// Decode decodes SimpleItemSchema from json.
func (s *SimpleItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SimpleItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SimpleItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSimpleItemSchema) {
					name = jsonFieldsNameOfSimpleItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SimpleItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SimpleItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SingleItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SingleItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("item")
		s.Item.Encode(e)
	}
	{
		if s.Ge.Set {
			e.FieldStart("ge")
			s.Ge.Encode(e)
		}
	}
}

var jsonFieldsNameOfSingleItemSchema = [2]string{
	0: "item",
	1: "ge",
}

// Decode decodes SingleItemSchema from json.
func (s *SingleItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SingleItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "item":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Item.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item\"")
			}
		case "ge":
			if err := func() error {
				s.Ge.Reset()
				if err := s.Ge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ge\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SingleItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSingleItemSchema) {
					name = jsonFieldsNameOfSingleItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SingleItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SingleItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SingleItemSchemaGe as json.
func (s SingleItemSchemaGe) Encode(e *jx.Encoder) {
	switch s.Type {
	case GEItemSchemaSingleItemSchemaGe:
		s.GEItemSchema.Encode(e)
	case NullSingleItemSchemaGe:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes SingleItemSchemaGe from json.
func (s *SingleItemSchemaGe) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SingleItemSchemaGe to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullSingleItemSchemaGe
	case jx.Object:
		if err := s.GEItemSchema.Decode(d); err != nil {
			return err
		}
		s.Type = GEItemSchemaSingleItemSchemaGe
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SingleItemSchemaGe) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SingleItemSchemaGe) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SingleItemSchemaItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SingleItemSchemaItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("subtype")
		e.Str(s.Subtype)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Effects != nil {
			e.FieldStart("effects")
			e.ArrStart()
			for _, elem := range s.Effects {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Craft.Set {
			e.FieldStart("craft")
			s.Craft.Encode(e)
		}
	}
}

var jsonFieldsNameOfSingleItemSchemaItem = [8]string{
	0: "name",
	1: "code",
	2: "level",
	3: "type",
	4: "subtype",
	5: "description",
	6: "effects",
	7: "craft",
}

// Decode decodes SingleItemSchemaItem from json.
func (s *SingleItemSchemaItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SingleItemSchemaItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "subtype":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Subtype = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subtype\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "effects":
			if err := func() error {
				s.Effects = make([]ItemEffectSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ItemEffectSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Effects = append(s.Effects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effects\"")
			}
		case "craft":
			if err := func() error {
				s.Craft.Reset()
				if err := s.Craft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"craft\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SingleItemSchemaItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSingleItemSchemaItem) {
					name = jsonFieldsNameOfSingleItemSchemaItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SingleItemSchemaItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SingleItemSchemaItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SingleItemSchemaItemCraft as json.
func (s SingleItemSchemaItemCraft) Encode(e *jx.Encoder) {
	switch s.Type {
	case CraftSchemaSingleItemSchemaItemCraft:
		s.CraftSchema.Encode(e)
	case NullSingleItemSchemaItemCraft:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes SingleItemSchemaItemCraft from json.
func (s *SingleItemSchemaItemCraft) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SingleItemSchemaItemCraft to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullSingleItemSchemaItemCraft
	case jx.Object:
		if err := s.CraftSchema.Decode(d); err != nil {
			return err
		}
		s.Type = CraftSchemaSingleItemSchemaItemCraft
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SingleItemSchemaItemCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SingleItemSchemaItemCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SkillDataSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SkillDataSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("details")
		s.Details.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfSkillDataSchema = [3]string{
	0: "cooldown",
	1: "details",
	2: "character",
}

// Decode decodes SkillDataSchema from json.
func (s *SkillDataSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillDataSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "details":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SkillDataSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSkillDataSchema) {
					name = jsonFieldsNameOfSkillDataSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SkillDataSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillDataSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SkillDataSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SkillDataSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("total_xp")
		e.Int(s.TotalXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("inventory_slot1")
		e.Str(s.InventorySlot1)
	}
	{
		e.FieldStart("inventory_slot1_quantity")
		e.Int(s.InventorySlot1Quantity)
	}
	{
		e.FieldStart("inventory_slot2")
		e.Str(s.InventorySlot2)
	}
	{
		e.FieldStart("inventory_slot2_quantity")
		e.Int(s.InventorySlot2Quantity)
	}
	{
		e.FieldStart("inventory_slot3")
		e.Str(s.InventorySlot3)
	}
	{
		e.FieldStart("inventory_slot3_quantity")
		e.Int(s.InventorySlot3Quantity)
	}
	{
		e.FieldStart("inventory_slot4")
		e.Str(s.InventorySlot4)
	}
	{
		e.FieldStart("inventory_slot4_quantity")
		e.Int(s.InventorySlot4Quantity)
	}
	{
		e.FieldStart("inventory_slot5")
		e.Str(s.InventorySlot5)
	}
	{
		e.FieldStart("inventory_slot5_quantity")
		e.Int(s.InventorySlot5Quantity)
	}
	{
		e.FieldStart("inventory_slot6")
		e.Str(s.InventorySlot6)
	}
	{
		e.FieldStart("inventory_slot6_quantity")
		e.Int(s.InventorySlot6Quantity)
	}
	{
		e.FieldStart("inventory_slot7")
		e.Str(s.InventorySlot7)
	}
	{
		e.FieldStart("inventory_slot7_quantity")
		e.Int(s.InventorySlot7Quantity)
	}
	{
		e.FieldStart("inventory_slot8")
		e.Str(s.InventorySlot8)
	}
	{
		e.FieldStart("inventory_slot8_quantity")
		e.Int(s.InventorySlot8Quantity)
	}
	{
		e.FieldStart("inventory_slot9")
		e.Str(s.InventorySlot9)
	}
	{
		e.FieldStart("inventory_slot9_quantity")
		e.Int(s.InventorySlot9Quantity)
	}
	{
		e.FieldStart("inventory_slot10")
		e.Str(s.InventorySlot10)
	}
	{
		e.FieldStart("inventory_slot10_quantity")
		e.Int(s.InventorySlot10Quantity)
	}
	{
		e.FieldStart("inventory_slot11")
		e.Str(s.InventorySlot11)
	}
	{
		e.FieldStart("inventory_slot11_quantity")
		e.Int(s.InventorySlot11Quantity)
	}
	{
		e.FieldStart("inventory_slot12")
		e.Str(s.InventorySlot12)
	}
	{
		e.FieldStart("inventory_slot12_quantity")
		e.Int(s.InventorySlot12Quantity)
	}
	{
		e.FieldStart("inventory_slot13")
		e.Str(s.InventorySlot13)
	}
	{
		e.FieldStart("inventory_slot13_quantity")
		e.Int(s.InventorySlot13Quantity)
	}
	{
		e.FieldStart("inventory_slot14")
		e.Str(s.InventorySlot14)
	}
	{
		e.FieldStart("inventory_slot14_quantity")
		e.Int(s.InventorySlot14Quantity)
	}
	{
		e.FieldStart("inventory_slot15")
		e.Str(s.InventorySlot15)
	}
	{
		e.FieldStart("inventory_slot15_quantity")
		e.Int(s.InventorySlot15Quantity)
	}
	{
		e.FieldStart("inventory_slot16")
		e.Str(s.InventorySlot16)
	}
	{
		e.FieldStart("inventory_slot16_quantity")
		e.Int(s.InventorySlot16Quantity)
	}
	{
		e.FieldStart("inventory_slot17")
		e.Str(s.InventorySlot17)
	}
	{
		e.FieldStart("inventory_slot17_quantity")
		e.Int(s.InventorySlot17Quantity)
	}
	{
		e.FieldStart("inventory_slot18")
		e.Str(s.InventorySlot18)
	}
	{
		e.FieldStart("inventory_slot18_quantity")
		e.Int(s.InventorySlot18Quantity)
	}
	{
		e.FieldStart("inventory_slot19")
		e.Str(s.InventorySlot19)
	}
	{
		e.FieldStart("inventory_slot19_quantity")
		e.Int(s.InventorySlot19Quantity)
	}
	{
		e.FieldStart("inventory_slot20")
		e.Str(s.InventorySlot20)
	}
	{
		e.FieldStart("inventory_slot20_quantity")
		e.Int(s.InventorySlot20Quantity)
	}
}

var jsonFieldsNameOfSkillDataSchemaCharacter = [111]string{
	0:   "name",
	1:   "skin",
	2:   "level",
	3:   "xp",
	4:   "max_xp",
	5:   "total_xp",
	6:   "gold",
	7:   "speed",
	8:   "mining_level",
	9:   "mining_xp",
	10:  "mining_max_xp",
	11:  "woodcutting_level",
	12:  "woodcutting_xp",
	13:  "woodcutting_max_xp",
	14:  "fishing_level",
	15:  "fishing_xp",
	16:  "fishing_max_xp",
	17:  "weaponcrafting_level",
	18:  "weaponcrafting_xp",
	19:  "weaponcrafting_max_xp",
	20:  "gearcrafting_level",
	21:  "gearcrafting_xp",
	22:  "gearcrafting_max_xp",
	23:  "jewelrycrafting_level",
	24:  "jewelrycrafting_xp",
	25:  "jewelrycrafting_max_xp",
	26:  "cooking_level",
	27:  "cooking_xp",
	28:  "cooking_max_xp",
	29:  "hp",
	30:  "haste",
	31:  "critical_strike",
	32:  "stamina",
	33:  "attack_fire",
	34:  "attack_earth",
	35:  "attack_water",
	36:  "attack_air",
	37:  "dmg_fire",
	38:  "dmg_earth",
	39:  "dmg_water",
	40:  "dmg_air",
	41:  "res_fire",
	42:  "res_earth",
	43:  "res_water",
	44:  "res_air",
	45:  "x",
	46:  "y",
	47:  "cooldown",
	48:  "cooldown_expiration",
	49:  "weapon_slot",
	50:  "shield_slot",
	51:  "helmet_slot",
	52:  "body_armor_slot",
	53:  "leg_armor_slot",
	54:  "boots_slot",
	55:  "ring1_slot",
	56:  "ring2_slot",
	57:  "amulet_slot",
	58:  "artifact1_slot",
	59:  "artifact2_slot",
	60:  "artifact3_slot",
	61:  "consumable1_slot",
	62:  "consumable1_slot_quantity",
	63:  "consumable2_slot",
	64:  "consumable2_slot_quantity",
	65:  "task",
	66:  "task_type",
	67:  "task_progress",
	68:  "task_total",
	69:  "inventory_max_items",
	70:  "inventory",
	71:  "inventory_slot1",
	72:  "inventory_slot1_quantity",
	73:  "inventory_slot2",
	74:  "inventory_slot2_quantity",
	75:  "inventory_slot3",
	76:  "inventory_slot3_quantity",
	77:  "inventory_slot4",
	78:  "inventory_slot4_quantity",
	79:  "inventory_slot5",
	80:  "inventory_slot5_quantity",
	81:  "inventory_slot6",
	82:  "inventory_slot6_quantity",
	83:  "inventory_slot7",
	84:  "inventory_slot7_quantity",
	85:  "inventory_slot8",
	86:  "inventory_slot8_quantity",
	87:  "inventory_slot9",
	88:  "inventory_slot9_quantity",
	89:  "inventory_slot10",
	90:  "inventory_slot10_quantity",
	91:  "inventory_slot11",
	92:  "inventory_slot11_quantity",
	93:  "inventory_slot12",
	94:  "inventory_slot12_quantity",
	95:  "inventory_slot13",
	96:  "inventory_slot13_quantity",
	97:  "inventory_slot14",
	98:  "inventory_slot14_quantity",
	99:  "inventory_slot15",
	100: "inventory_slot15_quantity",
	101: "inventory_slot16",
	102: "inventory_slot16_quantity",
	103: "inventory_slot17",
	104: "inventory_slot17_quantity",
	105: "inventory_slot18",
	106: "inventory_slot18_quantity",
	107: "inventory_slot19",
	108: "inventory_slot19_quantity",
	109: "inventory_slot20",
	110: "inventory_slot20_quantity",
}

// Decode decodes SkillDataSchemaCharacter from json.
func (s *SkillDataSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillDataSchemaCharacter to nil")
	}
	var requiredBitSet [14]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "total_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.TotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		case "inventory_slot1":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot1 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1\"")
			}
		case "inventory_slot1_quantity":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot1Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1_quantity\"")
			}
		case "inventory_slot2":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot2 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2\"")
			}
		case "inventory_slot2_quantity":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot2Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2_quantity\"")
			}
		case "inventory_slot3":
			requiredBitSet[9] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot3 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3\"")
			}
		case "inventory_slot3_quantity":
			requiredBitSet[9] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot3Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3_quantity\"")
			}
		case "inventory_slot4":
			requiredBitSet[9] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot4 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4\"")
			}
		case "inventory_slot4_quantity":
			requiredBitSet[9] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot4Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4_quantity\"")
			}
		case "inventory_slot5":
			requiredBitSet[9] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot5 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5\"")
			}
		case "inventory_slot5_quantity":
			requiredBitSet[10] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot5Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5_quantity\"")
			}
		case "inventory_slot6":
			requiredBitSet[10] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot6 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6\"")
			}
		case "inventory_slot6_quantity":
			requiredBitSet[10] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot6Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6_quantity\"")
			}
		case "inventory_slot7":
			requiredBitSet[10] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot7 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7\"")
			}
		case "inventory_slot7_quantity":
			requiredBitSet[10] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot7Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7_quantity\"")
			}
		case "inventory_slot8":
			requiredBitSet[10] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot8 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8\"")
			}
		case "inventory_slot8_quantity":
			requiredBitSet[10] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot8Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8_quantity\"")
			}
		case "inventory_slot9":
			requiredBitSet[10] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot9 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9\"")
			}
		case "inventory_slot9_quantity":
			requiredBitSet[11] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot9Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9_quantity\"")
			}
		case "inventory_slot10":
			requiredBitSet[11] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot10 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10\"")
			}
		case "inventory_slot10_quantity":
			requiredBitSet[11] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot10Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10_quantity\"")
			}
		case "inventory_slot11":
			requiredBitSet[11] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot11 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11\"")
			}
		case "inventory_slot11_quantity":
			requiredBitSet[11] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot11Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11_quantity\"")
			}
		case "inventory_slot12":
			requiredBitSet[11] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot12 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12\"")
			}
		case "inventory_slot12_quantity":
			requiredBitSet[11] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot12Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12_quantity\"")
			}
		case "inventory_slot13":
			requiredBitSet[11] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot13 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13\"")
			}
		case "inventory_slot13_quantity":
			requiredBitSet[12] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot13Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13_quantity\"")
			}
		case "inventory_slot14":
			requiredBitSet[12] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot14 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14\"")
			}
		case "inventory_slot14_quantity":
			requiredBitSet[12] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot14Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14_quantity\"")
			}
		case "inventory_slot15":
			requiredBitSet[12] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot15 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15\"")
			}
		case "inventory_slot15_quantity":
			requiredBitSet[12] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot15Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15_quantity\"")
			}
		case "inventory_slot16":
			requiredBitSet[12] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot16 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16\"")
			}
		case "inventory_slot16_quantity":
			requiredBitSet[12] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot16Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16_quantity\"")
			}
		case "inventory_slot17":
			requiredBitSet[12] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot17 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17\"")
			}
		case "inventory_slot17_quantity":
			requiredBitSet[13] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot17Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17_quantity\"")
			}
		case "inventory_slot18":
			requiredBitSet[13] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot18 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18\"")
			}
		case "inventory_slot18_quantity":
			requiredBitSet[13] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot18Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18_quantity\"")
			}
		case "inventory_slot19":
			requiredBitSet[13] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot19 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19\"")
			}
		case "inventory_slot19_quantity":
			requiredBitSet[13] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot19Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19_quantity\"")
			}
		case "inventory_slot20":
			requiredBitSet[13] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot20 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20\"")
			}
		case "inventory_slot20_quantity":
			requiredBitSet[13] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot20Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20_quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SkillDataSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [14]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b10111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSkillDataSchemaCharacter) {
					name = jsonFieldsNameOfSkillDataSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SkillDataSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillDataSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SkillDataSchemaCharacterCooldownExpiration as json.
func (s SkillDataSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	switch s.Type {
	case DateTimeSkillDataSchemaCharacterCooldownExpiration:
		json.EncodeDateTime(e, s.DateTime)
	case NullSkillDataSchemaCharacterCooldownExpiration:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes SkillDataSchemaCharacterCooldownExpiration from json.
func (s *SkillDataSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillDataSchemaCharacterCooldownExpiration to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullSkillDataSchemaCharacterCooldownExpiration
	case jx.String:
		v, err := json.DecodeDateTime(d)
		s.DateTime = v
		if err != nil {
			return err
		}
		s.Type = DateTimeSkillDataSchemaCharacterCooldownExpiration
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SkillDataSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillDataSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SkillDataSchemaCharacterSkin as json.
func (s SkillDataSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SkillDataSchemaCharacterSkin from json.
func (s *SkillDataSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillDataSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SkillDataSchemaCharacterSkin(v) {
	case SkillDataSchemaCharacterSkinMen1:
		*s = SkillDataSchemaCharacterSkinMen1
	case SkillDataSchemaCharacterSkinMen2:
		*s = SkillDataSchemaCharacterSkinMen2
	case SkillDataSchemaCharacterSkinMen3:
		*s = SkillDataSchemaCharacterSkinMen3
	case SkillDataSchemaCharacterSkinWomen1:
		*s = SkillDataSchemaCharacterSkinWomen1
	case SkillDataSchemaCharacterSkinWomen2:
		*s = SkillDataSchemaCharacterSkinWomen2
	case SkillDataSchemaCharacterSkinWomen3:
		*s = SkillDataSchemaCharacterSkinWomen3
	default:
		*s = SkillDataSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SkillDataSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillDataSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SkillDataSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SkillDataSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfSkillDataSchemaCooldown = [4]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "expiration",
	3: "reason",
}

// Decode decodes SkillDataSchemaCooldown from json.
func (s *SkillDataSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillDataSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SkillDataSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSkillDataSchemaCooldown) {
					name = jsonFieldsNameOfSkillDataSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SkillDataSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillDataSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SkillDataSchemaCooldownReason as json.
func (s SkillDataSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SkillDataSchemaCooldownReason from json.
func (s *SkillDataSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillDataSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SkillDataSchemaCooldownReason(v) {
	case SkillDataSchemaCooldownReasonMovement:
		*s = SkillDataSchemaCooldownReasonMovement
	case SkillDataSchemaCooldownReasonFight:
		*s = SkillDataSchemaCooldownReasonFight
	case SkillDataSchemaCooldownReasonCrafting:
		*s = SkillDataSchemaCooldownReasonCrafting
	case SkillDataSchemaCooldownReasonGathering:
		*s = SkillDataSchemaCooldownReasonGathering
	case SkillDataSchemaCooldownReasonBuyGe:
		*s = SkillDataSchemaCooldownReasonBuyGe
	case SkillDataSchemaCooldownReasonSellGe:
		*s = SkillDataSchemaCooldownReasonSellGe
	case SkillDataSchemaCooldownReasonDeleteItem:
		*s = SkillDataSchemaCooldownReasonDeleteItem
	case SkillDataSchemaCooldownReasonDepositBank:
		*s = SkillDataSchemaCooldownReasonDepositBank
	case SkillDataSchemaCooldownReasonWithdrawBank:
		*s = SkillDataSchemaCooldownReasonWithdrawBank
	case SkillDataSchemaCooldownReasonEquip:
		*s = SkillDataSchemaCooldownReasonEquip
	case SkillDataSchemaCooldownReasonUnequip:
		*s = SkillDataSchemaCooldownReasonUnequip
	case SkillDataSchemaCooldownReasonTask:
		*s = SkillDataSchemaCooldownReasonTask
	case SkillDataSchemaCooldownReasonRecycling:
		*s = SkillDataSchemaCooldownReasonRecycling
	default:
		*s = SkillDataSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SkillDataSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillDataSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SkillDataSchemaDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SkillDataSchemaDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSkillDataSchemaDetails = [2]string{
	0: "xp",
	1: "items",
}

// Decode decodes SkillDataSchemaDetails from json.
func (s *SkillDataSchemaDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillDataSchemaDetails to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "xp":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]DropSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DropSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SkillDataSchemaDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSkillDataSchemaDetails) {
					name = jsonFieldsNameOfSkillDataSchemaDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SkillDataSchemaDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillDataSchemaDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SkillResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SkillResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfSkillResponseSchema = [1]string{
	0: "data",
}

// Decode decodes SkillResponseSchema from json.
func (s *SkillResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SkillResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSkillResponseSchema) {
					name = jsonFieldsNameOfSkillResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SkillResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StatusResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StatusResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfStatusResponseSchema = [1]string{
	0: "data",
}

// Decode decodes StatusResponseSchema from json.
func (s *StatusResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StatusResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StatusResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStatusResponseSchema) {
					name = jsonFieldsNameOfStatusResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StatusResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StatusResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StatusSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StatusSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		if s.CharactersOnline.Set {
			e.FieldStart("characters_online")
			s.CharactersOnline.Encode(e)
		}
	}
	{
		if s.Announcements != nil {
			e.FieldStart("announcements")
			e.ArrStart()
			for _, elem := range s.Announcements {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("last_wipe")
		e.Str(s.LastWipe)
	}
	{
		e.FieldStart("next_wipe")
		e.Str(s.NextWipe)
	}
}

var jsonFieldsNameOfStatusSchema = [6]string{
	0: "status",
	1: "version",
	2: "characters_online",
	3: "announcements",
	4: "last_wipe",
	5: "next_wipe",
}

// Decode decodes StatusSchema from json.
func (s *StatusSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StatusSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "characters_online":
			if err := func() error {
				s.CharactersOnline.Reset()
				if err := s.CharactersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characters_online\"")
			}
		case "announcements":
			if err := func() error {
				s.Announcements = make([]AnnouncementSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AnnouncementSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Announcements = append(s.Announcements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"announcements\"")
			}
		case "last_wipe":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.LastWipe = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_wipe\"")
			}
		case "next_wipe":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.NextWipe = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_wipe\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StatusSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStatusSchema) {
					name = jsonFieldsNameOfStatusSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StatusSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StatusSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskDataSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskDataSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("task")
		s.Task.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfTaskDataSchema = [3]string{
	0: "cooldown",
	1: "task",
	2: "character",
}

// Decode decodes TaskDataSchema from json.
func (s *TaskDataSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "task":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Task.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskDataSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskDataSchema) {
					name = jsonFieldsNameOfTaskDataSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskDataSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskDataSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskDataSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("total_xp")
		e.Int(s.TotalXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("inventory_slot1")
		e.Str(s.InventorySlot1)
	}
	{
		e.FieldStart("inventory_slot1_quantity")
		e.Int(s.InventorySlot1Quantity)
	}
	{
		e.FieldStart("inventory_slot2")
		e.Str(s.InventorySlot2)
	}
	{
		e.FieldStart("inventory_slot2_quantity")
		e.Int(s.InventorySlot2Quantity)
	}
	{
		e.FieldStart("inventory_slot3")
		e.Str(s.InventorySlot3)
	}
	{
		e.FieldStart("inventory_slot3_quantity")
		e.Int(s.InventorySlot3Quantity)
	}
	{
		e.FieldStart("inventory_slot4")
		e.Str(s.InventorySlot4)
	}
	{
		e.FieldStart("inventory_slot4_quantity")
		e.Int(s.InventorySlot4Quantity)
	}
	{
		e.FieldStart("inventory_slot5")
		e.Str(s.InventorySlot5)
	}
	{
		e.FieldStart("inventory_slot5_quantity")
		e.Int(s.InventorySlot5Quantity)
	}
	{
		e.FieldStart("inventory_slot6")
		e.Str(s.InventorySlot6)
	}
	{
		e.FieldStart("inventory_slot6_quantity")
		e.Int(s.InventorySlot6Quantity)
	}
	{
		e.FieldStart("inventory_slot7")
		e.Str(s.InventorySlot7)
	}
	{
		e.FieldStart("inventory_slot7_quantity")
		e.Int(s.InventorySlot7Quantity)
	}
	{
		e.FieldStart("inventory_slot8")
		e.Str(s.InventorySlot8)
	}
	{
		e.FieldStart("inventory_slot8_quantity")
		e.Int(s.InventorySlot8Quantity)
	}
	{
		e.FieldStart("inventory_slot9")
		e.Str(s.InventorySlot9)
	}
	{
		e.FieldStart("inventory_slot9_quantity")
		e.Int(s.InventorySlot9Quantity)
	}
	{
		e.FieldStart("inventory_slot10")
		e.Str(s.InventorySlot10)
	}
	{
		e.FieldStart("inventory_slot10_quantity")
		e.Int(s.InventorySlot10Quantity)
	}
	{
		e.FieldStart("inventory_slot11")
		e.Str(s.InventorySlot11)
	}
	{
		e.FieldStart("inventory_slot11_quantity")
		e.Int(s.InventorySlot11Quantity)
	}
	{
		e.FieldStart("inventory_slot12")
		e.Str(s.InventorySlot12)
	}
	{
		e.FieldStart("inventory_slot12_quantity")
		e.Int(s.InventorySlot12Quantity)
	}
	{
		e.FieldStart("inventory_slot13")
		e.Str(s.InventorySlot13)
	}
	{
		e.FieldStart("inventory_slot13_quantity")
		e.Int(s.InventorySlot13Quantity)
	}
	{
		e.FieldStart("inventory_slot14")
		e.Str(s.InventorySlot14)
	}
	{
		e.FieldStart("inventory_slot14_quantity")
		e.Int(s.InventorySlot14Quantity)
	}
	{
		e.FieldStart("inventory_slot15")
		e.Str(s.InventorySlot15)
	}
	{
		e.FieldStart("inventory_slot15_quantity")
		e.Int(s.InventorySlot15Quantity)
	}
	{
		e.FieldStart("inventory_slot16")
		e.Str(s.InventorySlot16)
	}
	{
		e.FieldStart("inventory_slot16_quantity")
		e.Int(s.InventorySlot16Quantity)
	}
	{
		e.FieldStart("inventory_slot17")
		e.Str(s.InventorySlot17)
	}
	{
		e.FieldStart("inventory_slot17_quantity")
		e.Int(s.InventorySlot17Quantity)
	}
	{
		e.FieldStart("inventory_slot18")
		e.Str(s.InventorySlot18)
	}
	{
		e.FieldStart("inventory_slot18_quantity")
		e.Int(s.InventorySlot18Quantity)
	}
	{
		e.FieldStart("inventory_slot19")
		e.Str(s.InventorySlot19)
	}
	{
		e.FieldStart("inventory_slot19_quantity")
		e.Int(s.InventorySlot19Quantity)
	}
	{
		e.FieldStart("inventory_slot20")
		e.Str(s.InventorySlot20)
	}
	{
		e.FieldStart("inventory_slot20_quantity")
		e.Int(s.InventorySlot20Quantity)
	}
}

var jsonFieldsNameOfTaskDataSchemaCharacter = [111]string{
	0:   "name",
	1:   "skin",
	2:   "level",
	3:   "xp",
	4:   "max_xp",
	5:   "total_xp",
	6:   "gold",
	7:   "speed",
	8:   "mining_level",
	9:   "mining_xp",
	10:  "mining_max_xp",
	11:  "woodcutting_level",
	12:  "woodcutting_xp",
	13:  "woodcutting_max_xp",
	14:  "fishing_level",
	15:  "fishing_xp",
	16:  "fishing_max_xp",
	17:  "weaponcrafting_level",
	18:  "weaponcrafting_xp",
	19:  "weaponcrafting_max_xp",
	20:  "gearcrafting_level",
	21:  "gearcrafting_xp",
	22:  "gearcrafting_max_xp",
	23:  "jewelrycrafting_level",
	24:  "jewelrycrafting_xp",
	25:  "jewelrycrafting_max_xp",
	26:  "cooking_level",
	27:  "cooking_xp",
	28:  "cooking_max_xp",
	29:  "hp",
	30:  "haste",
	31:  "critical_strike",
	32:  "stamina",
	33:  "attack_fire",
	34:  "attack_earth",
	35:  "attack_water",
	36:  "attack_air",
	37:  "dmg_fire",
	38:  "dmg_earth",
	39:  "dmg_water",
	40:  "dmg_air",
	41:  "res_fire",
	42:  "res_earth",
	43:  "res_water",
	44:  "res_air",
	45:  "x",
	46:  "y",
	47:  "cooldown",
	48:  "cooldown_expiration",
	49:  "weapon_slot",
	50:  "shield_slot",
	51:  "helmet_slot",
	52:  "body_armor_slot",
	53:  "leg_armor_slot",
	54:  "boots_slot",
	55:  "ring1_slot",
	56:  "ring2_slot",
	57:  "amulet_slot",
	58:  "artifact1_slot",
	59:  "artifact2_slot",
	60:  "artifact3_slot",
	61:  "consumable1_slot",
	62:  "consumable1_slot_quantity",
	63:  "consumable2_slot",
	64:  "consumable2_slot_quantity",
	65:  "task",
	66:  "task_type",
	67:  "task_progress",
	68:  "task_total",
	69:  "inventory_max_items",
	70:  "inventory",
	71:  "inventory_slot1",
	72:  "inventory_slot1_quantity",
	73:  "inventory_slot2",
	74:  "inventory_slot2_quantity",
	75:  "inventory_slot3",
	76:  "inventory_slot3_quantity",
	77:  "inventory_slot4",
	78:  "inventory_slot4_quantity",
	79:  "inventory_slot5",
	80:  "inventory_slot5_quantity",
	81:  "inventory_slot6",
	82:  "inventory_slot6_quantity",
	83:  "inventory_slot7",
	84:  "inventory_slot7_quantity",
	85:  "inventory_slot8",
	86:  "inventory_slot8_quantity",
	87:  "inventory_slot9",
	88:  "inventory_slot9_quantity",
	89:  "inventory_slot10",
	90:  "inventory_slot10_quantity",
	91:  "inventory_slot11",
	92:  "inventory_slot11_quantity",
	93:  "inventory_slot12",
	94:  "inventory_slot12_quantity",
	95:  "inventory_slot13",
	96:  "inventory_slot13_quantity",
	97:  "inventory_slot14",
	98:  "inventory_slot14_quantity",
	99:  "inventory_slot15",
	100: "inventory_slot15_quantity",
	101: "inventory_slot16",
	102: "inventory_slot16_quantity",
	103: "inventory_slot17",
	104: "inventory_slot17_quantity",
	105: "inventory_slot18",
	106: "inventory_slot18_quantity",
	107: "inventory_slot19",
	108: "inventory_slot19_quantity",
	109: "inventory_slot20",
	110: "inventory_slot20_quantity",
}

// Decode decodes TaskDataSchemaCharacter from json.
func (s *TaskDataSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchemaCharacter to nil")
	}
	var requiredBitSet [14]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "total_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.TotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		case "inventory_slot1":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot1 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1\"")
			}
		case "inventory_slot1_quantity":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot1Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1_quantity\"")
			}
		case "inventory_slot2":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot2 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2\"")
			}
		case "inventory_slot2_quantity":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot2Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2_quantity\"")
			}
		case "inventory_slot3":
			requiredBitSet[9] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot3 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3\"")
			}
		case "inventory_slot3_quantity":
			requiredBitSet[9] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot3Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3_quantity\"")
			}
		case "inventory_slot4":
			requiredBitSet[9] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot4 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4\"")
			}
		case "inventory_slot4_quantity":
			requiredBitSet[9] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot4Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4_quantity\"")
			}
		case "inventory_slot5":
			requiredBitSet[9] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot5 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5\"")
			}
		case "inventory_slot5_quantity":
			requiredBitSet[10] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot5Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5_quantity\"")
			}
		case "inventory_slot6":
			requiredBitSet[10] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot6 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6\"")
			}
		case "inventory_slot6_quantity":
			requiredBitSet[10] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot6Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6_quantity\"")
			}
		case "inventory_slot7":
			requiredBitSet[10] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot7 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7\"")
			}
		case "inventory_slot7_quantity":
			requiredBitSet[10] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot7Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7_quantity\"")
			}
		case "inventory_slot8":
			requiredBitSet[10] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot8 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8\"")
			}
		case "inventory_slot8_quantity":
			requiredBitSet[10] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot8Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8_quantity\"")
			}
		case "inventory_slot9":
			requiredBitSet[10] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot9 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9\"")
			}
		case "inventory_slot9_quantity":
			requiredBitSet[11] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot9Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9_quantity\"")
			}
		case "inventory_slot10":
			requiredBitSet[11] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot10 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10\"")
			}
		case "inventory_slot10_quantity":
			requiredBitSet[11] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot10Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10_quantity\"")
			}
		case "inventory_slot11":
			requiredBitSet[11] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot11 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11\"")
			}
		case "inventory_slot11_quantity":
			requiredBitSet[11] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot11Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11_quantity\"")
			}
		case "inventory_slot12":
			requiredBitSet[11] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot12 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12\"")
			}
		case "inventory_slot12_quantity":
			requiredBitSet[11] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot12Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12_quantity\"")
			}
		case "inventory_slot13":
			requiredBitSet[11] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot13 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13\"")
			}
		case "inventory_slot13_quantity":
			requiredBitSet[12] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot13Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13_quantity\"")
			}
		case "inventory_slot14":
			requiredBitSet[12] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot14 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14\"")
			}
		case "inventory_slot14_quantity":
			requiredBitSet[12] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot14Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14_quantity\"")
			}
		case "inventory_slot15":
			requiredBitSet[12] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot15 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15\"")
			}
		case "inventory_slot15_quantity":
			requiredBitSet[12] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot15Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15_quantity\"")
			}
		case "inventory_slot16":
			requiredBitSet[12] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot16 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16\"")
			}
		case "inventory_slot16_quantity":
			requiredBitSet[12] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot16Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16_quantity\"")
			}
		case "inventory_slot17":
			requiredBitSet[12] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot17 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17\"")
			}
		case "inventory_slot17_quantity":
			requiredBitSet[13] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot17Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17_quantity\"")
			}
		case "inventory_slot18":
			requiredBitSet[13] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot18 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18\"")
			}
		case "inventory_slot18_quantity":
			requiredBitSet[13] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot18Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18_quantity\"")
			}
		case "inventory_slot19":
			requiredBitSet[13] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot19 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19\"")
			}
		case "inventory_slot19_quantity":
			requiredBitSet[13] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot19Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19_quantity\"")
			}
		case "inventory_slot20":
			requiredBitSet[13] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot20 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20\"")
			}
		case "inventory_slot20_quantity":
			requiredBitSet[13] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot20Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20_quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskDataSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [14]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b10111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskDataSchemaCharacter) {
					name = jsonFieldsNameOfTaskDataSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskDataSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskDataSchemaCharacterCooldownExpiration as json.
func (s TaskDataSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	switch s.Type {
	case DateTimeTaskDataSchemaCharacterCooldownExpiration:
		json.EncodeDateTime(e, s.DateTime)
	case NullTaskDataSchemaCharacterCooldownExpiration:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes TaskDataSchemaCharacterCooldownExpiration from json.
func (s *TaskDataSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchemaCharacterCooldownExpiration to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullTaskDataSchemaCharacterCooldownExpiration
	case jx.String:
		v, err := json.DecodeDateTime(d)
		s.DateTime = v
		if err != nil {
			return err
		}
		s.Type = DateTimeTaskDataSchemaCharacterCooldownExpiration
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskDataSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskDataSchemaCharacterSkin as json.
func (s TaskDataSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TaskDataSchemaCharacterSkin from json.
func (s *TaskDataSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TaskDataSchemaCharacterSkin(v) {
	case TaskDataSchemaCharacterSkinMen1:
		*s = TaskDataSchemaCharacterSkinMen1
	case TaskDataSchemaCharacterSkinMen2:
		*s = TaskDataSchemaCharacterSkinMen2
	case TaskDataSchemaCharacterSkinMen3:
		*s = TaskDataSchemaCharacterSkinMen3
	case TaskDataSchemaCharacterSkinWomen1:
		*s = TaskDataSchemaCharacterSkinWomen1
	case TaskDataSchemaCharacterSkinWomen2:
		*s = TaskDataSchemaCharacterSkinWomen2
	case TaskDataSchemaCharacterSkinWomen3:
		*s = TaskDataSchemaCharacterSkinWomen3
	default:
		*s = TaskDataSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskDataSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskDataSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskDataSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfTaskDataSchemaCooldown = [4]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "expiration",
	3: "reason",
}

// Decode decodes TaskDataSchemaCooldown from json.
func (s *TaskDataSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskDataSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskDataSchemaCooldown) {
					name = jsonFieldsNameOfTaskDataSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskDataSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskDataSchemaCooldownReason as json.
func (s TaskDataSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TaskDataSchemaCooldownReason from json.
func (s *TaskDataSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TaskDataSchemaCooldownReason(v) {
	case TaskDataSchemaCooldownReasonMovement:
		*s = TaskDataSchemaCooldownReasonMovement
	case TaskDataSchemaCooldownReasonFight:
		*s = TaskDataSchemaCooldownReasonFight
	case TaskDataSchemaCooldownReasonCrafting:
		*s = TaskDataSchemaCooldownReasonCrafting
	case TaskDataSchemaCooldownReasonGathering:
		*s = TaskDataSchemaCooldownReasonGathering
	case TaskDataSchemaCooldownReasonBuyGe:
		*s = TaskDataSchemaCooldownReasonBuyGe
	case TaskDataSchemaCooldownReasonSellGe:
		*s = TaskDataSchemaCooldownReasonSellGe
	case TaskDataSchemaCooldownReasonDeleteItem:
		*s = TaskDataSchemaCooldownReasonDeleteItem
	case TaskDataSchemaCooldownReasonDepositBank:
		*s = TaskDataSchemaCooldownReasonDepositBank
	case TaskDataSchemaCooldownReasonWithdrawBank:
		*s = TaskDataSchemaCooldownReasonWithdrawBank
	case TaskDataSchemaCooldownReasonEquip:
		*s = TaskDataSchemaCooldownReasonEquip
	case TaskDataSchemaCooldownReasonUnequip:
		*s = TaskDataSchemaCooldownReasonUnequip
	case TaskDataSchemaCooldownReasonTask:
		*s = TaskDataSchemaCooldownReasonTask
	case TaskDataSchemaCooldownReasonRecycling:
		*s = TaskDataSchemaCooldownReasonRecycling
	default:
		*s = TaskDataSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskDataSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskDataSchemaTask) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskDataSchemaTask) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
}

var jsonFieldsNameOfTaskDataSchemaTask = [3]string{
	0: "code",
	1: "type",
	2: "total",
}

// Decode decodes TaskDataSchemaTask from json.
func (s *TaskDataSchemaTask) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchemaTask to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskDataSchemaTask")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskDataSchemaTask) {
					name = jsonFieldsNameOfTaskDataSchemaTask[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskDataSchemaTask) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchemaTask) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskDataSchemaTaskType as json.
func (s TaskDataSchemaTaskType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TaskDataSchemaTaskType from json.
func (s *TaskDataSchemaTaskType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchemaTaskType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TaskDataSchemaTaskType(v) {
	case TaskDataSchemaTaskTypeMonsters:
		*s = TaskDataSchemaTaskTypeMonsters
	case TaskDataSchemaTaskTypeResources:
		*s = TaskDataSchemaTaskTypeResources
	case TaskDataSchemaTaskTypeCrafts:
		*s = TaskDataSchemaTaskTypeCrafts
	default:
		*s = TaskDataSchemaTaskType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskDataSchemaTaskType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchemaTaskType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfTaskResponseSchema = [1]string{
	0: "data",
}

// Decode decodes TaskResponseSchema from json.
func (s *TaskResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskResponseSchema) {
					name = jsonFieldsNameOfTaskResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskRewardDataSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskRewardDataSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("reward")
		s.Reward.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfTaskRewardDataSchema = [3]string{
	0: "cooldown",
	1: "reward",
	2: "character",
}

// Decode decodes TaskRewardDataSchema from json.
func (s *TaskRewardDataSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskRewardDataSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "reward":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Reward.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reward\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskRewardDataSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskRewardDataSchema) {
					name = jsonFieldsNameOfTaskRewardDataSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskRewardDataSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskRewardDataSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskRewardDataSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskRewardDataSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("total_xp")
		e.Int(s.TotalXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("consumable1_slot")
		e.Str(s.Consumable1Slot)
	}
	{
		e.FieldStart("consumable1_slot_quantity")
		e.Int(s.Consumable1SlotQuantity)
	}
	{
		e.FieldStart("consumable2_slot")
		e.Str(s.Consumable2Slot)
	}
	{
		e.FieldStart("consumable2_slot_quantity")
		e.Int(s.Consumable2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("inventory_slot1")
		e.Str(s.InventorySlot1)
	}
	{
		e.FieldStart("inventory_slot1_quantity")
		e.Int(s.InventorySlot1Quantity)
	}
	{
		e.FieldStart("inventory_slot2")
		e.Str(s.InventorySlot2)
	}
	{
		e.FieldStart("inventory_slot2_quantity")
		e.Int(s.InventorySlot2Quantity)
	}
	{
		e.FieldStart("inventory_slot3")
		e.Str(s.InventorySlot3)
	}
	{
		e.FieldStart("inventory_slot3_quantity")
		e.Int(s.InventorySlot3Quantity)
	}
	{
		e.FieldStart("inventory_slot4")
		e.Str(s.InventorySlot4)
	}
	{
		e.FieldStart("inventory_slot4_quantity")
		e.Int(s.InventorySlot4Quantity)
	}
	{
		e.FieldStart("inventory_slot5")
		e.Str(s.InventorySlot5)
	}
	{
		e.FieldStart("inventory_slot5_quantity")
		e.Int(s.InventorySlot5Quantity)
	}
	{
		e.FieldStart("inventory_slot6")
		e.Str(s.InventorySlot6)
	}
	{
		e.FieldStart("inventory_slot6_quantity")
		e.Int(s.InventorySlot6Quantity)
	}
	{
		e.FieldStart("inventory_slot7")
		e.Str(s.InventorySlot7)
	}
	{
		e.FieldStart("inventory_slot7_quantity")
		e.Int(s.InventorySlot7Quantity)
	}
	{
		e.FieldStart("inventory_slot8")
		e.Str(s.InventorySlot8)
	}
	{
		e.FieldStart("inventory_slot8_quantity")
		e.Int(s.InventorySlot8Quantity)
	}
	{
		e.FieldStart("inventory_slot9")
		e.Str(s.InventorySlot9)
	}
	{
		e.FieldStart("inventory_slot9_quantity")
		e.Int(s.InventorySlot9Quantity)
	}
	{
		e.FieldStart("inventory_slot10")
		e.Str(s.InventorySlot10)
	}
	{
		e.FieldStart("inventory_slot10_quantity")
		e.Int(s.InventorySlot10Quantity)
	}
	{
		e.FieldStart("inventory_slot11")
		e.Str(s.InventorySlot11)
	}
	{
		e.FieldStart("inventory_slot11_quantity")
		e.Int(s.InventorySlot11Quantity)
	}
	{
		e.FieldStart("inventory_slot12")
		e.Str(s.InventorySlot12)
	}
	{
		e.FieldStart("inventory_slot12_quantity")
		e.Int(s.InventorySlot12Quantity)
	}
	{
		e.FieldStart("inventory_slot13")
		e.Str(s.InventorySlot13)
	}
	{
		e.FieldStart("inventory_slot13_quantity")
		e.Int(s.InventorySlot13Quantity)
	}
	{
		e.FieldStart("inventory_slot14")
		e.Str(s.InventorySlot14)
	}
	{
		e.FieldStart("inventory_slot14_quantity")
		e.Int(s.InventorySlot14Quantity)
	}
	{
		e.FieldStart("inventory_slot15")
		e.Str(s.InventorySlot15)
	}
	{
		e.FieldStart("inventory_slot15_quantity")
		e.Int(s.InventorySlot15Quantity)
	}
	{
		e.FieldStart("inventory_slot16")
		e.Str(s.InventorySlot16)
	}
	{
		e.FieldStart("inventory_slot16_quantity")
		e.Int(s.InventorySlot16Quantity)
	}
	{
		e.FieldStart("inventory_slot17")
		e.Str(s.InventorySlot17)
	}
	{
		e.FieldStart("inventory_slot17_quantity")
		e.Int(s.InventorySlot17Quantity)
	}
	{
		e.FieldStart("inventory_slot18")
		e.Str(s.InventorySlot18)
	}
	{
		e.FieldStart("inventory_slot18_quantity")
		e.Int(s.InventorySlot18Quantity)
	}
	{
		e.FieldStart("inventory_slot19")
		e.Str(s.InventorySlot19)
	}
	{
		e.FieldStart("inventory_slot19_quantity")
		e.Int(s.InventorySlot19Quantity)
	}
	{
		e.FieldStart("inventory_slot20")
		e.Str(s.InventorySlot20)
	}
	{
		e.FieldStart("inventory_slot20_quantity")
		e.Int(s.InventorySlot20Quantity)
	}
}

var jsonFieldsNameOfTaskRewardDataSchemaCharacter = [111]string{
	0:   "name",
	1:   "skin",
	2:   "level",
	3:   "xp",
	4:   "max_xp",
	5:   "total_xp",
	6:   "gold",
	7:   "speed",
	8:   "mining_level",
	9:   "mining_xp",
	10:  "mining_max_xp",
	11:  "woodcutting_level",
	12:  "woodcutting_xp",
	13:  "woodcutting_max_xp",
	14:  "fishing_level",
	15:  "fishing_xp",
	16:  "fishing_max_xp",
	17:  "weaponcrafting_level",
	18:  "weaponcrafting_xp",
	19:  "weaponcrafting_max_xp",
	20:  "gearcrafting_level",
	21:  "gearcrafting_xp",
	22:  "gearcrafting_max_xp",
	23:  "jewelrycrafting_level",
	24:  "jewelrycrafting_xp",
	25:  "jewelrycrafting_max_xp",
	26:  "cooking_level",
	27:  "cooking_xp",
	28:  "cooking_max_xp",
	29:  "hp",
	30:  "haste",
	31:  "critical_strike",
	32:  "stamina",
	33:  "attack_fire",
	34:  "attack_earth",
	35:  "attack_water",
	36:  "attack_air",
	37:  "dmg_fire",
	38:  "dmg_earth",
	39:  "dmg_water",
	40:  "dmg_air",
	41:  "res_fire",
	42:  "res_earth",
	43:  "res_water",
	44:  "res_air",
	45:  "x",
	46:  "y",
	47:  "cooldown",
	48:  "cooldown_expiration",
	49:  "weapon_slot",
	50:  "shield_slot",
	51:  "helmet_slot",
	52:  "body_armor_slot",
	53:  "leg_armor_slot",
	54:  "boots_slot",
	55:  "ring1_slot",
	56:  "ring2_slot",
	57:  "amulet_slot",
	58:  "artifact1_slot",
	59:  "artifact2_slot",
	60:  "artifact3_slot",
	61:  "consumable1_slot",
	62:  "consumable1_slot_quantity",
	63:  "consumable2_slot",
	64:  "consumable2_slot_quantity",
	65:  "task",
	66:  "task_type",
	67:  "task_progress",
	68:  "task_total",
	69:  "inventory_max_items",
	70:  "inventory",
	71:  "inventory_slot1",
	72:  "inventory_slot1_quantity",
	73:  "inventory_slot2",
	74:  "inventory_slot2_quantity",
	75:  "inventory_slot3",
	76:  "inventory_slot3_quantity",
	77:  "inventory_slot4",
	78:  "inventory_slot4_quantity",
	79:  "inventory_slot5",
	80:  "inventory_slot5_quantity",
	81:  "inventory_slot6",
	82:  "inventory_slot6_quantity",
	83:  "inventory_slot7",
	84:  "inventory_slot7_quantity",
	85:  "inventory_slot8",
	86:  "inventory_slot8_quantity",
	87:  "inventory_slot9",
	88:  "inventory_slot9_quantity",
	89:  "inventory_slot10",
	90:  "inventory_slot10_quantity",
	91:  "inventory_slot11",
	92:  "inventory_slot11_quantity",
	93:  "inventory_slot12",
	94:  "inventory_slot12_quantity",
	95:  "inventory_slot13",
	96:  "inventory_slot13_quantity",
	97:  "inventory_slot14",
	98:  "inventory_slot14_quantity",
	99:  "inventory_slot15",
	100: "inventory_slot15_quantity",
	101: "inventory_slot16",
	102: "inventory_slot16_quantity",
	103: "inventory_slot17",
	104: "inventory_slot17_quantity",
	105: "inventory_slot18",
	106: "inventory_slot18_quantity",
	107: "inventory_slot19",
	108: "inventory_slot19_quantity",
	109: "inventory_slot20",
	110: "inventory_slot20_quantity",
}

// Decode decodes TaskRewardDataSchemaCharacter from json.
func (s *TaskRewardDataSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskRewardDataSchemaCharacter to nil")
	}
	var requiredBitSet [14]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "total_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.TotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "hp":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "haste":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "consumable1_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Consumable1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot\"")
			}
		case "consumable1_slot_quantity":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Consumable1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable1_slot_quantity\"")
			}
		case "consumable2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Consumable2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot\"")
			}
		case "consumable2_slot_quantity":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Consumable2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumable2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		case "inventory_slot1":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot1 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1\"")
			}
		case "inventory_slot1_quantity":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot1Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot1_quantity\"")
			}
		case "inventory_slot2":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot2 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2\"")
			}
		case "inventory_slot2_quantity":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot2Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot2_quantity\"")
			}
		case "inventory_slot3":
			requiredBitSet[9] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot3 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3\"")
			}
		case "inventory_slot3_quantity":
			requiredBitSet[9] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot3Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot3_quantity\"")
			}
		case "inventory_slot4":
			requiredBitSet[9] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot4 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4\"")
			}
		case "inventory_slot4_quantity":
			requiredBitSet[9] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot4Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot4_quantity\"")
			}
		case "inventory_slot5":
			requiredBitSet[9] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot5 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5\"")
			}
		case "inventory_slot5_quantity":
			requiredBitSet[10] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot5Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot5_quantity\"")
			}
		case "inventory_slot6":
			requiredBitSet[10] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot6 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6\"")
			}
		case "inventory_slot6_quantity":
			requiredBitSet[10] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot6Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot6_quantity\"")
			}
		case "inventory_slot7":
			requiredBitSet[10] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot7 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7\"")
			}
		case "inventory_slot7_quantity":
			requiredBitSet[10] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot7Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot7_quantity\"")
			}
		case "inventory_slot8":
			requiredBitSet[10] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot8 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8\"")
			}
		case "inventory_slot8_quantity":
			requiredBitSet[10] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot8Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot8_quantity\"")
			}
		case "inventory_slot9":
			requiredBitSet[10] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot9 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9\"")
			}
		case "inventory_slot9_quantity":
			requiredBitSet[11] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot9Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot9_quantity\"")
			}
		case "inventory_slot10":
			requiredBitSet[11] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot10 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10\"")
			}
		case "inventory_slot10_quantity":
			requiredBitSet[11] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot10Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot10_quantity\"")
			}
		case "inventory_slot11":
			requiredBitSet[11] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot11 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11\"")
			}
		case "inventory_slot11_quantity":
			requiredBitSet[11] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot11Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot11_quantity\"")
			}
		case "inventory_slot12":
			requiredBitSet[11] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot12 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12\"")
			}
		case "inventory_slot12_quantity":
			requiredBitSet[11] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot12Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot12_quantity\"")
			}
		case "inventory_slot13":
			requiredBitSet[11] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot13 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13\"")
			}
		case "inventory_slot13_quantity":
			requiredBitSet[12] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot13Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot13_quantity\"")
			}
		case "inventory_slot14":
			requiredBitSet[12] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot14 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14\"")
			}
		case "inventory_slot14_quantity":
			requiredBitSet[12] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot14Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot14_quantity\"")
			}
		case "inventory_slot15":
			requiredBitSet[12] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot15 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15\"")
			}
		case "inventory_slot15_quantity":
			requiredBitSet[12] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot15Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot15_quantity\"")
			}
		case "inventory_slot16":
			requiredBitSet[12] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot16 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16\"")
			}
		case "inventory_slot16_quantity":
			requiredBitSet[12] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot16Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot16_quantity\"")
			}
		case "inventory_slot17":
			requiredBitSet[12] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot17 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17\"")
			}
		case "inventory_slot17_quantity":
			requiredBitSet[13] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot17Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot17_quantity\"")
			}
		case "inventory_slot18":
			requiredBitSet[13] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot18 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18\"")
			}
		case "inventory_slot18_quantity":
			requiredBitSet[13] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot18Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot18_quantity\"")
			}
		case "inventory_slot19":
			requiredBitSet[13] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot19 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19\"")
			}
		case "inventory_slot19_quantity":
			requiredBitSet[13] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot19Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot19_quantity\"")
			}
		case "inventory_slot20":
			requiredBitSet[13] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.InventorySlot20 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20\"")
			}
		case "inventory_slot20_quantity":
			requiredBitSet[13] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.InventorySlot20Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_slot20_quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskRewardDataSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [14]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111110,
		0b11111111,
		0b10111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskRewardDataSchemaCharacter) {
					name = jsonFieldsNameOfTaskRewardDataSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskRewardDataSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskRewardDataSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskRewardDataSchemaCharacterCooldownExpiration as json.
func (s TaskRewardDataSchemaCharacterCooldownExpiration) Encode(e *jx.Encoder) {
	switch s.Type {
	case DateTimeTaskRewardDataSchemaCharacterCooldownExpiration:
		json.EncodeDateTime(e, s.DateTime)
	case NullTaskRewardDataSchemaCharacterCooldownExpiration:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes TaskRewardDataSchemaCharacterCooldownExpiration from json.
func (s *TaskRewardDataSchemaCharacterCooldownExpiration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskRewardDataSchemaCharacterCooldownExpiration to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullTaskRewardDataSchemaCharacterCooldownExpiration
	case jx.String:
		v, err := json.DecodeDateTime(d)
		s.DateTime = v
		if err != nil {
			return err
		}
		s.Type = DateTimeTaskRewardDataSchemaCharacterCooldownExpiration
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskRewardDataSchemaCharacterCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskRewardDataSchemaCharacterCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskRewardDataSchemaCharacterSkin as json.
func (s TaskRewardDataSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TaskRewardDataSchemaCharacterSkin from json.
func (s *TaskRewardDataSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskRewardDataSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TaskRewardDataSchemaCharacterSkin(v) {
	case TaskRewardDataSchemaCharacterSkinMen1:
		*s = TaskRewardDataSchemaCharacterSkinMen1
	case TaskRewardDataSchemaCharacterSkinMen2:
		*s = TaskRewardDataSchemaCharacterSkinMen2
	case TaskRewardDataSchemaCharacterSkinMen3:
		*s = TaskRewardDataSchemaCharacterSkinMen3
	case TaskRewardDataSchemaCharacterSkinWomen1:
		*s = TaskRewardDataSchemaCharacterSkinWomen1
	case TaskRewardDataSchemaCharacterSkinWomen2:
		*s = TaskRewardDataSchemaCharacterSkinWomen2
	case TaskRewardDataSchemaCharacterSkinWomen3:
		*s = TaskRewardDataSchemaCharacterSkinWomen3
	default:
		*s = TaskRewardDataSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskRewardDataSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskRewardDataSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskRewardDataSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskRewardDataSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfTaskRewardDataSchemaCooldown = [4]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "expiration",
	3: "reason",
}

// Decode decodes TaskRewardDataSchemaCooldown from json.
func (s *TaskRewardDataSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskRewardDataSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskRewardDataSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskRewardDataSchemaCooldown) {
					name = jsonFieldsNameOfTaskRewardDataSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskRewardDataSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskRewardDataSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskRewardDataSchemaCooldownReason as json.
func (s TaskRewardDataSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TaskRewardDataSchemaCooldownReason from json.
func (s *TaskRewardDataSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskRewardDataSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TaskRewardDataSchemaCooldownReason(v) {
	case TaskRewardDataSchemaCooldownReasonMovement:
		*s = TaskRewardDataSchemaCooldownReasonMovement
	case TaskRewardDataSchemaCooldownReasonFight:
		*s = TaskRewardDataSchemaCooldownReasonFight
	case TaskRewardDataSchemaCooldownReasonCrafting:
		*s = TaskRewardDataSchemaCooldownReasonCrafting
	case TaskRewardDataSchemaCooldownReasonGathering:
		*s = TaskRewardDataSchemaCooldownReasonGathering
	case TaskRewardDataSchemaCooldownReasonBuyGe:
		*s = TaskRewardDataSchemaCooldownReasonBuyGe
	case TaskRewardDataSchemaCooldownReasonSellGe:
		*s = TaskRewardDataSchemaCooldownReasonSellGe
	case TaskRewardDataSchemaCooldownReasonDeleteItem:
		*s = TaskRewardDataSchemaCooldownReasonDeleteItem
	case TaskRewardDataSchemaCooldownReasonDepositBank:
		*s = TaskRewardDataSchemaCooldownReasonDepositBank
	case TaskRewardDataSchemaCooldownReasonWithdrawBank:
		*s = TaskRewardDataSchemaCooldownReasonWithdrawBank
	case TaskRewardDataSchemaCooldownReasonEquip:
		*s = TaskRewardDataSchemaCooldownReasonEquip
	case TaskRewardDataSchemaCooldownReasonUnequip:
		*s = TaskRewardDataSchemaCooldownReasonUnequip
	case TaskRewardDataSchemaCooldownReasonTask:
		*s = TaskRewardDataSchemaCooldownReasonTask
	case TaskRewardDataSchemaCooldownReasonRecycling:
		*s = TaskRewardDataSchemaCooldownReasonRecycling
	default:
		*s = TaskRewardDataSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskRewardDataSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskRewardDataSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskRewardDataSchemaReward) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskRewardDataSchemaReward) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfTaskRewardDataSchemaReward = [2]string{
	0: "code",
	1: "quantity",
}

// Decode decodes TaskRewardDataSchemaReward from json.
func (s *TaskRewardDataSchemaReward) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskRewardDataSchemaReward to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskRewardDataSchemaReward")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskRewardDataSchemaReward) {
					name = jsonFieldsNameOfTaskRewardDataSchemaReward[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskRewardDataSchemaReward) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskRewardDataSchemaReward) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskRewardResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskRewardResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfTaskRewardResponseSchema = [1]string{
	0: "data",
}

// Decode decodes TaskRewardResponseSchema from json.
func (s *TaskRewardResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskRewardResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskRewardResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskRewardResponseSchema) {
					name = jsonFieldsNameOfTaskRewardResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskRewardResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskRewardResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TokenResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TokenResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
}

var jsonFieldsNameOfTokenResponseSchema = [1]string{
	0: "token",
}

// Decode decodes TokenResponseSchema from json.
func (s *TokenResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TokenResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TokenResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTokenResponseSchema) {
					name = jsonFieldsNameOfTokenResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TokenResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TokenResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnequipSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnequipSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("slot")
		s.Slot.Encode(e)
	}
}

var jsonFieldsNameOfUnequipSchema = [1]string{
	0: "slot",
}

// Decode decodes UnequipSchema from json.
func (s *UnequipSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnequipSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "slot":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Slot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slot\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnequipSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnequipSchema) {
					name = jsonFieldsNameOfUnequipSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnequipSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnequipSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnequipSchemaSlot as json.
func (s UnequipSchemaSlot) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UnequipSchemaSlot from json.
func (s *UnequipSchemaSlot) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnequipSchemaSlot to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UnequipSchemaSlot(v) {
	case UnequipSchemaSlotWeapon:
		*s = UnequipSchemaSlotWeapon
	case UnequipSchemaSlotShield:
		*s = UnequipSchemaSlotShield
	case UnequipSchemaSlotHelmet:
		*s = UnequipSchemaSlotHelmet
	case UnequipSchemaSlotBodyArmor:
		*s = UnequipSchemaSlotBodyArmor
	case UnequipSchemaSlotLegArmor:
		*s = UnequipSchemaSlotLegArmor
	case UnequipSchemaSlotBoots:
		*s = UnequipSchemaSlotBoots
	case UnequipSchemaSlotRing1:
		*s = UnequipSchemaSlotRing1
	case UnequipSchemaSlotRing2:
		*s = UnequipSchemaSlotRing2
	case UnequipSchemaSlotAmulet:
		*s = UnequipSchemaSlotAmulet
	case UnequipSchemaSlotArtifact1:
		*s = UnequipSchemaSlotArtifact1
	case UnequipSchemaSlotArtifact2:
		*s = UnequipSchemaSlotArtifact2
	case UnequipSchemaSlotArtifact3:
		*s = UnequipSchemaSlotArtifact3
	case UnequipSchemaSlotConsumable1:
		*s = UnequipSchemaSlotConsumable1
	case UnequipSchemaSlotConsumable2:
		*s = UnequipSchemaSlotConsumable2
	default:
		*s = UnequipSchemaSlot(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UnequipSchemaSlot) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnequipSchemaSlot) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
