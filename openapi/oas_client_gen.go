// Code generated by ogen, DO NOT EDIT.

package openapi

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.19.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// ActionAcceptNewTaskMyNameActionTaskNewPost invokes action_accept_new_task_my__name__action_task_new_post operation.
	//
	// Accepting a new task.
	//
	// POST /my/{name}/action/task/new
	ActionAcceptNewTaskMyNameActionTaskNewPost(ctx context.Context, params ActionAcceptNewTaskMyNameActionTaskNewPostParams) (ActionAcceptNewTaskMyNameActionTaskNewPostRes, error)
	// ActionCompleteTaskMyNameActionTaskCompletePost invokes action_complete_task_my__name__action_task_complete_post operation.
	//
	// Complete a task.
	//
	// POST /my/{name}/action/task/complete
	ActionCompleteTaskMyNameActionTaskCompletePost(ctx context.Context, params ActionCompleteTaskMyNameActionTaskCompletePostParams) (ActionCompleteTaskMyNameActionTaskCompletePostRes, error)
	// ActionCraftingMyNameActionCraftingPost invokes action_crafting_my__name__action_crafting_post operation.
	//
	// Crafting an item. The character must be on a map with a workshop.
	//
	// POST /my/{name}/action/crafting
	ActionCraftingMyNameActionCraftingPost(ctx context.Context, request *CraftingSchema, params ActionCraftingMyNameActionCraftingPostParams) (ActionCraftingMyNameActionCraftingPostRes, error)
	// ActionDeleteItemMyNameActionDeletePost invokes action_delete_item_my__name__action_delete_post operation.
	//
	// Delete an item from your character's inventory.
	//
	// POST /my/{name}/action/delete
	ActionDeleteItemMyNameActionDeletePost(ctx context.Context, request *SimpleItemSchema, params ActionDeleteItemMyNameActionDeletePostParams) (ActionDeleteItemMyNameActionDeletePostRes, error)
	// ActionDepositBankGoldMyNameActionBankDepositGoldPost invokes action_deposit_bank_gold_my__name__action_bank_deposit_gold_post operation.
	//
	// Deposit golds in a bank on the character's map.
	//
	// POST /my/{name}/action/bank/deposit/gold
	ActionDepositBankGoldMyNameActionBankDepositGoldPost(ctx context.Context, request *DepositWithdrawGoldSchema, params ActionDepositBankGoldMyNameActionBankDepositGoldPostParams) (ActionDepositBankGoldMyNameActionBankDepositGoldPostRes, error)
	// ActionDepositBankMyNameActionBankDepositPost invokes action_deposit_bank_my__name__action_bank_deposit_post operation.
	//
	// Deposit an item in a bank on the character's map.
	//
	// POST /my/{name}/action/bank/deposit
	ActionDepositBankMyNameActionBankDepositPost(ctx context.Context, request *SimpleItemSchema, params ActionDepositBankMyNameActionBankDepositPostParams) (ActionDepositBankMyNameActionBankDepositPostRes, error)
	// ActionEquipItemMyNameActionEquipPost invokes action_equip_item_my__name__action_equip_post operation.
	//
	// Equip an item on your character.
	//
	// POST /my/{name}/action/equip
	ActionEquipItemMyNameActionEquipPost(ctx context.Context, request *EquipSchema, params ActionEquipItemMyNameActionEquipPostParams) (ActionEquipItemMyNameActionEquipPostRes, error)
	// ActionFightMyNameActionFightPost invokes action_fight_my__name__action_fight_post operation.
	//
	// Start a fight against a monster on the character's map.
	//
	// POST /my/{name}/action/fight
	ActionFightMyNameActionFightPost(ctx context.Context, params ActionFightMyNameActionFightPostParams) (ActionFightMyNameActionFightPostRes, error)
	// ActionGatheringMyNameActionGatheringPost invokes action_gathering_my__name__action_gathering_post operation.
	//
	// Harvest a resource on the character's map.
	//
	// POST /my/{name}/action/gathering
	ActionGatheringMyNameActionGatheringPost(ctx context.Context, params ActionGatheringMyNameActionGatheringPostParams) (ActionGatheringMyNameActionGatheringPostRes, error)
	// ActionGeBuyItemMyNameActionGeBuyPost invokes action_ge_buy_item_my__name__action_ge_buy_post operation.
	//
	// Buy an item at the Grand Exchange on the character's map.
	//
	// POST /my/{name}/action/ge/buy
	ActionGeBuyItemMyNameActionGeBuyPost(ctx context.Context, request *GETransactionItemSchema, params ActionGeBuyItemMyNameActionGeBuyPostParams) (ActionGeBuyItemMyNameActionGeBuyPostRes, error)
	// ActionGeSellItemMyNameActionGeSellPost invokes action_ge_sell_item_my__name__action_ge_sell_post operation.
	//
	// Sell an item at the Grand Exchange on the character's map.
	//
	// POST /my/{name}/action/ge/sell
	ActionGeSellItemMyNameActionGeSellPost(ctx context.Context, request *GETransactionItemSchema, params ActionGeSellItemMyNameActionGeSellPostParams) (ActionGeSellItemMyNameActionGeSellPostRes, error)
	// ActionMoveMyNameActionMovePost invokes action_move_my__name__action_move_post operation.
	//
	// Moves a character on the map using the map's X and Y position.
	//
	// POST /my/{name}/action/move
	ActionMoveMyNameActionMovePost(ctx context.Context, request *DestinationSchema, params ActionMoveMyNameActionMovePostParams) (ActionMoveMyNameActionMovePostRes, error)
	// ActionRecyclingMyNameActionRecyclingPost invokes action_recycling_my__name__action_recycling_post operation.
	//
	// Recyling an item. The character must be on a map with a workshop (only for equipments and weapons).
	//
	// POST /my/{name}/action/recycling
	ActionRecyclingMyNameActionRecyclingPost(ctx context.Context, request *RecyclingSchema, params ActionRecyclingMyNameActionRecyclingPostParams) (ActionRecyclingMyNameActionRecyclingPostRes, error)
	// ActionTaskExchangeMyNameActionTaskExchangePost invokes action_task_exchange_my__name__action_task_exchange_post operation.
	//
	// Exchange 3 tasks coins for a random reward. Rewards are exclusive resources for crafting  items.
	//
	// POST /my/{name}/action/task/exchange
	ActionTaskExchangeMyNameActionTaskExchangePost(ctx context.Context, params ActionTaskExchangeMyNameActionTaskExchangePostParams) (ActionTaskExchangeMyNameActionTaskExchangePostRes, error)
	// ActionUnequipItemMyNameActionUnequipPost invokes action_unequip_item_my__name__action_unequip_post operation.
	//
	// Unequip an item on your character.
	//
	// POST /my/{name}/action/unequip
	ActionUnequipItemMyNameActionUnequipPost(ctx context.Context, request *UnequipSchema, params ActionUnequipItemMyNameActionUnequipPostParams) (ActionUnequipItemMyNameActionUnequipPostRes, error)
	// ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPost invokes action_withdraw_bank_gold_my__name__action_bank_withdraw_gold_post operation.
	//
	// Withdraw gold from your bank.
	//
	// POST /my/{name}/action/bank/withdraw/gold
	ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPost(ctx context.Context, request *DepositWithdrawGoldSchema, params ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostParams) (ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostRes, error)
	// ActionWithdrawBankMyNameActionBankWithdrawPost invokes action_withdraw_bank_my__name__action_bank_withdraw_post operation.
	//
	// Take an item from your bank and put it in the character's inventory.
	//
	// POST /my/{name}/action/bank/withdraw
	ActionWithdrawBankMyNameActionBankWithdrawPost(ctx context.Context, request *SimpleItemSchema, params ActionWithdrawBankMyNameActionBankWithdrawPostParams) (ActionWithdrawBankMyNameActionBankWithdrawPostRes, error)
	// ChangePasswordMyChangePasswordPost invokes change_password_my_change_password_post operation.
	//
	// Change your account password. Changing the password reset the account token.
	//
	// POST /my/change_password
	ChangePasswordMyChangePasswordPost(ctx context.Context, request *ChangePassword) (ChangePasswordMyChangePasswordPostRes, error)
	// CreateAccountAccountsCreatePost invokes create_account_accounts_create_post operation.
	//
	// Create an account.
	//
	// POST /accounts/create
	CreateAccountAccountsCreatePost(ctx context.Context, request *AddAccountSchema) (CreateAccountAccountsCreatePostRes, error)
	// CreateCharacterCharactersCreatePost invokes create_character_characters_create_post operation.
	//
	// Create new character on your account. You can create up to 5 characters.
	//
	// POST /characters/create
	CreateCharacterCharactersCreatePost(ctx context.Context, request *AddCharacterSchema) (CreateCharacterCharactersCreatePostRes, error)
	// GenerateTokenTokenPost invokes generate_token_token__post operation.
	//
	// Use your account as HTTPBasic Auth to generate your token to use the API. You can also generate
	// your token directly on the website.
	//
	// POST /token/
	GenerateTokenTokenPost(ctx context.Context) (GenerateTokenTokenPostRes, error)
	// GetAllCharactersCharactersGet invokes get_all_characters_characters__get operation.
	//
	// Fetch characters details.
	//
	// GET /characters/
	GetAllCharactersCharactersGet(ctx context.Context, params GetAllCharactersCharactersGetParams) (GetAllCharactersCharactersGetRes, error)
	// GetAllCharactersLogsMyLogsGet invokes get_all_characters_logs_my_logs_get operation.
	//
	// History of the last 100 actions of all your characters.
	//
	// GET /my/logs
	GetAllCharactersLogsMyLogsGet(ctx context.Context, params GetAllCharactersLogsMyLogsGetParams) (GetAllCharactersLogsMyLogsGetRes, error)
	// GetAllEventsEventsGet invokes get_all_events_events__get operation.
	//
	// Fetch events details.
	//
	// GET /events/
	GetAllEventsEventsGet(ctx context.Context, params GetAllEventsEventsGetParams) (GetAllEventsEventsGetRes, error)
	// GetAllGeItemsGeGet invokes get_all_ge_items_ge__get operation.
	//
	// Fetch Grand Exchange items details.
	//
	// GET /ge/
	GetAllGeItemsGeGet(ctx context.Context, params GetAllGeItemsGeGetParams) (GetAllGeItemsGeGetRes, error)
	// GetAllItemsItemsGet invokes get_all_items_items__get operation.
	//
	// Fetch items details.
	//
	// GET /items/
	GetAllItemsItemsGet(ctx context.Context, params GetAllItemsItemsGetParams) (GetAllItemsItemsGetRes, error)
	// GetAllMapsMapsGet invokes get_all_maps_maps__get operation.
	//
	// Fetch maps details.
	//
	// GET /maps/
	GetAllMapsMapsGet(ctx context.Context, params GetAllMapsMapsGetParams) (GetAllMapsMapsGetRes, error)
	// GetAllMonstersMonstersGet invokes get_all_monsters_monsters__get operation.
	//
	// Fetch monsters details.
	//
	// GET /monsters/
	GetAllMonstersMonstersGet(ctx context.Context, params GetAllMonstersMonstersGetParams) (GetAllMonstersMonstersGetRes, error)
	// GetAllResourcesResourcesGet invokes get_all_resources_resources__get operation.
	//
	// Fetch resources details.
	//
	// GET /resources/
	GetAllResourcesResourcesGet(ctx context.Context, params GetAllResourcesResourcesGetParams) (GetAllResourcesResourcesGetRes, error)
	// GetBankGoldsMyBankGoldGet invokes get_bank_golds_my_bank_gold_get operation.
	//
	// Fetch golds in your bank.
	//
	// GET /my/bank/gold
	GetBankGoldsMyBankGoldGet(ctx context.Context) (*GoldBankResponseSchema, error)
	// GetBankItemsMyBankItemsGet invokes get_bank_items_my_bank_items_get operation.
	//
	// Fetch all items in your bank.
	//
	// GET /my/bank/items
	GetBankItemsMyBankItemsGet(ctx context.Context, params GetBankItemsMyBankItemsGetParams) (GetBankItemsMyBankItemsGetRes, error)
	// GetCharacterCharactersNameGet invokes get_character_characters__name__get operation.
	//
	// Retrieve the details of a character.
	//
	// GET /characters/{name}
	GetCharacterCharactersNameGet(ctx context.Context, params GetCharacterCharactersNameGetParams) (GetCharacterCharactersNameGetRes, error)
	// GetCharacterLogsMyNameLogsGet invokes get_character_logs_my__name__logs_get operation.
	//
	// History of your character's last 100 actions.
	//
	// GET /my/{name}/logs
	GetCharacterLogsMyNameLogsGet(ctx context.Context, params GetCharacterLogsMyNameLogsGetParams) (GetCharacterLogsMyNameLogsGetRes, error)
	// GetGeItemGeCodeGet invokes get_ge_item_ge__code__get operation.
	//
	// Retrieve the details of a Grand Exchange item.
	//
	// GET /ge/{code}
	GetGeItemGeCodeGet(ctx context.Context, params GetGeItemGeCodeGetParams) (GetGeItemGeCodeGetRes, error)
	// GetItemItemsCodeGet invokes get_item_items__code__get operation.
	//
	// Retrieve the details of a item.
	//
	// GET /items/{code}
	GetItemItemsCodeGet(ctx context.Context, params GetItemItemsCodeGetParams) (GetItemItemsCodeGetRes, error)
	// GetMapMapsXYGet invokes get_map_maps__x___y__get operation.
	//
	// Retrieve the details of a map.
	//
	// GET /maps/{x}/{y}
	GetMapMapsXYGet(ctx context.Context, params GetMapMapsXYGetParams) (GetMapMapsXYGetRes, error)
	// GetMonsterMonstersCodeGet invokes get_monster_monsters__code__get operation.
	//
	// Retrieve the details of a monster.
	//
	// GET /monsters/{code}
	GetMonsterMonstersCodeGet(ctx context.Context, params GetMonsterMonstersCodeGetParams) (GetMonsterMonstersCodeGetRes, error)
	// GetMyCharactersMyCharactersGet invokes get_my_characters_my_characters_get operation.
	//
	// List of your characters.
	//
	// GET /my/characters
	GetMyCharactersMyCharactersGet(ctx context.Context) (GetMyCharactersMyCharactersGetRes, error)
	// GetResourcesResourcesCodeGet invokes get_resources_resources__code__get operation.
	//
	// Retrieve the details of a resource.
	//
	// GET /resources/{code}
	GetResourcesResourcesCodeGet(ctx context.Context, params GetResourcesResourcesCodeGetParams) (GetResourcesResourcesCodeGetRes, error)
	// GetStatusGet invokes get_status__get operation.
	//
	// Return the status of the game server.
	//
	// GET /
	GetStatusGet(ctx context.Context) (*StatusResponseSchema, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

var _ Handler = struct {
	*Client
}{}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// ActionAcceptNewTaskMyNameActionTaskNewPost invokes action_accept_new_task_my__name__action_task_new_post operation.
//
// Accepting a new task.
//
// POST /my/{name}/action/task/new
func (c *Client) ActionAcceptNewTaskMyNameActionTaskNewPost(ctx context.Context, params ActionAcceptNewTaskMyNameActionTaskNewPostParams) (ActionAcceptNewTaskMyNameActionTaskNewPostRes, error) {
	res, err := c.sendActionAcceptNewTaskMyNameActionTaskNewPost(ctx, params)
	return res, err
}

func (c *Client) sendActionAcceptNewTaskMyNameActionTaskNewPost(ctx context.Context, params ActionAcceptNewTaskMyNameActionTaskNewPostParams) (res ActionAcceptNewTaskMyNameActionTaskNewPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_accept_new_task_my__name__action_task_new_post"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/task/new"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionAcceptNewTaskMyNameActionTaskNewPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/task/new"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionAcceptNewTaskMyNameActionTaskNewPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionAcceptNewTaskMyNameActionTaskNewPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionCompleteTaskMyNameActionTaskCompletePost invokes action_complete_task_my__name__action_task_complete_post operation.
//
// Complete a task.
//
// POST /my/{name}/action/task/complete
func (c *Client) ActionCompleteTaskMyNameActionTaskCompletePost(ctx context.Context, params ActionCompleteTaskMyNameActionTaskCompletePostParams) (ActionCompleteTaskMyNameActionTaskCompletePostRes, error) {
	res, err := c.sendActionCompleteTaskMyNameActionTaskCompletePost(ctx, params)
	return res, err
}

func (c *Client) sendActionCompleteTaskMyNameActionTaskCompletePost(ctx context.Context, params ActionCompleteTaskMyNameActionTaskCompletePostParams) (res ActionCompleteTaskMyNameActionTaskCompletePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_complete_task_my__name__action_task_complete_post"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/task/complete"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionCompleteTaskMyNameActionTaskCompletePost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/task/complete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionCompleteTaskMyNameActionTaskCompletePost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionCompleteTaskMyNameActionTaskCompletePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionCraftingMyNameActionCraftingPost invokes action_crafting_my__name__action_crafting_post operation.
//
// Crafting an item. The character must be on a map with a workshop.
//
// POST /my/{name}/action/crafting
func (c *Client) ActionCraftingMyNameActionCraftingPost(ctx context.Context, request *CraftingSchema, params ActionCraftingMyNameActionCraftingPostParams) (ActionCraftingMyNameActionCraftingPostRes, error) {
	res, err := c.sendActionCraftingMyNameActionCraftingPost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionCraftingMyNameActionCraftingPost(ctx context.Context, request *CraftingSchema, params ActionCraftingMyNameActionCraftingPostParams) (res ActionCraftingMyNameActionCraftingPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_crafting_my__name__action_crafting_post"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/crafting"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionCraftingMyNameActionCraftingPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/crafting"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionCraftingMyNameActionCraftingPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionCraftingMyNameActionCraftingPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionCraftingMyNameActionCraftingPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionDeleteItemMyNameActionDeletePost invokes action_delete_item_my__name__action_delete_post operation.
//
// Delete an item from your character's inventory.
//
// POST /my/{name}/action/delete
func (c *Client) ActionDeleteItemMyNameActionDeletePost(ctx context.Context, request *SimpleItemSchema, params ActionDeleteItemMyNameActionDeletePostParams) (ActionDeleteItemMyNameActionDeletePostRes, error) {
	res, err := c.sendActionDeleteItemMyNameActionDeletePost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionDeleteItemMyNameActionDeletePost(ctx context.Context, request *SimpleItemSchema, params ActionDeleteItemMyNameActionDeletePostParams) (res ActionDeleteItemMyNameActionDeletePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_delete_item_my__name__action_delete_post"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/delete"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionDeleteItemMyNameActionDeletePost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionDeleteItemMyNameActionDeletePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionDeleteItemMyNameActionDeletePost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionDeleteItemMyNameActionDeletePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionDepositBankGoldMyNameActionBankDepositGoldPost invokes action_deposit_bank_gold_my__name__action_bank_deposit_gold_post operation.
//
// Deposit golds in a bank on the character's map.
//
// POST /my/{name}/action/bank/deposit/gold
func (c *Client) ActionDepositBankGoldMyNameActionBankDepositGoldPost(ctx context.Context, request *DepositWithdrawGoldSchema, params ActionDepositBankGoldMyNameActionBankDepositGoldPostParams) (ActionDepositBankGoldMyNameActionBankDepositGoldPostRes, error) {
	res, err := c.sendActionDepositBankGoldMyNameActionBankDepositGoldPost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionDepositBankGoldMyNameActionBankDepositGoldPost(ctx context.Context, request *DepositWithdrawGoldSchema, params ActionDepositBankGoldMyNameActionBankDepositGoldPostParams) (res ActionDepositBankGoldMyNameActionBankDepositGoldPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_deposit_bank_gold_my__name__action_bank_deposit_gold_post"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/bank/deposit/gold"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionDepositBankGoldMyNameActionBankDepositGoldPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/bank/deposit/gold"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionDepositBankGoldMyNameActionBankDepositGoldPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionDepositBankGoldMyNameActionBankDepositGoldPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionDepositBankGoldMyNameActionBankDepositGoldPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionDepositBankMyNameActionBankDepositPost invokes action_deposit_bank_my__name__action_bank_deposit_post operation.
//
// Deposit an item in a bank on the character's map.
//
// POST /my/{name}/action/bank/deposit
func (c *Client) ActionDepositBankMyNameActionBankDepositPost(ctx context.Context, request *SimpleItemSchema, params ActionDepositBankMyNameActionBankDepositPostParams) (ActionDepositBankMyNameActionBankDepositPostRes, error) {
	res, err := c.sendActionDepositBankMyNameActionBankDepositPost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionDepositBankMyNameActionBankDepositPost(ctx context.Context, request *SimpleItemSchema, params ActionDepositBankMyNameActionBankDepositPostParams) (res ActionDepositBankMyNameActionBankDepositPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_deposit_bank_my__name__action_bank_deposit_post"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/bank/deposit"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionDepositBankMyNameActionBankDepositPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/bank/deposit"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionDepositBankMyNameActionBankDepositPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionDepositBankMyNameActionBankDepositPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionDepositBankMyNameActionBankDepositPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionEquipItemMyNameActionEquipPost invokes action_equip_item_my__name__action_equip_post operation.
//
// Equip an item on your character.
//
// POST /my/{name}/action/equip
func (c *Client) ActionEquipItemMyNameActionEquipPost(ctx context.Context, request *EquipSchema, params ActionEquipItemMyNameActionEquipPostParams) (ActionEquipItemMyNameActionEquipPostRes, error) {
	res, err := c.sendActionEquipItemMyNameActionEquipPost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionEquipItemMyNameActionEquipPost(ctx context.Context, request *EquipSchema, params ActionEquipItemMyNameActionEquipPostParams) (res ActionEquipItemMyNameActionEquipPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_equip_item_my__name__action_equip_post"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/equip"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionEquipItemMyNameActionEquipPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/equip"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionEquipItemMyNameActionEquipPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionEquipItemMyNameActionEquipPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionEquipItemMyNameActionEquipPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionFightMyNameActionFightPost invokes action_fight_my__name__action_fight_post operation.
//
// Start a fight against a monster on the character's map.
//
// POST /my/{name}/action/fight
func (c *Client) ActionFightMyNameActionFightPost(ctx context.Context, params ActionFightMyNameActionFightPostParams) (ActionFightMyNameActionFightPostRes, error) {
	res, err := c.sendActionFightMyNameActionFightPost(ctx, params)
	return res, err
}

func (c *Client) sendActionFightMyNameActionFightPost(ctx context.Context, params ActionFightMyNameActionFightPostParams) (res ActionFightMyNameActionFightPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_fight_my__name__action_fight_post"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/fight"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionFightMyNameActionFightPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/fight"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionFightMyNameActionFightPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionFightMyNameActionFightPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionGatheringMyNameActionGatheringPost invokes action_gathering_my__name__action_gathering_post operation.
//
// Harvest a resource on the character's map.
//
// POST /my/{name}/action/gathering
func (c *Client) ActionGatheringMyNameActionGatheringPost(ctx context.Context, params ActionGatheringMyNameActionGatheringPostParams) (ActionGatheringMyNameActionGatheringPostRes, error) {
	res, err := c.sendActionGatheringMyNameActionGatheringPost(ctx, params)
	return res, err
}

func (c *Client) sendActionGatheringMyNameActionGatheringPost(ctx context.Context, params ActionGatheringMyNameActionGatheringPostParams) (res ActionGatheringMyNameActionGatheringPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_gathering_my__name__action_gathering_post"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/gathering"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionGatheringMyNameActionGatheringPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/gathering"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionGatheringMyNameActionGatheringPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionGatheringMyNameActionGatheringPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionGeBuyItemMyNameActionGeBuyPost invokes action_ge_buy_item_my__name__action_ge_buy_post operation.
//
// Buy an item at the Grand Exchange on the character's map.
//
// POST /my/{name}/action/ge/buy
func (c *Client) ActionGeBuyItemMyNameActionGeBuyPost(ctx context.Context, request *GETransactionItemSchema, params ActionGeBuyItemMyNameActionGeBuyPostParams) (ActionGeBuyItemMyNameActionGeBuyPostRes, error) {
	res, err := c.sendActionGeBuyItemMyNameActionGeBuyPost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionGeBuyItemMyNameActionGeBuyPost(ctx context.Context, request *GETransactionItemSchema, params ActionGeBuyItemMyNameActionGeBuyPostParams) (res ActionGeBuyItemMyNameActionGeBuyPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_ge_buy_item_my__name__action_ge_buy_post"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/ge/buy"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionGeBuyItemMyNameActionGeBuyPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/ge/buy"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionGeBuyItemMyNameActionGeBuyPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionGeBuyItemMyNameActionGeBuyPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionGeBuyItemMyNameActionGeBuyPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionGeSellItemMyNameActionGeSellPost invokes action_ge_sell_item_my__name__action_ge_sell_post operation.
//
// Sell an item at the Grand Exchange on the character's map.
//
// POST /my/{name}/action/ge/sell
func (c *Client) ActionGeSellItemMyNameActionGeSellPost(ctx context.Context, request *GETransactionItemSchema, params ActionGeSellItemMyNameActionGeSellPostParams) (ActionGeSellItemMyNameActionGeSellPostRes, error) {
	res, err := c.sendActionGeSellItemMyNameActionGeSellPost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionGeSellItemMyNameActionGeSellPost(ctx context.Context, request *GETransactionItemSchema, params ActionGeSellItemMyNameActionGeSellPostParams) (res ActionGeSellItemMyNameActionGeSellPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_ge_sell_item_my__name__action_ge_sell_post"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/ge/sell"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionGeSellItemMyNameActionGeSellPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/ge/sell"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionGeSellItemMyNameActionGeSellPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionGeSellItemMyNameActionGeSellPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionGeSellItemMyNameActionGeSellPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionMoveMyNameActionMovePost invokes action_move_my__name__action_move_post operation.
//
// Moves a character on the map using the map's X and Y position.
//
// POST /my/{name}/action/move
func (c *Client) ActionMoveMyNameActionMovePost(ctx context.Context, request *DestinationSchema, params ActionMoveMyNameActionMovePostParams) (ActionMoveMyNameActionMovePostRes, error) {
	res, err := c.sendActionMoveMyNameActionMovePost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionMoveMyNameActionMovePost(ctx context.Context, request *DestinationSchema, params ActionMoveMyNameActionMovePostParams) (res ActionMoveMyNameActionMovePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_move_my__name__action_move_post"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/move"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionMoveMyNameActionMovePost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/move"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionMoveMyNameActionMovePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionMoveMyNameActionMovePost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionMoveMyNameActionMovePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionRecyclingMyNameActionRecyclingPost invokes action_recycling_my__name__action_recycling_post operation.
//
// Recyling an item. The character must be on a map with a workshop (only for equipments and weapons).
//
// POST /my/{name}/action/recycling
func (c *Client) ActionRecyclingMyNameActionRecyclingPost(ctx context.Context, request *RecyclingSchema, params ActionRecyclingMyNameActionRecyclingPostParams) (ActionRecyclingMyNameActionRecyclingPostRes, error) {
	res, err := c.sendActionRecyclingMyNameActionRecyclingPost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionRecyclingMyNameActionRecyclingPost(ctx context.Context, request *RecyclingSchema, params ActionRecyclingMyNameActionRecyclingPostParams) (res ActionRecyclingMyNameActionRecyclingPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_recycling_my__name__action_recycling_post"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/recycling"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionRecyclingMyNameActionRecyclingPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/recycling"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionRecyclingMyNameActionRecyclingPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionRecyclingMyNameActionRecyclingPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionRecyclingMyNameActionRecyclingPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionTaskExchangeMyNameActionTaskExchangePost invokes action_task_exchange_my__name__action_task_exchange_post operation.
//
// Exchange 3 tasks coins for a random reward. Rewards are exclusive resources for crafting  items.
//
// POST /my/{name}/action/task/exchange
func (c *Client) ActionTaskExchangeMyNameActionTaskExchangePost(ctx context.Context, params ActionTaskExchangeMyNameActionTaskExchangePostParams) (ActionTaskExchangeMyNameActionTaskExchangePostRes, error) {
	res, err := c.sendActionTaskExchangeMyNameActionTaskExchangePost(ctx, params)
	return res, err
}

func (c *Client) sendActionTaskExchangeMyNameActionTaskExchangePost(ctx context.Context, params ActionTaskExchangeMyNameActionTaskExchangePostParams) (res ActionTaskExchangeMyNameActionTaskExchangePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_task_exchange_my__name__action_task_exchange_post"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/task/exchange"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionTaskExchangeMyNameActionTaskExchangePost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/task/exchange"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionTaskExchangeMyNameActionTaskExchangePost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionTaskExchangeMyNameActionTaskExchangePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionUnequipItemMyNameActionUnequipPost invokes action_unequip_item_my__name__action_unequip_post operation.
//
// Unequip an item on your character.
//
// POST /my/{name}/action/unequip
func (c *Client) ActionUnequipItemMyNameActionUnequipPost(ctx context.Context, request *UnequipSchema, params ActionUnequipItemMyNameActionUnequipPostParams) (ActionUnequipItemMyNameActionUnequipPostRes, error) {
	res, err := c.sendActionUnequipItemMyNameActionUnequipPost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionUnequipItemMyNameActionUnequipPost(ctx context.Context, request *UnequipSchema, params ActionUnequipItemMyNameActionUnequipPostParams) (res ActionUnequipItemMyNameActionUnequipPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_unequip_item_my__name__action_unequip_post"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/unequip"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionUnequipItemMyNameActionUnequipPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/unequip"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionUnequipItemMyNameActionUnequipPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionUnequipItemMyNameActionUnequipPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionUnequipItemMyNameActionUnequipPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPost invokes action_withdraw_bank_gold_my__name__action_bank_withdraw_gold_post operation.
//
// Withdraw gold from your bank.
//
// POST /my/{name}/action/bank/withdraw/gold
func (c *Client) ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPost(ctx context.Context, request *DepositWithdrawGoldSchema, params ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostParams) (ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostRes, error) {
	res, err := c.sendActionWithdrawBankGoldMyNameActionBankWithdrawGoldPost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionWithdrawBankGoldMyNameActionBankWithdrawGoldPost(ctx context.Context, request *DepositWithdrawGoldSchema, params ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostParams) (res ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_withdraw_bank_gold_my__name__action_bank_withdraw_gold_post"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/bank/withdraw/gold"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/bank/withdraw/gold"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionWithdrawBankMyNameActionBankWithdrawPost invokes action_withdraw_bank_my__name__action_bank_withdraw_post operation.
//
// Take an item from your bank and put it in the character's inventory.
//
// POST /my/{name}/action/bank/withdraw
func (c *Client) ActionWithdrawBankMyNameActionBankWithdrawPost(ctx context.Context, request *SimpleItemSchema, params ActionWithdrawBankMyNameActionBankWithdrawPostParams) (ActionWithdrawBankMyNameActionBankWithdrawPostRes, error) {
	res, err := c.sendActionWithdrawBankMyNameActionBankWithdrawPost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionWithdrawBankMyNameActionBankWithdrawPost(ctx context.Context, request *SimpleItemSchema, params ActionWithdrawBankMyNameActionBankWithdrawPostParams) (res ActionWithdrawBankMyNameActionBankWithdrawPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_withdraw_bank_my__name__action_bank_withdraw_post"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/bank/withdraw"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionWithdrawBankMyNameActionBankWithdrawPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/bank/withdraw"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionWithdrawBankMyNameActionBankWithdrawPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionWithdrawBankMyNameActionBankWithdrawPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionWithdrawBankMyNameActionBankWithdrawPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChangePasswordMyChangePasswordPost invokes change_password_my_change_password_post operation.
//
// Change your account password. Changing the password reset the account token.
//
// POST /my/change_password
func (c *Client) ChangePasswordMyChangePasswordPost(ctx context.Context, request *ChangePassword) (ChangePasswordMyChangePasswordPostRes, error) {
	res, err := c.sendChangePasswordMyChangePasswordPost(ctx, request)
	return res, err
}

func (c *Client) sendChangePasswordMyChangePasswordPost(ctx context.Context, request *ChangePassword) (res ChangePasswordMyChangePasswordPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("change_password_my_change_password_post"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/change_password"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ChangePasswordMyChangePasswordPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/my/change_password"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeChangePasswordMyChangePasswordPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ChangePasswordMyChangePasswordPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeChangePasswordMyChangePasswordPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateAccountAccountsCreatePost invokes create_account_accounts_create_post operation.
//
// Create an account.
//
// POST /accounts/create
func (c *Client) CreateAccountAccountsCreatePost(ctx context.Context, request *AddAccountSchema) (CreateAccountAccountsCreatePostRes, error) {
	res, err := c.sendCreateAccountAccountsCreatePost(ctx, request)
	return res, err
}

func (c *Client) sendCreateAccountAccountsCreatePost(ctx context.Context, request *AddAccountSchema) (res CreateAccountAccountsCreatePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_account_accounts_create_post"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/accounts/create"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateAccountAccountsCreatePost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/accounts/create"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAccountAccountsCreatePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateAccountAccountsCreatePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateCharacterCharactersCreatePost invokes create_character_characters_create_post operation.
//
// Create new character on your account. You can create up to 5 characters.
//
// POST /characters/create
func (c *Client) CreateCharacterCharactersCreatePost(ctx context.Context, request *AddCharacterSchema) (CreateCharacterCharactersCreatePostRes, error) {
	res, err := c.sendCreateCharacterCharactersCreatePost(ctx, request)
	return res, err
}

func (c *Client) sendCreateCharacterCharactersCreatePost(ctx context.Context, request *AddCharacterSchema) (res CreateCharacterCharactersCreatePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_character_characters_create_post"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/characters/create"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateCharacterCharactersCreatePost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/characters/create"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateCharacterCharactersCreatePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "CreateCharacterCharactersCreatePost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateCharacterCharactersCreatePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GenerateTokenTokenPost invokes generate_token_token__post operation.
//
// Use your account as HTTPBasic Auth to generate your token to use the API. You can also generate
// your token directly on the website.
//
// POST /token/
func (c *Client) GenerateTokenTokenPost(ctx context.Context) (GenerateTokenTokenPostRes, error) {
	res, err := c.sendGenerateTokenTokenPost(ctx)
	return res, err
}

func (c *Client) sendGenerateTokenTokenPost(ctx context.Context) (res GenerateTokenTokenPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("generate_token_token__post"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/token/"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GenerateTokenTokenPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/token/"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:HTTPBasic"
			switch err := c.securityHTTPBasic(ctx, "GenerateTokenTokenPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HTTPBasic\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGenerateTokenTokenPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAllCharactersCharactersGet invokes get_all_characters_characters__get operation.
//
// Fetch characters details.
//
// GET /characters/
func (c *Client) GetAllCharactersCharactersGet(ctx context.Context, params GetAllCharactersCharactersGetParams) (GetAllCharactersCharactersGetRes, error) {
	res, err := c.sendGetAllCharactersCharactersGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAllCharactersCharactersGet(ctx context.Context, params GetAllCharactersCharactersGetParams) (res GetAllCharactersCharactersGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_all_characters_characters__get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/characters/"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAllCharactersCharactersGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/characters/"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAllCharactersCharactersGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAllCharactersLogsMyLogsGet invokes get_all_characters_logs_my_logs_get operation.
//
// History of the last 100 actions of all your characters.
//
// GET /my/logs
func (c *Client) GetAllCharactersLogsMyLogsGet(ctx context.Context, params GetAllCharactersLogsMyLogsGetParams) (GetAllCharactersLogsMyLogsGetRes, error) {
	res, err := c.sendGetAllCharactersLogsMyLogsGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAllCharactersLogsMyLogsGet(ctx context.Context, params GetAllCharactersLogsMyLogsGetParams) (res GetAllCharactersLogsMyLogsGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_all_characters_logs_my_logs_get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/logs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAllCharactersLogsMyLogsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/my/logs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "GetAllCharactersLogsMyLogsGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAllCharactersLogsMyLogsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAllEventsEventsGet invokes get_all_events_events__get operation.
//
// Fetch events details.
//
// GET /events/
func (c *Client) GetAllEventsEventsGet(ctx context.Context, params GetAllEventsEventsGetParams) (GetAllEventsEventsGetRes, error) {
	res, err := c.sendGetAllEventsEventsGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAllEventsEventsGet(ctx context.Context, params GetAllEventsEventsGetParams) (res GetAllEventsEventsGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_all_events_events__get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/events/"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAllEventsEventsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/events/"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAllEventsEventsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAllGeItemsGeGet invokes get_all_ge_items_ge__get operation.
//
// Fetch Grand Exchange items details.
//
// GET /ge/
func (c *Client) GetAllGeItemsGeGet(ctx context.Context, params GetAllGeItemsGeGetParams) (GetAllGeItemsGeGetRes, error) {
	res, err := c.sendGetAllGeItemsGeGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAllGeItemsGeGet(ctx context.Context, params GetAllGeItemsGeGetParams) (res GetAllGeItemsGeGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_all_ge_items_ge__get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/ge/"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAllGeItemsGeGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/ge/"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAllGeItemsGeGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAllItemsItemsGet invokes get_all_items_items__get operation.
//
// Fetch items details.
//
// GET /items/
func (c *Client) GetAllItemsItemsGet(ctx context.Context, params GetAllItemsItemsGetParams) (GetAllItemsItemsGetRes, error) {
	res, err := c.sendGetAllItemsItemsGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAllItemsItemsGet(ctx context.Context, params GetAllItemsItemsGetParams) (res GetAllItemsItemsGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_all_items_items__get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/items/"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAllItemsItemsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/items/"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "min_level" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "min_level",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MinLevel.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "max_level" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "max_level",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MaxLevel.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "craft_skill" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "craft_skill",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CraftSkill.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "craft_material" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "craft_material",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CraftMaterial.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAllItemsItemsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAllMapsMapsGet invokes get_all_maps_maps__get operation.
//
// Fetch maps details.
//
// GET /maps/
func (c *Client) GetAllMapsMapsGet(ctx context.Context, params GetAllMapsMapsGetParams) (GetAllMapsMapsGetRes, error) {
	res, err := c.sendGetAllMapsMapsGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAllMapsMapsGet(ctx context.Context, params GetAllMapsMapsGetParams) (res GetAllMapsMapsGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_all_maps_maps__get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/maps/"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAllMapsMapsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/maps/"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "content_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "content_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ContentType.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "content_code" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "content_code",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ContentCode.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAllMapsMapsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAllMonstersMonstersGet invokes get_all_monsters_monsters__get operation.
//
// Fetch monsters details.
//
// GET /monsters/
func (c *Client) GetAllMonstersMonstersGet(ctx context.Context, params GetAllMonstersMonstersGetParams) (GetAllMonstersMonstersGetRes, error) {
	res, err := c.sendGetAllMonstersMonstersGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAllMonstersMonstersGet(ctx context.Context, params GetAllMonstersMonstersGetParams) (res GetAllMonstersMonstersGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_all_monsters_monsters__get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/monsters/"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAllMonstersMonstersGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/monsters/"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "min_level" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "min_level",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MinLevel.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "max_level" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "max_level",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MaxLevel.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "drop" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "drop",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Drop.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAllMonstersMonstersGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAllResourcesResourcesGet invokes get_all_resources_resources__get operation.
//
// Fetch resources details.
//
// GET /resources/
func (c *Client) GetAllResourcesResourcesGet(ctx context.Context, params GetAllResourcesResourcesGetParams) (GetAllResourcesResourcesGetRes, error) {
	res, err := c.sendGetAllResourcesResourcesGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAllResourcesResourcesGet(ctx context.Context, params GetAllResourcesResourcesGetParams) (res GetAllResourcesResourcesGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_all_resources_resources__get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/resources/"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAllResourcesResourcesGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/resources/"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "min_level" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "min_level",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MinLevel.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "max_level" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "max_level",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MaxLevel.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "skill" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "skill",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Skill.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "drop" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "drop",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Drop.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAllResourcesResourcesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBankGoldsMyBankGoldGet invokes get_bank_golds_my_bank_gold_get operation.
//
// Fetch golds in your bank.
//
// GET /my/bank/gold
func (c *Client) GetBankGoldsMyBankGoldGet(ctx context.Context) (*GoldBankResponseSchema, error) {
	res, err := c.sendGetBankGoldsMyBankGoldGet(ctx)
	return res, err
}

func (c *Client) sendGetBankGoldsMyBankGoldGet(ctx context.Context) (res *GoldBankResponseSchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_bank_golds_my_bank_gold_get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/bank/gold"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetBankGoldsMyBankGoldGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/my/bank/gold"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "GetBankGoldsMyBankGoldGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetBankGoldsMyBankGoldGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBankItemsMyBankItemsGet invokes get_bank_items_my_bank_items_get operation.
//
// Fetch all items in your bank.
//
// GET /my/bank/items
func (c *Client) GetBankItemsMyBankItemsGet(ctx context.Context, params GetBankItemsMyBankItemsGetParams) (GetBankItemsMyBankItemsGetRes, error) {
	res, err := c.sendGetBankItemsMyBankItemsGet(ctx, params)
	return res, err
}

func (c *Client) sendGetBankItemsMyBankItemsGet(ctx context.Context, params GetBankItemsMyBankItemsGetParams) (res GetBankItemsMyBankItemsGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_bank_items_my_bank_items_get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/bank/items"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetBankItemsMyBankItemsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/my/bank/items"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "item_code" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "item_code",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ItemCode.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "GetBankItemsMyBankItemsGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetBankItemsMyBankItemsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCharacterCharactersNameGet invokes get_character_characters__name__get operation.
//
// Retrieve the details of a character.
//
// GET /characters/{name}
func (c *Client) GetCharacterCharactersNameGet(ctx context.Context, params GetCharacterCharactersNameGetParams) (GetCharacterCharactersNameGetRes, error) {
	res, err := c.sendGetCharacterCharactersNameGet(ctx, params)
	return res, err
}

func (c *Client) sendGetCharacterCharactersNameGet(ctx context.Context, params GetCharacterCharactersNameGetParams) (res GetCharacterCharactersNameGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_character_characters__name__get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/characters/{name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCharacterCharactersNameGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/characters/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCharacterCharactersNameGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCharacterLogsMyNameLogsGet invokes get_character_logs_my__name__logs_get operation.
//
// History of your character's last 100 actions.
//
// GET /my/{name}/logs
func (c *Client) GetCharacterLogsMyNameLogsGet(ctx context.Context, params GetCharacterLogsMyNameLogsGetParams) (GetCharacterLogsMyNameLogsGetRes, error) {
	res, err := c.sendGetCharacterLogsMyNameLogsGet(ctx, params)
	return res, err
}

func (c *Client) sendGetCharacterLogsMyNameLogsGet(ctx context.Context, params GetCharacterLogsMyNameLogsGetParams) (res GetCharacterLogsMyNameLogsGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_character_logs_my__name__logs_get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/{name}/logs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCharacterLogsMyNameLogsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/logs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "GetCharacterLogsMyNameLogsGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCharacterLogsMyNameLogsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetGeItemGeCodeGet invokes get_ge_item_ge__code__get operation.
//
// Retrieve the details of a Grand Exchange item.
//
// GET /ge/{code}
func (c *Client) GetGeItemGeCodeGet(ctx context.Context, params GetGeItemGeCodeGetParams) (GetGeItemGeCodeGetRes, error) {
	res, err := c.sendGetGeItemGeCodeGet(ctx, params)
	return res, err
}

func (c *Client) sendGetGeItemGeCodeGet(ctx context.Context, params GetGeItemGeCodeGetParams) (res GetGeItemGeCodeGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_ge_item_ge__code__get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/ge/{code}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetGeItemGeCodeGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/ge/"
	{
		// Encode "code" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "code",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Code))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetGeItemGeCodeGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetItemItemsCodeGet invokes get_item_items__code__get operation.
//
// Retrieve the details of a item.
//
// GET /items/{code}
func (c *Client) GetItemItemsCodeGet(ctx context.Context, params GetItemItemsCodeGetParams) (GetItemItemsCodeGetRes, error) {
	res, err := c.sendGetItemItemsCodeGet(ctx, params)
	return res, err
}

func (c *Client) sendGetItemItemsCodeGet(ctx context.Context, params GetItemItemsCodeGetParams) (res GetItemItemsCodeGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_item_items__code__get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/items/{code}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetItemItemsCodeGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/items/"
	{
		// Encode "code" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "code",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Code))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetItemItemsCodeGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMapMapsXYGet invokes get_map_maps__x___y__get operation.
//
// Retrieve the details of a map.
//
// GET /maps/{x}/{y}
func (c *Client) GetMapMapsXYGet(ctx context.Context, params GetMapMapsXYGetParams) (GetMapMapsXYGetRes, error) {
	res, err := c.sendGetMapMapsXYGet(ctx, params)
	return res, err
}

func (c *Client) sendGetMapMapsXYGet(ctx context.Context, params GetMapMapsXYGetParams) (res GetMapMapsXYGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_map_maps__x___y__get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/maps/{x}/{y}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetMapMapsXYGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/maps/"
	{
		// Encode "x" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "x",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.X))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "y" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "y",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.Y))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMapMapsXYGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMonsterMonstersCodeGet invokes get_monster_monsters__code__get operation.
//
// Retrieve the details of a monster.
//
// GET /monsters/{code}
func (c *Client) GetMonsterMonstersCodeGet(ctx context.Context, params GetMonsterMonstersCodeGetParams) (GetMonsterMonstersCodeGetRes, error) {
	res, err := c.sendGetMonsterMonstersCodeGet(ctx, params)
	return res, err
}

func (c *Client) sendGetMonsterMonstersCodeGet(ctx context.Context, params GetMonsterMonstersCodeGetParams) (res GetMonsterMonstersCodeGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_monster_monsters__code__get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/monsters/{code}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetMonsterMonstersCodeGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/monsters/"
	{
		// Encode "code" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "code",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Code))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMonsterMonstersCodeGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyCharactersMyCharactersGet invokes get_my_characters_my_characters_get operation.
//
// List of your characters.
//
// GET /my/characters
func (c *Client) GetMyCharactersMyCharactersGet(ctx context.Context) (GetMyCharactersMyCharactersGetRes, error) {
	res, err := c.sendGetMyCharactersMyCharactersGet(ctx)
	return res, err
}

func (c *Client) sendGetMyCharactersMyCharactersGet(ctx context.Context) (res GetMyCharactersMyCharactersGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_my_characters_my_characters_get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/characters"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetMyCharactersMyCharactersGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/my/characters"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "GetMyCharactersMyCharactersGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMyCharactersMyCharactersGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetResourcesResourcesCodeGet invokes get_resources_resources__code__get operation.
//
// Retrieve the details of a resource.
//
// GET /resources/{code}
func (c *Client) GetResourcesResourcesCodeGet(ctx context.Context, params GetResourcesResourcesCodeGetParams) (GetResourcesResourcesCodeGetRes, error) {
	res, err := c.sendGetResourcesResourcesCodeGet(ctx, params)
	return res, err
}

func (c *Client) sendGetResourcesResourcesCodeGet(ctx context.Context, params GetResourcesResourcesCodeGetParams) (res GetResourcesResourcesCodeGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_resources_resources__code__get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/resources/{code}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetResourcesResourcesCodeGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/resources/"
	{
		// Encode "code" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "code",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Code))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetResourcesResourcesCodeGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStatusGet invokes get_status__get operation.
//
// Return the status of the game server.
//
// GET /
func (c *Client) GetStatusGet(ctx context.Context) (*StatusResponseSchema, error) {
	res, err := c.sendGetStatusGet(ctx)
	return res, err
}

func (c *Client) sendGetStatusGet(ctx context.Context) (res *StatusResponseSchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_status__get"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetStatusGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetStatusGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
